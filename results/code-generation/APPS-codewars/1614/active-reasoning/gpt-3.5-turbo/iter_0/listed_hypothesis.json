{
    "0": [
        {
            "content": "def who_is_winner(pieces_positions):\n    # Create a grid to keep track of the game state\n    grid = [['' for _ in range(7)] for _ in range(6)]\n\n    # Iterate through each piece position in the list\n    for piece in pieces_positions:\n        # Extract the column and color from the piece position\n        column, color = piece.split('_')\n\n        # Convert the column letter to a numerical index\n        col_index = ord(column) - ord('A')\n\n        # Find the lowest empty row in the selected column\n        row_index = 0\n        while row_index < 6 and grid[row_index][col_index] != '':\n            row_index += 1\n\n        # Place the color in the selected position on the grid\n        grid[row_index][col_index] = color\n\n        # Check if the current move has resulted in a winning position\n        for line in LINES:\n            if all(grid[i][j] == color for j, i in line):\n                return color\n\n    # If there is no winner, return 'Draw'\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    # Create a 2D grid to represent the game board\n    grid = [['' for _ in range(7)] for _ in range(6)]\n    \n    # Iterate through the pieces_positions list\n    for piece in pieces_positions:\n        # Extract the column and color from each piece\n        col, color = piece.split('_')\n        \n        # Find the first available row in the chosen column\n        for row in range(5, -1, -1):\n            if grid[row][ord(col) - ord('A')] == '':\n                grid[row][ord(col) - ord('A')] = color\n                break\n    \n    # Check for a win in each line\n    for line in LINES:\n        for row, col in line:\n            if grid[row][ord(col) - ord('A')] == grid[row + 1][ord(col) - ord('A')] == \\\n               grid[row + 2][ord(col) - ord('A')] == grid[row + 3][ord(col) - ord('A')]:\n                return grid[row][ord(col) - ord('A')]\n    \n    # If no winner is found, return 'Draw'\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\n    def check_winner(grid):\n        for line in LINES:\n            if all(grid[cell] == grid[next(iter(line))] for cell in line):\n                return grid[next(iter(line))]\n        return None\n\n    grid = {pos: None for pos in COLUMNS}\n    for move in pieces_positions:\n        column, color = move.split('_')\n        grid[column] = color\n        winner = check_winner(grid)\n        if winner:\n            return winner\n\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "COLUMNS, ROWS = 'ABCDEFG', range(6)\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n    board = [['' for _ in range(7)] for _ in range(6)]\n    \n    for move in pieces_positions:\n        column, color = move.split('_')\n        row = 0\n        while row < 6 and board[row][COLUMNS.index(column)] != '':\n            row += 1\n        board[row][COLUMNS.index(column)] = color\n    \n    for line in LINES:\n        for color in ['Yellow', 'Red']:\n            if all(board[row][COLUMNS.index(column)] == color for column, row in line):\n                return color\n    \n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n            + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\n    def get_winner():\n        for line in LINES:\n            if all(pos in pieces_positions[player]\n                   for pos in line):\n                return player\n        return ''\n\n    players = ['Red', 'Yellow']\n    for piece in pieces_positions:\n        col, player = piece.split('_')\n        pieces_positions[player].add((col, min(ROWS - {pos[1]\n                                                       for pos in\n                                                       pieces_positions[col]})))\n        if get_winner():\n            return get_winner()\n        players = players[::-1]\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    # Create a grid to keep track of the moves\n    grid = [['' for _ in range(7)] for _ in range(6)]\n    \n    # Create a dictionary to map colors to players\n    color_to_player = {'Red': 'Red', 'Yellow': 'Yellow'}\n    \n    # Iterate over each move\n    for move in pieces_positions:\n        # Extract the column and color from the move\n        column, color = move.split('_')\n        \n        # Convert the column to an index\n        column_index = ord(column) - ord('A')\n        \n        # Find the lowest empty slot in the column\n        row_index = 5 - grid[::-1][column_index].index('')\n        \n        # Update the grid with the move\n        grid[row_index][column_index] = color\n        \n        # Check if the move results in a winning position\n        for line in LINES:\n            if all(grid[j][i] == color for i, j in line):\n                return color_to_player[color]\n    \n    # If no player has won, return 'Draw'\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n            + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\n    # initialize empty grid\n    grid = [['' for _ in ROWS] for _ in COLUMNS]\n    \n    # iterate over pieces_positions\n    for move in pieces_positions:\n        # get column and color from move\n        column, color = move.split('_')\n        \n        # find next available row in column\n        for row in ROWS:\n            if grid[COLUMNS.index(column)][row] == '':\n                # assign color to the grid cell\n                grid[COLUMNS.index(column)][row] = color\n                break\n    \n    # check if there is a winner\n    for line in LINES:\n        cells = [grid[COLUMNS.index(column)][row] for column, row in line]\n        if cells.count('Red') == 4:\n            return 'Red'\n        elif cells.count('Yellow') == 4:\n            return 'Yellow'\n    \n    # check if the grid is full\n    if all(all(cell != '' for cell in column) for column in grid):\n        return 'Draw'\n    \n    # if there is no winner and the grid is not full, the game is ongoing\n    return 'Ongoing'",
            "logp": null
        },
        {
            "content": "COLUMNS, ROWS = 'ABCDEFG', range(6)\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n    board = [[None] * len(ROWS) for _ in range(len(COLUMNS))]\n    for piece in pieces_positions:\n        column, color = piece.split('_')\n        board[COLUMNS.index(column)][board[COLUMNS.index(column)].index(None)] = color\n    \n    for line in LINES:\n        for i in range(len(COLUMNS) - 3):\n            for j in range(len(ROWS) - 3):\n                if all(board[COLUMNS.index(column)][row] == 'Yellow' for column, row in line):\n                    return 'Yellow'\n                if all(board[COLUMNS.index(column)][row] == 'Red' for column, row in line):\n                    return 'Red'\n    \n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n            + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n    \n    def get_color(piece):\n        return piece.split('_')[1]\n    \n    def get_column(piece):\n        return piece.split('_')[0]\n    \n    grid = [[None for _ in ROWS] for _ in COLUMNS]\n    for piece in pieces_positions:\n        column = get_column(piece)\n        color = get_color(piece)\n        column_index = COLUMNS.index(column)\n        for row in ROWS:\n            if grid[column_index][row] is None:\n                grid[column_index][row] = color\n                break\n    \n    for line in LINES:\n        colors = set()\n        for cell in line:\n            column, row = cell\n            column_index = COLUMNS.index(column)\n            colors.add(grid[column_index][row])\n        if len(colors) == 1 and None not in colors:\n            return colors.pop()\n    \n    return \"Draw\"",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n             for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n            + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\n    for piece in pieces_positions:\n        column, color = piece.split('_')\n        row = next((i for i in range(6) if (column, i) not in {piece for line in LINES for piece in line}), None)\n        if row is None:\n            return 'Draw'\n        for line in LINES:\n            if (column, row) in line:\n                if all((column, row) in pieces_positions for (column, row) in line):\n                    return color\n    return 'Draw'",
            "logp": null
        }
    ],
    "1": [
        {
            "content": "COLUMNS, ROWS = 'ABCDEFG', range(6)\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\ndef who_is_winner(pieces_positions):\n    board = {}\n    for move in pieces_positions:\n        column, color = move.split('_')\n        row = next((row for row in reversed(ROWS) if (column, row) not in board), None)\n        if row is not None:\n            board[(column, row)] = color\n            for line in LINES:\n                if all(board.get(cell) == color for cell in line):\n                    return color\n    return 'Draw'",
            "logp": null
        }
    ],
    "2": [
        {
            "content": "def who_is_winner(pieces_positions):\n    def check_winner(board):\n        for line in LINES:\n            cells = [board[cell] for cell in line]\n            if len(set(cells)) == 1 and '' not in cells:\n                return cells[0]\n        return 'Draw'\n\n    board = {(column, row): '' for column in COLUMNS for row in ROWS}\n    for piece_position in pieces_positions:\n        column, color = piece_position.split('_')\n        row = next(row for row in ROWS if board[column, row] == '')\n        board[column, row] = color\n\n        winner = check_winner(board)\n        if winner != 'Draw':\n            return winner\n\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n            + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n    board = [['' for _ in ROWS] for _ in COLUMNS]\n    for move in pieces_positions:\n        column, color = move.split('_')\n        board[COLUMNS.index(column)][next(i for i, cell in enumerate(board[COLUMNS.index(column)]) if not cell)] = color\n        for line in LINES:\n            if all(board[COLUMNS.index(c)][r] == color for c, r in line):\n                return color\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    board = [[\"\" for _ in range(7)] for _ in range(6)]\n    \n    for piece in pieces_positions:\n        column, color = piece.split(\"_\")\n        \n        for row in range(5, -1, -1):\n            if board[row][ord(column)-65] == \"\":\n                board[row][ord(column)-65] = color\n                break\n                \n        for line in LINES:\n            if all(board[row][ord(column)-65] == color for column, row in line):\n                return color\n            \n    return \"Draw\"",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    # Initialize the game grid with empty spaces\n    grid = [[' ' for _ in range(7)] for _ in range(6)]\n\n    # Dictionary to store the color of each column\n    column_colors = {}\n\n    # Variable to keep track of the current player\n    current_player = 'Red'\n\n    # Iterate over the pieces positions\n    for piece_position in pieces_positions:\n        # Split the piece position into column and color\n        column, color = piece_position.split('_')\n\n        # Find the row where the piece should be placed\n        row = -1\n        for i in range(5, -1, -1):\n            if grid[i][ord(column) - ord('A')] == ' ':\n                row = i\n                break\n\n        # Place the piece in the grid\n        grid[row][ord(column) - ord('A')] = color\n\n        # Check if the current player has won\n        for line in LINES:\n            if all(grid[row][ord(column) - ord('A')] == color for column, row in line):\n                return color\n\n        # Update the color of the column\n        column_colors[column] = color\n\n        # Switch to the next player\n        current_player = 'Yellow' if current_player == 'Red' else 'Red'\n\n    # If no player has won, check if the grid is full\n    if all(grid[i][j] != ' ' for i in range(6) for j in range(7)):\n        return 'Draw'\n\n    # If the game is not over, return None\n    return None",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    board = [[''] * 7 for _ in range(6)]\n    for piece in pieces_positions:\n        column = ord(piece[0]) - ord('A')\n        color = piece.split('_')[1]\n        for row in range(6):\n            if board[row][column] == '':\n                board[row][column] = color\n                break\n        for line in LINES:\n            if all(board[row][ord(column) - ord('A')] == color for column, row in line):\n                return color\n    return 'Draw'",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    # Create an empty board\n    board = [['' for _ in range(7)] for _ in range(6)]\n\n    # Create a dictionary to store the count of each color\n    count = {'Red': 0, 'Yellow': 0}\n\n    # Iterate over the pieces positions\n    for piece in pieces_positions:\n        # Split the piece position into column and color\n        column, color = piece.split('_')\n\n        # Find the row where the piece should be placed\n        row = 0\n        while row < 6 and board[row][ord(column)-ord('A')] != '':\n            row += 1\n\n        # Place the piece on the board\n        board[row][ord(column)-ord('A')] = color\n\n        # Check for a winning condition\n        for line in LINES:\n            if all(board[row][ord(column)-ord('A')] == color for column, row in line):\n                return color\n\n        # Update the count for the color\n        count[color] += 1\n\n        # Check if the game is a draw\n        if count['Red'] + count['Yellow'] == 42:\n            return 'Draw'\n\n    # If no winner and not a draw, return None\n    return None",
            "logp": null
        },
        {
            "content": "def who_is_winner(pieces_positions):\n    COLUMNS, ROWS = 'ABCDEFG', range(6)\n    LINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n            + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n            + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n               for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n    \n    red_moves = set()\n    yellow_moves = set()\n    for move in pieces_positions:\n        column, color = move.split(\"_\")\n        if color == \"Red\":\n            red_moves.add((column, len(red_moves)))\n        else:\n            yellow_moves.add((column, len(yellow_moves)))\n        \n        for line in LINES:\n            if line.issubset(red_moves):\n                return \"Red\"\n            elif line.issubset(yellow_moves):\n                return \"Yellow\"\n        \n    return \"Draw\"",
            "logp": null
        }
    ],
    "3": []
}