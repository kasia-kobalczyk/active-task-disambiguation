{
    "0": {
        "0": [
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    for mode, offset in config:\n        if notes[1] - notes[0] == offset and notes[2] - notes[1] == 7 - offset:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    chord_notes.sort()\n    interval1 = (chord_notes[1] - chord_notes[0]) % 12\n    interval2 = (chord_notes[2] - chord_notes[1]) % 12\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                index = NOTES.index(note_list)\n                notes[notes.index(note)] = index\n                break\n    notes = sorted(notes)\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for group in NOTES if n in group][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, options in enumerate(NOTES):\n            if note in options:\n                NOTES[i] = [note]\n                break\n    NOTES = [note[0] for note in NOTES]\n    chord_notes = tuple(sorted([ NOTES.index(note) for note in notes ]))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [x for x in chord.split() if x]\n    notes_exists = all(any(note in notes_list for note in notes) for notes_list in NOTES)\n    if not notes_exists:\n        return 'Not a chord'\n    chord_name = ' '.join(sorted(notes))\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(v) == tuple(notes)]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    chord_type = [mode for c, mode in DCT_CHORDS.items() if tuple(chord_notes) == c]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes[i] - notes[0] for i in range(1, 3))\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES.index(group)\n                notes[notes.index(note)] = i + 1\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for lst in NOTES:\n            if note in lst:\n                NOTES.index(lst)\n                break\n    notes_indices = [NOTES.index([n for n in NOTES if n.count(note)][0]) for note in notes]\n    intervals = [notes_indices[i+1] - notes_indices[i] for i in range(len(notes_indices) - 1)]\n    if intervals == [4, 3]:\n        return 'Major'\n    elif intervals == [3, 4]:\n        return 'Minor'\n    else:\n        return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        found = False\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                found = True\n                NOTES[i] = [note]\n                break\n        if not found:\n            return 'Not a chord'\n    chord = tuple(sorted(chord))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    for note in chord_notes:\n        found = False\n        for i, note_list in enumerate(notes):\n            if note in note_list:\n                notes[i] = [note]\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for group in NOTES:\n            if note in group:\n                note_index = NOTES.index(group)\n                notes[notes.index(note)] = note_index\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 4 and interval2 == 3:\n        return 'Major'\n    elif interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    flat = False\n    sharp = False\n    for note in chord_notes:\n        if '#' in note:\n            sharp = True\n        elif 'b' in note:\n            flat = True\n    if sharp and flat:\n        return 'Not a chord'\n    for i, note in enumerate(notes):\n        if note == chord_notes[0]:\n            first = i\n            break\n        elif isinstance(note, list):\n            for n in note:\n                if n == chord_notes[0]:\n                    first = i\n                    break\n    for i, note in enumerate(notes):\n        if note == chord_notes[1]:\n            second = i\n            break\n        elif isinstance(note, list):\n            for n in note:\n                if n == chord_notes[1]:\n                    second = i\n                    break\n    for i, note in enumerate(notes):\n        if note == chord_notes[2]:\n            third = i\n            break\n        elif isinstance(note, list):\n            for n in note:\n                if n == chord_notes[2]:\n                    third = i\n                    break\n    if abs(first - second) == 3 and abs(second - third) == 4:\n        return 'Minor'\n    elif abs(first - second) == 4 and abs(second - third) == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES[i] = [note]\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES[i].index(note)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    chord_indexes = [NOTES_INDEX] + [NOTES_INDEX + 3] + [NOTES_INDEX + 7]\n    chord_notes = tuple(next(note for note in group) for group in [NOTES[i] for i in chord_indexes])\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord_type = DCT_CHORDS.get(tuple(sorted(notes)))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_indices = {}\n    for i, note_group in enumerate(notes):\n        for note in note_group if isinstance(note_group, list) else [note_group]:\n            note_indices[note] = i\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    intervals = [(note_indices[chord_notes[i+1]] - note_indices[chord_notes[i]]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group, i)\n                notes[notes.index(note)] = NOTES.index(note_group)\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 4 and interval2 == 3:\n        return 'Major'\n    elif interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if all(note in key for note in notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    chord_type = None\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            chord_type = v\n            break\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, n in enumerate(NOTES):\n            if note in n:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    for note_set in NOTES:\n        if notes[0] in note_set:\n            base_index = NOTES.index(note_set)\n        for note_set in NOTES:\n            if notes[1] in note_set:\n                second_index = NOTES.index(note_set)\n        for note_set in NOTES:\n            if notes[2] in note_set:\n                third_index = NOTES.index(note_set)\n    interval1 = (second_index - base_index) % 12\n    interval2 = (third_index - second_index) % 12\n    if (interval1 == 3 and interval2 == 4) or (interval1 == 4 and interval2 == 3):\n        return 'Minor' if interval1 == 3 else 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_flatten = [note for sublist in NOTES for note in sublist]\n    if all(note in notes_flatten for note in notes):\n        notes_map = {note: idx for idx, sublist in enumerate(NOTES) for note in sublist}\n        notes_idx = [notes_map[note] % 12 for note in notes]\n        intervals = [(notes_idx[1] - notes_idx[0]) % 12, (notes_idx[2] - notes_idx[1]) % 12]\n        if intervals == [3, 4]:\n            return 'Minor'\n        elif intervals == [4, 3]:\n            return 'Major'\n        else:\n            return 'Not a chord'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if not any(note in note_list for note_list in NOTES):\n            return 'Not a chord'\n    note_index = [NOTES.index([n for n in NOTES if note in n][0]) % 12 for note in notes]\n    note_index.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if [i for i in NOTES for j in i if note in j]:\n            pass\n        else:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    note_values = []\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                note_values.append(i % 12)\n                break\n    intervals = [(note_values[i+1] - note_values[i]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ]
    },
    "1": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(notes) == v]\n    if chord_type:\n        return chord_type[0]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord_notes]\n    chord_notes.sort()\n    chord_name = tuple([NOTES[n][0] for n in chord_notes])\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if (interval1 == 4 and interval2 == 3) or (interval1 == 3 and interval2 == 4):\n        return 'Major' if interval1 == 4 else 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES[i] = [note]\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for note1, note2, note3 in DCT_CHORDS:\n        if all(note in [note1, note2, note3] for note in notes):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES[i].index(note)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord_type = DCT_CHORDS.get(tuple(sorted(notes)))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    for i, note in enumerate(chord_notes):\n        for j, n in enumerate(notes):\n            if note in n:\n                chord_notes[i] = j\n                break\n    if len(set(chord_notes)) != 3:\n        return 'Not a chord'\n    chord_notes.sort()\n    if chord_notes[1] - chord_notes[0] == 3 and chord_notes[2] - chord_notes[1] == 4:\n        return 'Minor'\n    elif chord_notes[1] - chord_notes[0] == 4 and chord_notes[2] - chord_notes[1] == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if all(note in key for note in notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = list(chord.split())\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, n in enumerate(NOTES):\n            if note in n:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    for note_set in NOTES:\n        if notes[0] in note_set:\n            base_index = NOTES.index(note_set)\n        for note_set in NOTES:\n            if notes[1] in note_set:\n                second_index = NOTES.index(note_set)\n        for note_set in NOTES:\n            if notes[2] in note_set:\n                third_index = NOTES.index(note_set)\n    interval1 = (second_index - base_index) % 12\n    interval2 = (third_index - second_index) % 12\n    if (interval1 == 3 and interval2 == 4) or (interval1 == 4 and interval2 == 3):\n        return 'Minor' if interval1 == 3 else 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_flatten = [note for sublist in NOTES for note in sublist]\n    if all(note in notes_flatten for note in notes):\n        notes_map = {note: idx for idx, sublist in enumerate(NOTES) for note in sublist}\n        notes_idx = [notes_map[note] % 12 for note in notes]\n        intervals = [(notes_idx[1] - notes_idx[0]) % 12, (notes_idx[2] - notes_idx[1]) % 12]\n        if intervals == [3, 4]:\n            return 'Minor'\n        elif intervals == [4, 3]:\n            return 'Major'\n        else:\n            return 'Not a chord'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, n in enumerate(NOTES):\n            if note in n:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if not any(note in note_list for note_list in NOTES):\n            return 'Not a chord'\n    note_index = [NOTES.index([n for n in NOTES if note in n][0]) % 12 for note in notes]\n    note_index.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    note_values = []\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                note_values.append(i % 12)\n                break\n    intervals = [(note_values[i+1] - note_values[i]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ]
    },
    "2": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if (interval1 == 4 and interval2 == 3) or (interval1 == 3 and interval2 == 4):\n        return 'Major' if interval1 == 4 else 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    note_config = tuple(notes[0], notes[1] - notes[0], notes[2] - notes[1])\n    if note_config in DCT_CHORDS:\n        return DCT_CHORDS[note_config]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for l in NOTES if n in l][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, n in enumerate(NOTES):\n            if note in n:\n                notes[NOTES.index(n)] = i\n                break\n    notes.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    return chord_type if chord_type else 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for note_set in NOTES if n in note_set][0]) for n in notes]))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    for note, mode in DCT_CHORDS.items():\n        if set(note) == set(notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    chord_tuple = tuple(min(NOTES[i] + NOTES[i + 12], key=lambda x: abs(ord(x[0]) - ord(c[0]))) for i, c in enumerate(chord))\n    return DCT_CHORDS.get(chord_tuple, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    chord_tup = tuple(sorted([notes[0], notes[1], notes[2]]))\n    if idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    elif idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif chord_tup in DCT_CHORDS:\n        return DCT_CHORDS[chord_tup]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    notes = [NOTES.index(note) for note in notes]\n    notes.sort()\n    chord_type = [key for key, value in DCT_CHORDS.items() if tuple(notes) == value]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES[i].index(note)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    notes = [next(group for group in NOTES for n in group if n == note) for note in notes]\n    notes = [NOTES.index(note) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord_type = DCT_CHORDS.get(tuple(sorted(notes)))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {note[0] if isinstance(note, list) else note: i for i, note in enumerate(notes)}\n    chord_notes = chord.split()\n    chord_notes = [note_dict[next(note for note in note_list if note in note_dict) if isinstance(note_list, list) else note_list] for note_list in notes if any(note in chord_notes for note in note_list)]\n    chord_notes.sort()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    interval1 = chord_notes[1] - chord_notes[0]\n    interval2 = chord_notes[2] - chord_notes[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    for i, note in enumerate(chord_notes):\n        for j, n in enumerate(notes):\n            if note in n:\n                chord_notes[i] = j\n                break\n    if len(set(chord_notes)) != len(chord_notes):\n        return 'Not a chord'\n    intervals = [(chord_notes[1] - chord_notes[0]) % 12, (chord_notes[2] - chord_notes[1]) % 12]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [note for note in NOTES for n in note]\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES.index(note_list)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split() if note]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_indices = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for n in note:\n                note_indices[n] = i\n        else:\n            note_indices[note] = i\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    indices = [note_indices[note] for note in chord_notes]\n    intervals = [(indices[1] - indices[0]) % 12, (indices[2] - indices[1]) % 12]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES[i] = [note]\n                break\n    for mode, offset in config:\n        if tuple(notes) in DCT_CHORDS and DCT_CHORDS[tuple(notes)] == mode:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if [i for i in NOTES for j in i if note in j]:\n            pass\n        else:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if not any(note in note_list for note_list in NOTES):\n            return 'Not a chord'\n    note_index = [NOTES.index([n for n in NOTES if note in n][0]) % 12 for note in notes]\n    note_index.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        intervals = [(note_index[i + 1] - note_index[i]) % 12 for i in range(2)]\n        if intervals == [3, 4]:\n            return 'Minor'\n        elif intervals == [4, 3]:\n            return 'Major'\n        else:\n            return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if [i for i in NOTES for j in i if note in j]:\n            pass\n        else:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    note_values = []\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                note_values.append(i % 12)\n                break\n    intervals = [(note_values[1] - note_values[0]) % 12, (note_values[2] - note_values[1]) % 12]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    }
}