{
    "0": {
        "0": [
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    chord_notes.sort()\n    interval1 = (chord_notes[1] - chord_notes[0]) % 12\n    interval2 = (chord_notes[2] - chord_notes[1]) % 12\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    for mode, offset in config:\n        if (notes[1] - notes[0]) % 12 == offset and (notes[2] - notes[1]) % 12 == 7 - offset:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                index = NOTES.index(note_list)\n                notes[notes.index(note)] = index\n                break\n    notes = sorted(notes)\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for group in NOTES if n in group][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, options in enumerate(NOTES):\n            if note in options:\n                NOTES[i] = [note]\n                break\n    NOTES = [note[0] for note in NOTES]\n    chord_notes = tuple(sorted([ NOTES.index(note) for note in notes ]))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [x for x in NOTES for y in x]\n    notes_dict = {notes[i]: i for i in range(len(notes))}\n    notes_in_chord = chord.split()\n    notes_in_chord = [note for note in notes_in_chord for note in NOTES if note in note]\n    if len(notes_in_chord) != 3:\n        return 'Not a chord'\n    intervals = [(notes_dict[notes_in_chord[1]]) - (notes_dict[notes_in_chord[0]]), \n                 (notes_dict[notes_in_chord[2]]) - (notes_dict[notes_in_chord[1]])]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(notes) == v]\n    if chord_type:\n        return chord_type[0]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord_notes]\n    chord_notes.sort()\n    chord_name = tuple([NOTES[n][0] for n in chord_notes])\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    chord_config = tuple(sorted(chord))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for lst in NOTES:\n            if note in lst:\n                NOTES[NOTES.index(lst)] = [note]\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(chord.split())\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    chord = tuple(sorted(notes))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([n for note_set in NOTES for i, note_set in enumerate(note_set) if note in note_set][0] for n in notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES.index(note_list, i)\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    flat = False\n    sharp = False\n    for note in chord_notes:\n        if '#' in note:\n            sharp = True\n        if 'b' in note:\n            flat = True\n    if sharp and flat:\n        return 'Not a chord'\n    for note in notes:\n        if isinstance(note, list):\n            for n in note:\n                if n in chord_notes:\n                    chord_notes[chord_notes.index(n)] = notes.index(note)\n        else:\n            if note in chord_notes:\n                chord_notes[chord_notes.index(note)] = notes.index(note)\n    intervals = [(chord_notes[i + 1] - chord_notes[i]) % 12 for i in range(len(chord_notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n        notes_index.append(NOTES_INDEX)\n    notes_index.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    chord_type = None\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            chord_type = v\n            break\n    if chord_type == 'Major':\n        return 'Major'\n    elif chord_type == 'Minor':\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_values = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for n in note:\n                note_values[n] = i\n        else:\n            note_values[note] = i\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in note_values:\n            return 'Not a chord'\n    intervals = [(note_values[chord_notes[i]] - note_values[chord_notes[i - 1]]) % 12 for i in range(1, 3)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "1": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    for note in notes:\n        for notes_lst in NOTES:\n            if note in notes_lst:\n                NOTES.remove(notes_lst)\n                NOTES.insert(0, notes_lst)\n                break\n    chord_notes = [NOTES.index([note]) for note in notes]\n    chord_notes.sort()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES[i] = [note]\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(chord.split())\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES.index(note_group)\n                NOTES.index(note_group)\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([n for note_set in NOTES for i, note_set in enumerate(note_set) if note in note_set][0] for n in notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[1:-1].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {note[0] if isinstance(note, list) else note: i for i, note in enumerate(notes)}\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    notes_nums = [note_dict[note] if note in note_dict else [i for i, ns in enumerate(notes) if note in ns][0] for note in chord_notes]\n    intervals = [(notes_nums[i + 1] - notes_nums[i]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    chord_type = None\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            chord_type = v\n            break\n    if chord_type == 'Major':\n        return 'Major'\n    elif chord_type == 'Minor':\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "2": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in DCT_CHORDS:\n        if set(chord_notes) == set(notes):\n            return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for l in NOTES if n in l][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, n in enumerate(NOTES):\n            if note in n:\n                notes[notes.index(note)] = i\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    if idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for note_set in NOTES if n in note_set][0]) for n in notes]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    notes = [NOTES.index(note) for note in notes]\n    notes.sort()\n    chord_type = 'Not a chord'\n    for key, value in DCT_CHORDS.items():\n        if tuple(notes) == key:\n            chord_type = value\n    return chord_type"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    chord_indexes = [NOTES_INDEX] + [NOTES_INDEX + 3] + [NOTES_INDEX + 7]\n    chord_notes = tuple(next(note for note in group) for group in [NOTES[i] for i in chord_indexes])\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_values = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for n in note:\n                note_values[n] = i\n        else:\n            note_values[note] = i\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    intervals = [(note_values[chord_notes[i+1]] - note_values[chord_notes[i]]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([n for note_set in NOTES for i, note_set in enumerate(note_set) if note in note_set][0] for n in notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[1:-1].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {note[0] if isinstance(note, list) else note: i for i, note in enumerate(notes)}\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    notes_nums = [note_dict[note] if note in note_dict else [i for i, ns in enumerate(notes) if note in ns][0] for note in chord_notes]\n    intervals = [(notes_nums[i+1] - notes_nums[i]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_values = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for n in note:\n                note_values[n] = i\n        else:\n            note_values[note] = i\n    chord_notes = chord.split()\n    chord_values = [note_values[note] for note in chord_notes]\n    intervals = [(chord_values[i+1] - chord_values[i]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return 'Major' if 'Major' in DCT_CHORDS[(note1, note2, note3)] else 'Minor'\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ]
    }
}