{
    "0": [
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flat = [note for sublist in notes for note in (sublist if isinstance(sublist, list) else [sublist])]\n    \n    chord_elements = chord.split()\n    \n    if len(chord_elements) != 3 or any(note not in notes_flat for note in chord_elements):\n        return 'Not a chord'\n    \n    first_index = notes_flat.index(chord_elements[0])\n    second_index = notes_flat.index(chord_elements[1])\n    third_index = notes_flat.index(chord_elements[2])\n    \n    interval1 = (second_index - first_index) % 12\n    interval2 = (third_index - second_index) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note for sublist in notes for note in (sublist if isinstance(sublist, list) else [sublist])]\n    \n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3 or not all(note in flat_notes for note in chord_notes):\n        return 'Not a chord'\n\n    intervals = []\n    for i in range(2):\n        interval = (flat_notes.index(chord_notes[i + 1]) - flat_notes.index(chord_notes[i])) % 12\n        intervals.append(interval)\n    \n    total_interval = (flat_notes.index(chord_notes[2]) - flat_notes.index(chord_notes[0])) % 12\n\n    if intervals == [3, 4] and total_interval == 7:\n        return 'Minor'\n    elif intervals == [4, 3] and total_interval == 7:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flat = [item for sublist in notes for item in (sublist if isinstance(sublist, list) else [sublist])]\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3 or any(note not in notes_flat for note in chord_notes):\n        return 'Not a chord'\n    \n    first, second, third = chord_notes\n    first_index = notes_flat.index(first)\n    second_index = notes_flat.index(second)\n    third_index = notes_flat.index(third)\n    \n    interval1 = (second_index - first_index) % 12\n    interval2 = (third_index - second_index) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note for sublist in notes for note in (sublist if isinstance(sublist, list) else [sublist])]\n    \n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3 or not all(note in flat_notes for note in chord_notes):\n        return 'Not a chord'\n    \n    first, second, third = chord_notes\n    \n    first_index = flat_notes.index(first)\n    second_index = flat_notes.index(second)\n    third_index = flat_notes.index(third)\n    \n    interval_1_2 = (second_index - first_index) % 12\n    interval_2_3 = (third_index - second_index) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flat = [note if isinstance(note, str) else note for note in notes]\n    \n    note_list = chord.split()\n    if len(note_list) != 3:\n        return 'Not a chord'\n\n    indices = []\n    for note in note_list:\n        found = False\n        for i, n in enumerate(notes_flat):\n            if n == note:\n                indices.append(i)\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    \n    interval_1_2 = (indices[1] - indices[0]) % 12\n    interval_2_3 = (indices[2] - indices[1]) % 12\n\n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note for sublist in notes for note in (sublist if isinstance(sublist, list) else [sublist])]\n    chord_notes = chord.split()\n\n    if len(chord_notes) != 3 or not all(note in flat_notes for note in chord_notes):\n        return 'Not a chord'\n\n    first, second, third = chord_notes\n    first_index = flat_notes.index(first)\n    second_index = flat_notes.index(second)\n    third_index = flat_notes.index(third)\n\n    interval1 = (second_index - first_index) % 12\n    interval2 = (third_index - second_index) % 12\n\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note for sublist in notes for note in (sublist if isinstance(sublist, list) else [sublist])]\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    intervals = []\n    for i in range(3):\n        note_index = flat_notes.index(chord_notes[i])\n        next_note_index = flat_notes.index(chord_notes[(i + 1) % 3])\n        interval = (next_note_index - note_index) % 12\n        intervals.append(interval)\n    \n    if intervals == [3, 4]:  # Minor\n        return 'Minor'\n    elif intervals == [4, 3]:  # Major\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    \n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    indices = []\n    for note in chord_notes:\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                indices.append(i)\n                break\n        else:\n            return 'Not a chord'\n    \n    interval_1_2 = (indices[1] - indices[0]) % 12\n    interval_2_3 = (indices[2] - indices[1]) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_index = {note: i for i, note in enumerate(notes) for note in (note if isinstance(note, list) else [note])}\n    \n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    indexes = [note_index[note] for note in chord_notes if note in note_index]\n    \n    if len(indexes) != 3:\n        return 'Not a chord'\n    \n    intervals = [(indexes[1] - indexes[0]) % 12, (indexes[2] - indexes[1]) % 12]\n    \n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_list = chord.split()\n    \n    if len(chord_list) != 3:\n        return 'Not a chord'\n    \n    positions = []\n    for note in chord_list:\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                positions.append(i)\n                break\n    else:\n        return 'Not a chord'\n\n    intervals = [positions[1] - positions[0], positions[2] - positions[1]]\n    \n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        }
    ],
    "1": [
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    \n    note_indices = []\n    chromatic_scale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    for note in notes:\n        if note in chromatic_scale:\n            note_indices.append(chromatic_scale.index(note))\n        else:\n            return 'Not a chord'\n    \n    interval1 = (note_indices[1] - note_indices[0]) % 12\n    interval2 = (note_indices[2] - note_indices[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    \n    return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    chord_notes = chord.split()\n\n    if len(chord_notes) != 3 or not all(note in flat_notes for note in chord_notes):\n        return 'Not a chord'\n\n    intervals = [flat_notes.index(chord_notes[i + 1]) - flat_notes.index(chord_notes[i]) for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    intervals = []\n    for note in chord_notes:\n        index = next((i for i, n in enumerate(notes) if note in (n if isinstance(n, list) else [n])), None)\n        if index is None:\n            return 'Not a chord'\n        intervals.append(index)\n    \n    interval_1_2 = (intervals[1] - intervals[0]) % 12\n    interval_2_3 = (intervals[2] - intervals[1]) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    \n    return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    def get_index(note):\n        for i, n in enumerate(notes):\n            if note in n:\n                return i\n        return -1\n    \n    first, second, third = map(get_index, chord_notes)\n    \n    if first == -1 or second == -1 or third == -1:\n        return 'Not a chord'\n    \n    interval1 = (second - first) % 12\n    interval2 = (third - second) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    def find_note_index(note):\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                return i\n        return -1\n\n    indices = [find_note_index(note) for note in chord_notes]\n    \n    if -1 in indices:\n        return 'Not a chord'\n    \n    interval1 = indices[1] - indices[0]\n    interval2 = indices[2] - indices[1]\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    \n    return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    def get_note_index(note):\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                return i\n        return None\n\n    first, second, third = map(get_note_index, chord_notes)\n    \n    if None in (first, second, third):\n        return 'Not a chord'\n    \n    interval1 = second - first\n    interval2 = third - second\n\n    if interval1 < 0:\n        interval1 += 12\n    if interval2 < 0:\n        interval2 += 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {note: i for i, note in enumerate(notes) if isinstance(note, str) or isinstance(note, list) for note in (note if isinstance(note, list) else [note])}\n\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3 or not all(note in note_dict for note in chord_notes):\n        return 'Not a chord'\n    \n    intervals = [note_dict[chord_notes[1]] - note_dict[chord_notes[0]],\n                 note_dict[chord_notes[2]] - note_dict[chord_notes[1]]]\n    \n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    \n    note_indices = []\n    note_dict = {note: index for index, note in enumerate(['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'])}\n    \n    for note in notes:\n        if note in note_dict:\n            note_indices.append(note_dict[note])\n        else:\n            return 'Not a chord'\n    \n    interval1 = (note_indices[1] - note_indices[0]) % 12\n    interval2 = (note_indices[2] - note_indices[1]) % 12\n\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    \n    return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flattened_notes = [item if isinstance(item, str) else item[0] for item in notes]\n    note_indices = {note: idx for idx, note in enumerate(flattened_notes)}\n\n    chord_notes = chord.split()\n    if len(chord_notes) != 3 or any(note not in note_indices for note in chord_notes):\n        return 'Not a chord'\n\n    first, second, third = chord_notes\n    interval_1_2 = (note_indices[second] - note_indices[first]) % 12\n    interval_2_3 = (note_indices[third] - note_indices[second]) % 12\n\n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    try:\n        indices = [notes.index(note) for note in chord_notes]\n    except ValueError:\n        return 'Not a chord'\n\n    interval1 = (indices[1] - indices[0]) % 12\n    interval2 = (indices[2] - indices[1]) % 12\n\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    \n    note_indices = []\n    chromatic_scale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    \n    for note in notes:\n        if note in chromatic_scale:\n            note_indices.append(chromatic_scale.index(note))\n        else:\n            return 'Not a chord'\n    \n    interval1 = (note_indices[1] - note_indices[0]) % 12\n    interval2 = (note_indices[2] - note_indices[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    indices = []\n    for note in chord_notes:\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                indices.append(i)\n                break\n        else:\n            return 'Not a chord'\n    \n    interval_1_2 = (indices[1] - indices[0]) % 12\n    interval_2_3 = (indices[2] - indices[1]) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        }
    ],
    "2": [
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    \n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n\n    positions = [flat_notes.index(note) if note in flat_notes else flat_notes.index(note[0]) for note in chord_notes]\n\n    interval1 = (positions[1] - positions[0]) % 12\n    interval2 = (positions[2] - positions[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [n if isinstance(n, str) else n[0] for n in notes]\n    note_indices = {note: index for index, note in enumerate(flat_notes)}\n    \n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    indices = [note_indices[note] for note in chord_notes if note in note_indices]\n    \n    if len(indices) != 3:\n        return 'Not a chord'\n    \n    interval1 = (indices[1] - indices[0]) % 12\n    interval2 = (indices[2] - indices[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    \n    note_indices = []\n    chromatic_scale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    \n    for note in notes:\n        if note in chromatic_scale:\n            note_indices.append(chromatic_scale.index(note))\n        else:\n            return 'Not a chord'\n    \n    interval_1_2 = (note_indices[1] - note_indices[0]) % 12\n    interval_2_3 = (note_indices[2] - note_indices[1]) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n\n    intervals = []\n    for note in chord_notes:\n        if note not in notes:\n            return 'Not a chord'\n        intervals.append(notes.index(note))\n    \n    interval1 = (intervals[1] - intervals[0]) % 12\n    interval2 = (intervals[2] - intervals[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    \n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n\n    def find_index(note):\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                return i\n        return -1\n\n    first, second, third = map(find_index, chord_notes)\n    if first == -1 or second == -1 or third == -1:\n        return 'Not a chord'\n\n    interval_1_2 = (second - first) % 12\n    interval_2_3 = (third - second) % 12\n\n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    def get_note_index(note):\n        for i, n in enumerate(notes):\n            if isinstance(n, list):\n                if note in n:\n                    return i\n            elif note == n:\n                return i\n        return -1\n    \n    indices = [get_note_index(n) for n in chord_notes]\n    \n    if -1 in indices:\n        return 'Not a chord'\n    \n    interval1 = (indices[1] - indices[0]) % 12\n    interval2 = (indices[2] - indices[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for variant in note:\n                note_dict[variant] = i\n        else:\n            note_dict[note] = i\n\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    try:\n        first = note_dict[chord_notes[0]]\n        second = note_dict[chord_notes[1]]\n        third = note_dict[chord_notes[2]]\n    except KeyError:\n        return 'Not a chord'\n\n    interval1 = (second - first) % 12\n    interval2 = (third - second) % 12\n\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3 or any(note not in flat_notes for note in chord_notes):\n        return 'Not a chord'\n    \n    first, second, third = chord_notes\n    first_index = flat_notes.index(first)\n    second_index = flat_notes.index(second)\n    third_index = flat_notes.index(third)\n    \n    interval_1_2 = (second_index - first_index) % 12\n    interval_2_3 = (third_index - second_index) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    \n    chord_list = chord.split()\n    \n    if len(chord_list) != 3:\n        return 'Not a chord'\n    \n    indices = [flat_notes.index(note) for note in chord_list if note in flat_notes]\n    \n    if len(indices) != 3:\n        return 'Not a chord'\n    \n    intervals = [(indices[1] - indices[0]) % 12, (indices[2] - indices[1]) % 12]\n    \n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        }
    ],
    "3": [
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    \n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n\n    intervals = []\n    for note in chord_notes:\n        if note not in flat_notes:\n            return 'Not a chord'\n        intervals.append(flat_notes.index(note))\n\n    interval1 = intervals[1] - intervals[0] if intervals[1] >= intervals[0] else intervals[1] + 12 - intervals[0]\n    interval2 = intervals[2] - intervals[1] if intervals[2] >= intervals[1] else intervals[2] + 12 - intervals[1]\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [n if isinstance(n, str) else n[0] for n in notes]\n    note_indices = {note: index for index, note in enumerate(flat_notes)}\n    \n    chord_elements = chord.split()\n    \n    if len(chord_elements) != 3:\n        return 'Not a chord'\n    \n    indices = [note_indices[note] for note in chord_elements if note in note_indices]\n    \n    if len(indices) != 3:\n        return 'Not a chord'\n    \n    intervals = [(indices[i] - indices[i-1]) % 12 for i in range(1, 3)]\n    \n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    first, second, third = chord_notes\n    \n    if first not in notes or second not in notes or third not in notes:\n        return 'Not a chord'\n    \n    first_index = notes.index(first)\n    second_index = notes.index(second)\n    third_index = notes.index(third)\n    \n    interval_1_2 = (second_index - first_index) % 12\n    interval_2_3 = (third_index - second_index) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    \n    note_indices = []\n    chromatic_scale = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B']\n    \n    for note in notes:\n        if note in chromatic_scale:\n            note_indices.append(chromatic_scale.index(note))\n        else:\n            return 'Not a chord'\n    \n    interval_1_2 = (note_indices[1] - note_indices[0]) % 12\n    interval_2_3 = (note_indices[2] - note_indices[1]) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes_list = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes_list]\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    intervals = []\n    for i in range(2):\n        first_index = flat_notes.index(chord_notes[i])\n        second_index = flat_notes.index(chord_notes[i + 1])\n        interval = (second_index - first_index) % 12\n        intervals.append(interval)\n    \n    if sum(intervals) == 7 and intervals == [3, 4]:\n        return 'Minor'\n    elif sum(intervals) == 7 and intervals == [4, 3]:\n        return 'Major'\n    \n    return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    \n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n\n    def find_index(note):\n        for i, n in enumerate(notes):\n            if note in (n if isinstance(n, list) else [n]):\n                return i\n        return -1\n\n    first, second, third = map(find_index, chord_notes)\n    if first == -1 or second == -1 or third == -1:\n        return 'Not a chord'\n\n    interval_1_2 = (second - first) % 12\n    interval_2_3 = (third - second) % 12\n\n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    def get_note_index(note):\n        for i, n in enumerate(notes):\n            if isinstance(n, list):\n                if note in n:\n                    return i\n            elif note == n:\n                return i\n        return -1\n    \n    indices = [get_note_index(n) for n in chord_notes]\n    \n    if -1 in indices:\n        return 'Not a chord'\n    \n    interval1 = (indices[1] - indices[0]) % 12\n    interval2 = (indices[2] - indices[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for variant in note:\n                note_dict[variant] = i\n        else:\n            note_dict[note] = i\n\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    try:\n        first = note_dict[chord_notes[0]]\n        second = note_dict[chord_notes[1]]\n        third = note_dict[chord_notes[2]]\n    except KeyError:\n        return 'Not a chord'\n\n    interval1 = (second - first) % 12\n    interval2 = (third - second) % 12\n\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    \n    return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    intervals = []\n    for i in range(3):\n        note_index = flat_notes.index(chord_notes[i])\n        intervals.append(note_index)\n    \n    interval1 = (intervals[1] - intervals[0]) % 12\n    interval2 = (intervals[2] - intervals[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    \n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    \n    def get_semi_tone_distance(note1, note2):\n        idx1 = next(i for i, n in enumerate(notes) if note1 in (n if isinstance(n, list) else [n]))\n        idx2 = next(i for i, n in enumerate(notes) if note2 in (n if isinstance(n, list) else [n]))\n        return (idx2 - idx1) % 12\n\n    interval1 = get_semi_tone_distance(chord_notes[0], chord_notes[1])\n    interval2 = get_semi_tone_distance(chord_notes[1], chord_notes[2])\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    chord_notes = chord.split()\n    \n    if len(chord_notes) != 3 or any(note not in flat_notes for note in chord_notes):\n        return 'Not a chord'\n    \n    first, second, third = chord_notes\n    first_index = flat_notes.index(first)\n    second_index = flat_notes.index(second)\n    third_index = flat_notes.index(third)\n    \n    interval_1_2 = (second_index - first_index) % 12\n    interval_2_3 = (third_index - second_index) % 12\n    \n    if interval_1_2 == 3 and interval_2_3 == 4:\n        return 'Minor'\n    elif interval_1_2 == 4 and interval_2_3 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        },
        {
            "content": "```python\ndef minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flat_notes = [note if isinstance(note, str) else note[0] for note in notes]\n    \n    chord_list = chord.split()\n    \n    if len(chord_list) != 3:\n        return 'Not a chord'\n    \n    note_indices = [flat_notes.index(note) for note in chord_list]\n    \n    interval1 = (note_indices[1] - note_indices[0]) % 12\n    interval2 = (note_indices[2] - note_indices[1]) % 12\n    \n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'\n```",
            "logp": null
        }
    ]
}