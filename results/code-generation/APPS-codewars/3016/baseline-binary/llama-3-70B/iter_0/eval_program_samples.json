{
    "0": {
        "0": [
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    chord_notes.sort()\n    interval1 = (chord_notes[1] - chord_notes[0]) % 12\n    interval2 = (chord_notes[2] - chord_notes[1]) % 12\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                NOTES[NOTES.index(note_list)].remove(note)\n    notes = [NOTES.index([n][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for n in notes:\n        found = False\n        for i, note_set in enumerate(NOTES):\n            if n in note_set:\n                found = True\n                notes[notes.index(n)] = i\n                break\n        if not found:\n            return 'Not a chord'\n    notes = tuple(sorted(notes))\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for group in NOTES if n in group][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, options in enumerate(NOTES):\n            if note in options:\n                NOTES[i] = [note]\n                break\n    NOTES = [note[0] for note in NOTES]\n    chord_notes = tuple(sorted([ NOTES.index(note) for note in notes ]))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    for mode, offset in config:\n        if (notes[1] - notes[0] == offset and \n            notes[2] - notes[1] == (7 - offset) and \n            tuple(sorted(notes)) in DCT_CHORDS and \n            DCT_CHORDS[tuple(sorted(notes))] == mode):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [x for x in chord.split() if x]\n    notes_exists = all(any(note in notes_list for note in notes) for notes_list in NOTES)\n    if not notes_exists:\n        return 'Not a chord'\n    chord_name = ' '.join(sorted(notes))\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_normalized = [min((n for n in note for n in NOTES if n == note), key=lambda x: NOTES.index(x)) for note in notes]\n    notes_normalized.sort(key=lambda x: NOTES.index(x))\n    if tuple(notes_normalized) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes_normalized)]\n    else:\n        return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                index = NOTES.index(note_list)\n                notes[notes.index(note)] = index\n                break\n    notes = sorted(notes)\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in product(*[n for n in NOTES for note in chord_notes if note in n]):\n        chord_name = ' '.join(notes)\n        if chord_name in DCT_CHORDS:\n            return DCT_CHORDS[chord_name]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    chord_tup = tuple(sorted([notes[0], notes[1], notes[2]]))\n    if idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    elif idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif chord_tup in DCT_CHORDS:\n        return DCT_CHORDS[chord_tup]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                notes[notes.index(note)] = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    notes = [''.join(n) for n in NOTES[:len(notes)]]\n    chord = ' '.join(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if len(notes) != 3:\n        return 'Not a chord'\n    chord_notes = tuple(sorted(set(note for note_list in NOTES for note in note_list if any(n in note_list for n in notes))))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES.index([note]) if NOTES.index(group) == i else NOTES.index(group) + 12\n                note_index = i\n                break\n    intervals = [(notes[i], notes[i+1]) for i in range(2)]\n    for interval in intervals:\n        for note1 in NOTES[note_index]:\n            for note2 in NOTES[note_index + 4 if interval == (notes[0], notes[1]) else note_index + 3]:\n                if (note1, note2) == interval:\n                    if intervals == [(notes[0], notes[1]), (notes[1], notes[2])]:\n                        return 'Major'\n                    else:\n                        return 'Minor'\n    return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        found = False\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                found = True\n                NOTES[i] = [note]\n                break\n        if not found:\n            return 'Not a chord'\n    chord = tuple(sorted(chord))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for group in NOTES:\n            if note in group:\n                note_index = NOTES.index(group)\n                notes[notes.index(note)] = note_index\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    for i, note in enumerate(notes):\n        if note == chord_notes[0]:\n            root_idx = i\n            break\n        elif isinstance(note, list) and chord_notes[0] in note:\n            root_idx = i\n            chord_notes[0] = note[0]\n            break\n    for i, note in enumerate(notes):\n        if note == chord_notes[1]:\n            second_idx = i\n            break\n        elif isinstance(note, list) and chord_notes[1] in note:\n            second_idx = i\n            chord_notes[1] = note[0]\n            break\n    for i, note in enumerate(notes):\n        if note == chord_notes[2]:\n            third_idx = i\n            break\n        elif isinstance(note, list) and chord_notes[2] in note:\n            third_idx = i\n            chord_notes[2] = note[0]\n            break\n    interval_1 = (second_idx - root_idx) % 12\n    interval_2 = (third_idx - second_idx) % 12\n    if interval_1 == 3 and interval_2 == 4:\n        return 'Minor'\n    elif interval_1 == 4 and interval_2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    flat = False\n    sharp = False\n    for note in chord_notes:\n        if '#' in note:\n            sharp = True\n        elif 'b' in note:\n            flat = True\n    if sharp and flat:\n        return 'Not a chord'\n    else:\n        note_indices = []\n        for note in chord_notes:\n            for i, n in enumerate(notes):\n                if note in n:\n                    note_indices.append(i)\n                    break\n        intervals = [note_indices[1] - note_indices[0], note_indices[2] - note_indices[1]]\n        if intervals == [3, 4]:\n            return 'Minor'\n        elif intervals == [4, 3]:\n            return 'Major'\n        else:\n            return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES[i] = [note]\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES[i].index(note)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n        notes_index.append(NOTES_INDEX)\n    notes_index.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "1": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_normalized = [min((n for n in note for n in NOTES if n == note), key=lambda x: NOTES.index(x)) for note in notes]\n    notes_normalized.sort(key=lambda x: NOTES.index(x))\n    if tuple(notes_normalized) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes_normalized)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for lst in NOTES:\n            if note in lst:\n                NOTES.index(lst)\n                break\n    notes_indices = [NOTES.index([n for n in NOTES if n.count(note)][0]) for note in notes]\n    intervals = [notes_indices[i+1] - notes_indices[i] for i in range(2)]\n    if intervals == [4, 3]:\n        return 'Major'\n    elif intervals == [3, 4]:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if interval1 == 4 and interval2 == 3:\n        return 'Major'\n    elif interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes)-1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES_INDEX = i\n                break\n    first, second, third = NOTES_INDEX, NOTES_INDEX + 3, NOTES_INDEX + 7\n    interval1 = NOTES_INDEX - NOTES[first].index(notes[0])\n    interval2 = NOTES[second].index(notes[1]) - NOTES_INDEX\n    interval3 = NOTES[third].index(notes[2]) - NOTES[second]\n    if interval1 == 0 and interval2 == 4 and interval3 == 3:\n        return 'Major'\n    elif interval1 == 0 and interval2 == 3 and interval3 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_normalized = [min(note_set) for note_set in NOTES for note in note_set if note in notes]\n    notes_normalized.sort()\n    chord_normalized = tuple(notes_normalized)\n    if chord_normalized in DCT_CHORDS:\n        return DCT_CHORDS[chord_normalized]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if interval1 == 4 and interval2 == 3:\n        return 'Major'\n    elif interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES.index(note_group)\n                NOTES.index(note_group)\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes)-1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in DCT_CHORDS:\n        if set(chord_notes) == set(notes):\n            return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    interval1 = idx2 - idx1\n    interval2 = idx3 - idx2\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                notes[notes.index(note)] = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    notes = [''.join(n) for n in NOTES[:12]]\n    chord = tuple(sorted([notes.index(note) for note in notes if note in chord]))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES.index([note]) if NOTES.index(group) == i else NOTES.index(group) + 12\n                note_index = i\n                break\n    intervals = [(notes[i], notes[i+1]) for i in range(2)]\n    for interval in intervals:\n        first_note_index = NOTES.index([note for note in NOTES if interval[0] in note][0])\n        second_note_index = NOTES.index([note for note in NOTES if interval[1] in note][0])\n        intervals[intervals.index(interval)] = abs((second_note_index - first_note_index) % 12)\n    if intervals == [3, 4] or intervals == [4, 3]:\n        return 'Minor'\n    elif intervals == [4, 3] or intervals == [3, 4]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if len(notes) != 3:\n        return 'Not a chord'\n    chord_notes = tuple(sorted(set(note for note_list in NOTES for note in note_list if any(n in note_list for n in notes))))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES[i] = [note]\n                break\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES[i].index(note)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_indices = {}\n    for i, note_group in enumerate(notes):\n        for note in note_group if isinstance(note_group, list) else [note_group]:\n            note_indices[note] = i\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    intervals = [(note_indices[chord_notes[i+1]] - note_indices[chord_notes[i]]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group, i)\n                notes[notes.index(note)] = NOTES.index(note_group)\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\").split(', ')\n        else:\n            note = [note]\n        NOTES_ = [n for i in NOTES for n in i]\n        if note[0] not in NOTES_:\n            return 'Not a chord'\n    notes = [n[0] for n in sorted([[n, NOTES_.index(n)] for n in notes])]\n    notes_tuple = tuple(notes)\n    if notes_tuple in DCT_CHORDS:\n        return DCT_CHORDS[notes_tuple]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    for i, note in enumerate(chord_notes):\n        for j, n in enumerate(notes):\n            if note in n:\n                chord_notes[i] = j\n                break\n    if len(set(chord_notes)) != 3:\n        return 'Not a chord'\n    intervals = [chord_notes[i+1] - chord_notes[i] for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "2": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for l in NOTES if n in l][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in notes]\n    notes.sort()\n    notes = tuple([NOTES[i][0] for i in notes])\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, n in enumerate(NOTES):\n            if note in n:\n                notes[NOTES.index(n)] = i\n                break\n    notes.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    return chord_type if chord_type else 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in product(*[n for n in NOTES for note in chord_notes if note in n]):\n        chord_name = ' '.join(notes)\n        if chord_name in DCT_CHORDS:\n            return DCT_CHORDS[chord_name]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for note_set in NOTES if n in note_set][0]) for n in notes]))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    for note, mode in DCT_CHORDS.items():\n        if set(note) == set(notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    notes = [NOTES.index(note) for note in notes]\n    notes.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    return chord_type if chord_type else 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    chord_tup = tuple(sorted([notes[0], notes[1], notes[2]]))\n    if idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    elif idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif chord_tup in DCT_CHORDS:\n        return DCT_CHORDS[chord_tup]\n    else:\n        return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if (interval1 == 3 and interval2 == 4) or (interval1 == 4 and interval2 == 3):\n        return 'Minor' if interval1 == 3 else 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in product(*[n for n in NOTES for note in chord_notes if note in n]):\n        chord_name = ' '.join(notes)\n        if chord_name in DCT_CHORDS:\n            return DCT_CHORDS[chord_name]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    chord_tup = tuple(sorted([notes[0], notes[1], notes[2]]))\n    if idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    elif idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif chord_tup in DCT_CHORDS:\n        return DCT_CHORDS[chord_tup]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                notes[notes.index(note)] = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    notes = [''.join(n) for n in NOTES[:12]]\n    chord = tuple(sorted([notes.index(note) for note in notes if note in chord]))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if len(notes) != 3:\n        return 'Not a chord'\n    chord_notes = tuple(sorted(set(note for note_list in NOTES for note in note_list if any(n in note_list for n in notes))))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [x.strip() for x in chord.split()]\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note if note not in ['Db', 'D#', 'Eb', 'Fb', 'Gb', 'G#', 'Ab', 'A#', 'Bb', 'Cb'] else 'C#' if note == 'Db' else 'D#' if note == 'Eb' else 'E' if note == 'Fb' else 'F#' if note == 'Gb' else 'G#' if note == 'Ab' else 'A#' if note == 'Bb' else 'B' if note == 'Cb' else note for note in notes]\n    notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'].index(notes[0]), ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'].index(notes[1]), ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'].index(notes[2])\n    if (notes[1] - notes[0] == 4 and notes[2] - notes[1] == 3) or (notes[1] - notes[0] == 3 and notes[2] - notes[1] == 4):\n        return 'Major' if notes[1] - notes[0] == 4 else 'Minor'\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES[i].index(note)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord_type = DCT_CHORDS.get(tuple(sorted(notes)))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES.index(note_list)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split() if note]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n        notes_index.append(NOTES_INDEX)\n    notes_index.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].split(', ')\n            for n in note:\n                notes[notes.index(note)] = n\n    for key, value in DCT_CHORDS.items():\n        if tuple(notes) == key:\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note, mode in DCT_CHORDS.items():\n        if set(note) == set(notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ]
    }
}