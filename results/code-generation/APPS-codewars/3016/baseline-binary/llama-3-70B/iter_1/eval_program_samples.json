{
    "0": {
        "0": [
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    for mode, offset in config:\n        if notes[1] - notes[0] == offset and notes[2] - notes[1] == 7 - offset:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    for mode, offset in config:\n        if notes[1] - notes[0] == offset and notes[2] - notes[1] == (7 - offset):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    chord_notes.sort()\n    interval1 = (chord_notes[1] - chord_notes[0]) % 12\n    interval2 = (chord_notes[2] - chord_notes[1]) % 12\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                index = NOTES.index(note_list)\n                notes[notes.index(note)] = index\n                break\n    notes = sorted(notes)\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for group in NOTES if n in group][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [x for x in chord.split() if x]\n    notes_exists = all(any(note in notes_list for note in notes) for notes_list in NOTES)\n    if not notes_exists:\n        return 'Not a chord'\n    chord_name = ' '.join(sorted(notes))\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord_notes]\n    chord_notes.sort()\n    chord_notes = tuple([NOTES[n][0] for n in chord_notes])\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for n in notes:\n        if notes.count(n) > 1:\n            return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(key) == set(notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                index = NOTES.index(note_list)\n                notes[notes.index(note)] = index\n                break\n    notes = sorted(notes)\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [x for x in chord.split() if x]\n    notes_exists = all(any(note in notes_list for note in notes) for notes_list in NOTES)\n    if not notes_exists:\n        return 'Not a chord'\n    chord_name = ' '.join(sorted(notes))\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_normalized = [min(note_set) for note_set in NOTES for note in note_set if note in notes]\n    notes_normalized.sort()\n    chord_normalized = tuple(notes_normalized)\n    if chord_normalized in DCT_CHORDS:\n        return DCT_CHORDS[chord_normalized]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES.index([note])  # get index of note in NOTES\n                notes.remove(note)\n                notes.insert(0, i)\n                break\n    notes.sort()\n    chord_name = tuple(notes)\n    return DCT_CHORDS.get(chord_name, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if interval1 == 4 and interval2 == 3:\n        return 'Major'\n    elif interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes)-1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                NOTES.index([n for n in NOTES if note in n][0])\n                break\n    notes = [NOTES.index([n for n in NOTES if note in n][0]) % 12 for note in notes]\n    notes.sort()\n    interval1 = (notes[1] - notes[0]) % 12\n    interval2 = (notes[2] - notes[1]) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in DCT_CHORDS:\n        if set(chord_notes) == set(notes):\n            return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    interval12 = idx2 - idx1\n    interval23 = idx3 - idx2\n    if interval12 == 3 and interval23 == 4:\n        return 'Minor'\n    elif interval12 == 4 and interval23 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for group in NOTES:\n            if note in group:\n                note_index = NOTES.index(group)\n                notes[notes.index(note)] = note_index\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord_notes = chord.split()\n    flat = [note for note in notes for n in note if n in chord_notes]\n    sharp = [note for note in notes for n in note if n in chord_notes]\n    chord_notes = flat + [note for note in chord_notes if note not in flat]\n    notes_flat = [note[0] if isinstance(note, list) else note for note in notes]\n    notes_sharp = [note[1] if isinstance(note, list) else note for note in notes]\n    index_flat = [notes_flat.index(note) for note in chord_notes if note in notes_flat]\n    index_sharp = [notes_sharp.index(note) for note in chord_notes if note in notes_sharp]\n    intervals_flat = [(index_flat[i+1] - index_flat[i]) for i in range(len(index_flat) - 1)]\n    intervals_sharp = [(index_sharp[i+1] - index_sharp[i]) for i in range(len(index_sharp) - 1)]\n    if intervals_flat == [3, 4] or intervals_flat == [4, 3]:\n        return 'Minor'\n    elif intervals_sharp == [3, 4] or intervals_sharp == [4, 3]:\n        return 'Minor'\n    elif intervals_flat == [4, 3] or intervals_flat == [3, 4]:\n        return 'Major'\n    elif intervals_sharp == [4, 3] or intervals_sharp == [3, 4]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index(note_group, i)\n                notes[notes.index(note)] = i\n                break\n    chord_type = 'Not a chord'\n    for mode, offset in config:\n        if abs(notes[0] - notes[1]) == offset and abs(notes[1] - notes[2]) == 7 - offset:\n            chord_type = mode\n            break\n    return chord_type",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flatten = [note if isinstance(note, str) else note[0] for note in notes]\n    notes_dict = {note: i for i, note in enumerate(notes_flatten)}\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    notes_indices = [notes_dict[note] for note in chord_notes]\n    notes_intervals = [notes_indices[1] - notes_indices[0], notes_indices[2] - notes_indices[1]]\n    if notes_intervals == [3, 4]:\n        return 'Minor'\n    elif notes_intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_dict = {note[0] if isinstance(note, list) else note: i for i, note in enumerate(notes)}\n    chord_notes = chord.split()\n    chord_notes.sort(key=lambda note: note_dict[next(note for note in notes if note == note or note in note)])\n    chord_intervals = [(note_dict[chord_notes[i+1][0] if isinstance(chord_notes[i+1], list) else chord_notes[i+1]] - \n                        note_dict[chord_notes[i][0] if isinstance(chord_notes[i], list) else chord_notes[i]]) % 12 for i in range(2)]\n    if chord_intervals == [3, 4]:\n        return 'Minor'\n    elif chord_intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    chord = chord.split()\n    for i in range(len(notes)):\n        if chord[0] in notes[i]:\n            first_idx = i\n            break\n    for i in range(len(notes)):\n        if chord[1] in notes[i]:\n            second_idx = i\n            break\n    for i in range(len(notes)):\n        if chord[2] in notes[i]:\n            third_idx = i\n            break\n    interval1 = (second_idx - first_idx) % 12\n    interval2 = (third_idx - second_idx) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [n for sublist in NOTES for n in sublist if n in notes][0:3]\n    notes.sort(key=lambda x: NOTES.index([n for n in NOTES if x in n][0]))\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord').capitalize()",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    chord_type = None\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            chord_type = v\n            break\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_values = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for n in note:\n                note_values[n] = i\n        else:\n            note_values[note] = i\n    chord_notes = chord.split()\n    intervals = [(note_values[chord_notes[i + 1]] - note_values[chord_notes[i]]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes *= 2\n    note_indices = {note: index for index, note_list in enumerate(notes) for note in note_list}\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    intervals = [(note_indices[chord_notes[i]], note_indices[chord_notes[i+1]]) for i in range(2)]\n    if (intervals[0][1] - intervals[0][0] == 3 and intervals[1][1] - intervals[1][0] == 4) or (intervals[0][1] - intervals[0][0] == 4 and intervals[1][1] - intervals[1][0] == 3):\n        if intervals[0][1] - intervals[0][0] == 3:\n            return 'Minor'\n        else:\n            return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES_INDEX = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flats = {'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'}\n    sharps = {'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#'}\n\n    chord_notes = chord.split()\n    for i in range(len(chord_notes)):\n        if chord_notes[i] in flats:\n            chord_notes[i] = flats[chord_notes[i]]\n        elif chord_notes[i] in sharps:\n            chord_notes[i] = sharps[chord_notes[i]]\n\n    note_positions = []\n    for note in chord_notes:\n        for i in range(len(notes)):\n            if note in notes[i]:\n                note_positions.append(i)\n                break\n\n    intervals = [(note_positions[1] - note_positions[0]) % 12, (note_positions[2] - note_positions[1]) % 12]\n\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(chord.split())\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    if tuple(chord) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "1": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    chord_config = tuple(chord_notes[1] - chord_notes[0], chord_notes[2] - chord_notes[1])\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for n in notes:\n        if notes.count(n) > 1:\n            return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(key) == set(notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    for note in notes:\n        if note not in [n for note_group in NOTES for n in note_group]:\n            return 'Not a chord'\n    chord_name = tuple(sorted([NOTES.index([n for note_group in NOTES if n in note_group][0]) for n in notes]))\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_normalized = [min(note_set) for note_set in NOTES for note in notes if note in note_set]\n    notes_normalized.sort()\n    chord_normalized = tuple(notes_normalized)\n    if chord_normalized in DCT_CHORDS:\n        return DCT_CHORDS[chord_normalized]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = notes_index[1] - notes_index[0]\n    interval2 = notes_index[2] - notes_index[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes)-1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES_INDEX = i\n                break\n    first, second, third = NOTES_INDEX, NOTES_INDEX, NOTES_INDEX\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                if first == NOTES_INDEX:\n                    first = i\n                elif second == NOTES_INDEX:\n                    second = i\n                else:\n                    third = i\n    interval1 = (second - first) % 12\n    interval2 = (third - second) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    chord_tup = tuple(sorted([notes[0], notes[1], notes[2]]))\n    if idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    elif idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif chord_tup in DCT_CHORDS:\n        return DCT_CHORDS[chord_tup]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    chord_tuple = tuple(min(NOTES[i] + NOTES[i + 12], key=lambda x: abs(ord(x[0]) - ord(c[0]))) for i, c in enumerate(chord))\n    return DCT_CHORDS.get(chord_tuple, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                notes[notes.index(note)] = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    notes = [''.join(n) for n in NOTES[:len(notes)]]\n    chord = ' '.join(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if len(notes) != 3:\n        return 'Not a chord'\n    chord_notes = tuple(sorted(set(note for note_list in NOTES for note in note_list if any(n in note_list for n in notes))))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    note_values = {}\n    for i, note in enumerate(notes):\n        if isinstance(note, list):\n            for n in note:\n                note_values[n] = i\n        else:\n            note_values[note] = i\n    chord_notes = chord.split()\n    chord_notes_values = [note_values[note] for note in chord_notes]\n    chord_notes_values.sort()\n    if chord_notes_values[1] - chord_notes_values[0] == 3 and chord_notes_values[2] - chord_notes_values[1] == 4:\n        return 'Minor'\n    elif chord_notes_values[1] - chord_notes_values[0] == 4 and chord_notes_values[2] - chord_notes_values[1] == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flatten = [note if isinstance(note, str) else note[0] for note in notes]\n    notes_dict = {note: i for i, note in enumerate(notes_flatten)}\n    chord_notes = chord.split()\n    chord_notes_int = [notes_dict[note] for note in chord_notes]\n    chord_notes_int.sort()\n    intervals = [chord_notes_int[i + 1] - chord_notes_int[i] for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES.index(note_list)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (4, 3):\n        return 'Major'\n    elif (interval1, interval2) == (3, 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    chord_type = None\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            chord_type = v\n            break\n    if chord_type:\n        return chord_type\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    notes = [next(group for group in NOTES for n in group if n == note) for note in notes]\n    notes = [NOTES.index(note) % 12 for note in notes]\n    notes.sort()\n    interval1 = (notes[1] - notes[0]) % 12\n    interval2 = (notes[2] - notes[1]) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes *= 2\n    note_indices = {note: i for i, note_list in enumerate(notes) for note in note_list}\n    chord_notes = chord.split()\n    if len(chord_notes) != 3:\n        return 'Not a chord'\n    indices = [note_indices[note] for note in chord_notes]\n    intervals = [(indices[i + 1] - indices[i]) % 12 for i in range(2)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return 'Major' if DCT_CHORDS[(note1, note2, note3)] == 'Major' else 'Minor'\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flats = {'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'}\n    sharps = {'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#'}\n\n    chord_notes = chord.split()\n    for i in range(len(chord_notes)):\n        if chord_notes[i] in flats:\n            chord_notes[i] = flats[chord_notes[i]]\n        elif chord_notes[i] in sharps:\n            chord_notes[i] = sharps[chord_notes[i]]\n\n    note_positions = []\n    for note in chord_notes:\n        for i in range(len(notes)):\n            if note in notes[i]:\n                note_positions.append(i)\n                break\n\n    intervals = [(note_positions[1] - note_positions[0]) % 12, (note_positions[2] - note_positions[1]) % 12]\n\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key, value in DCT_CHORDS.items():\n        if set(notes) == set(key):\n            return value\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(chord.split())\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    if tuple(chord) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "2": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in DCT_CHORDS:\n        if set(chord_notes) == set(notes):\n            return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for l in NOTES if n in l][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    if idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for note_set in NOTES if n in note_set][0]) for n in notes]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, n in enumerate(NOTES):\n            if note in n:\n                notes[NOTES.index(n)] = i\n                break\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(v) == tuple(notes)]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    for note, mode in DCT_CHORDS.items():\n        if set(note) == set(notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    notes = [NOTES.index(note) for note in notes]\n    notes.sort()\n    chord_type = 'Not a chord'\n    for key, value in DCT_CHORDS.items():\n        if tuple(notes) == key:\n            chord_type = value\n    return chord_type"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in DCT_CHORDS:\n        if set(chord_notes) == set(notes):\n            return DCT_CHORDS[notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    interval1 = idx2 - idx1\n    interval2 = idx3 - idx2\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        found = False\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                notes[notes.index(note)] = i\n                found = True\n                break\n        if not found:\n            return 'Not a chord'\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    notes = [''.join(n) for n in NOTES[:12]]\n    chord = tuple(sorted([notes.index(note) for note in notes if note in chord]))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if len(notes) != 3:\n        return 'Not a chord'\n    chord_notes = tuple(sorted(set(note for note_list in NOTES for note in note_list if any(n in note_list for n in notes))))\n    if chord_notes in DCT_CHORDS:\n        return DCT_CHORDS[chord_notes]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                notes[notes.index(note)] = NOTES.index(note_list)\n                break\n    notes = tuple(sorted(notes))\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i] = [note]\n                break\n    chord = tuple(sorted(notes))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [x.strip() for x in chord.split()]\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return \"Not a chord\"\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note if note not in ['Db', 'D#', 'Eb', 'Fb', 'Gb', 'G#', 'Ab', 'A#', 'Bb', 'Cb'] else 'C#' if note == 'Db' else 'D#' if note == 'Eb' else 'E' if note == 'Fb' else 'F#' if note == 'Gb' else 'G#' if note == 'Ab' else 'A#' if note == 'Bb' else 'B' if note == 'Cb' else note for note in notes]\n    chord_notes = [NOTES.index([note]) for note in notes]\n    chord_notes.sort()\n    intervals = [chord_notes[i] - chord_notes[i - 1] for i in range(1, len(chord_notes))]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    notes = [next(group for group in NOTES for n in group if note in group) for note in notes]\n    notes = [(NOTES.index(note), min(note)) for note in notes]\n    notes.sort(key=lambda x: x[0])\n    intervals = [(notes[i+1][0] - notes[i][0]) % 12 for i in range(2)]\n    for mode, offset in config:\n        if tuple(sorted(intervals)) == (offset, 7 - offset):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes *= 2\n    notes = [note[0] if isinstance(note, list) else note for note in notes]\n    chord_notes = chord.split()\n    chord_notes = [note if note not in ['C#', 'Db', 'D#', 'Eb', 'F#', 'Gb', 'G#', 'Ab', 'A#', 'Bb'] else ['C#', 'Db'][notes.index(note) - notes.index('C')] if note in ['C#', 'Db'] else ['D#', 'Eb'][notes.index(note) - notes.index('D')] if note in ['D#', 'Eb'] else ['F#', 'Gb'][notes.index(note) - notes.index('F')] if note in ['F#', 'Gb'] else ['G#', 'Ab'][notes.index(note) - notes.index('G')] if note in ['G#', 'Ab'] else ['A#', 'Bb'][notes.index(note) - notes.index('A')] if note in ['A#', 'Bb'] else 'B' for note in chord_notes]\n    intervals = [(notes.index(chord_notes[i + 1]) - notes.index(chord_notes[i])) % 12 for i in range(len(chord_notes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flatten = [note if isinstance(note, str) else note[0] for note in notes]\n    notes_flatten = notes_flatten * 2\n    \n    chord_notes = chord.split()\n    chord_notes_min = [notes_flatten.index(note) for note in chord_notes]\n    chord_notes_min.sort()\n    \n    intervals = [chord_notes_min[i+1] - chord_notes_min[i] for i in range(2)]\n    \n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_list in enumerate(NOTES):\n            if note in note_list:\n                NOTES.index(note_list)\n                notes[notes.index(note)] = i\n                break\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [item for sublist in NOTES for item in sublist]:\n            return 'Not a chord'\n    note1, note2, note3 = notes\n    index1 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note1][0]\n    index2 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note2][0]\n    index3 = [i for i, sublist in enumerate(NOTES) for item in sublist if item == note3][0]\n    interval1 = (index2 - index1) % 12\n    interval2 = (index3 - index2) % 12\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[i] for i in range(len(NOTES)) if any(note in NOTES[i] for note in notes)]\n    for i in range(len(notes_possibilities) - 2):\n        for j in range(i + 1, len(notes_possibilities) - 1):\n            for k in range(j + 1, len(notes_possibilities)):\n                if (notes_possibilities[i][0], notes_possibilities[j][0], notes_possibilities[k][0]) in DCT_CHORDS:\n                    return DCT_CHORDS[(notes_possibilities[i][0], notes_possibilities[j][0], notes_possibilities[k][0])]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set((note1, note2, note3)):\n            return 'Major' if DCT_CHORDS[(note1, note2, note3)] == 'Major' else 'Minor'\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    flats = {'C#': 'Db', 'D#': 'Eb', 'F#': 'Gb', 'G#': 'Ab', 'A#': 'Bb'}\n    sharps = {'Db': 'C#', 'Eb': 'D#', 'Gb': 'F#', 'Ab': 'G#', 'Bb': 'A#'}\n\n    chord_notes = chord.split()\n    for i in range(len(chord_notes)):\n        if chord_notes[i] in flats:\n            chord_notes[i] = flats[chord_notes[i]]\n        elif chord_notes[i] in sharps:\n            chord_notes[i] = sharps[chord_notes[i]]\n\n    note_positions = []\n    for note in chord_notes:\n        for i in range(len(notes)):\n            if note in notes[i]:\n                note_positions.append(i)\n                break\n\n    intervals = [(note_positions[1] - note_positions[0]) % 12, (note_positions[2] - note_positions[1]) % 12]\n\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                note_index = NOTES.index(note_list)\n                break\n    notes = [NOTES.index([n for n in NOTES if note in n][0]) for note in notes]\n    notes.sort()\n    for mode, offset in config:\n        if (notes[1] - notes[0], notes[2] - notes[1]) == (offset, 7 - offset):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(chord.split())\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    if tuple(chord) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            notes[notes.index(note)] = note[1:-1]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str, chord.split()))\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(lambda x: [note for note_list in NOTES for note in note_list if x in note_list][0][0], chord.split()))\n    note_values = {'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3, 'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8, 'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11}\n    intervals = [(note_values[notes[1]]) - (note_values[notes[0]]), (note_values[notes[2]]) - (note_values[notes[1]])]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'"
        ]
    }
}