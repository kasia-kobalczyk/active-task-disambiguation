{
    "0": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if interval1 == 3 and interval2 == 4:\n        return 'Minor'\n    elif interval1 == 4 and interval2 == 3:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n    notes = sorted(notes)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if all(note in notes_config for note in notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    chord_name = tuple(notes[0], notes[1], notes[2])\n    if chord_name in DCT_CHORDS:\n        return DCT_CHORDS[chord_name]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for note_list in NOTES:\n            if note in note_list:\n                index = NOTES.index(note_list)\n                notes[notes.index(note)] = index\n                break\n    notes = sorted(notes)\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for group in NOTES for n in group]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for group in NOTES if n in group][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, options in enumerate(NOTES):\n            if note in options:\n                NOTES[i] = [note]\n                break\n    NOTES = NOTES[:12]\n    NOTES.extend(NOTES)\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [x for x in NOTES for y in x]\n    notes_dict = {notes[i]: i for i in range(len(notes))}\n    notes_in_chord = chord.split()\n    notes_in_chord_values = [notes_dict[note] for note in notes_in_chord]\n    notes_in_chord_values.sort()\n    intervals = [notes_in_chord_values[1] - notes_in_chord_values[0], notes_in_chord_values[2] - notes_in_chord_values[1]]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_normalized = [min(note_set) for note_set in NOTES for note in notes if note in note_set]\n    notes_normalized.sort()\n    chord_normalized = tuple(notes_normalized)\n    if chord_normalized in DCT_CHORDS:\n        return DCT_CHORDS[chord_normalized]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    for mode, _ in config:\n        if tuple(notes) in DCT_CHORDS:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flatten = [note if isinstance(note, str) else note[0] for note in notes] * 2\n\n    chord_notes = chord.split()\n    chord_notes_flatten = [note if note not in ['C#', 'Db', 'D#', 'Eb', 'F#', 'Gb', 'G#', 'Ab', 'A#', 'Bb'] else {'C#': 'Db', 'Db': 'C#', 'D#': 'Eb', 'Eb': 'D#', 'F#': 'Gb', 'Gb': 'F#', 'G#': 'Ab', 'Ab': 'G#', 'A#': 'Bb', 'Bb': 'A#'}[note] for note in chord_notes]\n\n    chord_notes_indices = [notes_flatten.index(note) for note in chord_notes_flatten]\n\n    intervals = [(chord_notes_indices[i + 1] - chord_notes_indices[i]) % 12 for i in range(len(chord_notes_indices) - 1)]\n\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    note_indices = [NOTES.index([n] if n in ['C', 'D', 'E', 'F', 'G', 'A', 'B'] else [n for n in NOTES if n in [n]]) for n in notes]\n    note_intervals = [(note_indices[1] - note_indices[0]) % 12, (note_indices[2] - note_indices[1]) % 12]\n    for k, v in DCT_CHORDS.items():\n        if list(k) == notes:\n            return v\n    return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if all(note in key for note in notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for n in notes:\n        if notes.count(n) > 1:\n            return \"Not a chord\"\n    for key in DCT_CHORDS:\n        if set(key) == set(notes):\n            return DCT_CHORDS[key]\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[1:-1].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES[i] = note\n                break\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if all(note in key for note in notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = [note.strip() for note in chord.split()]\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return \"Not a chord\"\n    for c, mode in DCT_CHORDS.items():\n        if set(c) == set(notes):\n            return mode\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    },
    "1": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    if tuple(sorted(notes)) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(sorted(notes))]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for note in chord_notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in chord_notes]\n    chord_notes.sort()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                index = i\n                break\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    interval1 = notes[1] - notes[0]\n    interval2 = notes[2] - notes[1]\n    if (interval1, interval2) == (3, 4):\n        return 'Minor'\n    elif (interval1, interval2) == (4, 3):\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = list(map(str.strip, chord.split()))\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if len([i for i in NOTES if note in i]) != 1:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) % 12 for note in notes]\n    notes.sort()\n    chord_type = [k for k, v in DCT_CHORDS.items() if tuple(n % 12 for n in notes) == v]\n    if chord_type:\n        return chord_type[0]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes = [note for note in notes for alt in NOTES if note in alt]\n    notes = [NOTES.index([note]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = [note for note in chord.split()]\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES.index(group)\n                notes[notes.index(note)] = i + 1\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    for mode, _ in config:\n        if tuple(notes) in DCT_CHORDS:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [note for sublist in NOTES for note in sublist]:\n            return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    intervals = [(NOTES_INDEX, NOTES_INDEX + 4), (NOTES_INDEX + 4, NOTES_INDEX + 7)]\n    for interval in intervals:\n        first_note = NOTES[interval[0]][0]\n        second_note = NOTES[interval[1]][0]\n        if (first_note, second_note, NOTES[NOTES_INDEX + 7][0]) in DCT_CHORDS:\n            return DCT_CHORDS[(first_note, second_note, NOTES[NOTES_INDEX + 7][0])]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if all(note in key for note in notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for n in notes:\n        if notes.count(n) > 1:\n            return \"Not a chord\"\n    for key in DCT_CHORDS:\n        if set(key) == set(notes):\n            return DCT_CHORDS[key]\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[1:-1].split(', ')\n            for n in note:\n                notes[notes.index(note)] = n\n    for k, v in DCT_CHORDS.items():\n        if set(k) == set(notes):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[1:-1].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES[i] = note\n                break\n    chord = tuple(notes)\n    return DCT_CHORDS.get(chord, 'Not a chord')"
        ],
        "3": [
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if all(note in key for note in notes):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    if tuple(chord_notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(chord_notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return \"Not a chord\"\n    for c, mode in DCT_CHORDS.items():\n        if set(c) == set(notes):\n            return mode\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    for k, v in DCT_CHORDS.items():\n        if set(k) == set(notes):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'"
        ]
    },
    "2": {
        "0": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for mode, notes_config in DCT_CHORDS.items():\n        if set(notes) in [set(c) for c in notes_config]:\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord_config = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord_config in DCT_CHORDS:\n        return DCT_CHORDS[chord_config]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_index = [NOTES_INDEX]\n    for note in notes[1:]:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                notes_index.append(i)\n                break\n    interval1 = (notes_index[1] - notes_index[0]) % 12\n    interval2 = (notes_index[2] - notes_index[1]) % 12\n    if (interval1 == 4 and interval2 == 3):\n        return 'Major'\n    elif (interval1 == 3 and interval2 == 4):\n        return 'Minor'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, lst in enumerate(NOTES):\n            if note in lst:\n                NOTES[i] = [note]\n                break\n    chord-notes = tuple(sorted([NOTES.index(i) for i in NOTES if len(i) == 1]))\n    return DCT_CHORDS.get(chord_notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i in range(len(NOTES)):\n            if note in NOTES[i]:\n                NOTES[i].remove(note)\n    notes = [NOTES.index([n]) for n in notes]\n    notes.sort()\n    notes = tuple(n % 12 for n in notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, group in enumerate(NOTES):\n            if note in group:\n                NOTES_INDEX = i\n                break\n    notes_indexes = [NOTES_INDEX] + [NOTES.index([n for n in NOTES if note in n][0]) for note in notes[1:]]\n    intervals = [(notes_indexes[i+1] - notes_indexes[i]) % 12 for i in range(len(notes_indexes) - 1)]\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    notes_possibilities = [NOTES[(NOTES.index([n]) + NOTES.index([note])) % 12] for n, note in product(notes, NOTES[0])]\n    for possibility in notes_possibilities:\n        if tuple(possibility) in DCT_CHORDS:\n            return DCT_CHORDS[tuple(possibility)]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for sublist in NOTES for n in sublist if note in sublist][0]) for note in notes]\n    notes.sort()\n    notes = tuple(notes)\n    if notes in DCT_CHORDS:\n        return DCT_CHORDS[notes]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    chord = chord.split()\n    for note in chord:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for sublist in NOTES if n in sublist][0]) for n in chord]))\n    if chord in DCT_CHORDS:\n        return DCT_CHORDS[chord]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for l in NOTES for n in l]:\n            return 'Not a chord'\n    notes = [NOTES.index([n for l in NOTES if n in l][0]) for n in notes]\n    notes.sort()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                notes[notes.index(note)] = i\n                break\n    notes.sort()\n    notes = tuple(notes)\n    return DCT_CHORDS.get(notes, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, n in enumerate(NOTES):\n            if note in n:\n                notes[NOTES.index(n)] = i\n                break\n    notes.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    return chord_type if chord_type else 'Not a chord'",
            "def minor_or_major(chord):\n    chord_notes = chord.split()\n    for notes in product(*[n for n in NOTES for note in chord_notes if note in n]):\n        chord_name = ' '.join(notes)\n        if chord_name in DCT_CHORDS:\n            return DCT_CHORDS[chord_name]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for note_set in NOTES for n in note_set]:\n            return 'Not a chord'\n    chord = tuple(sorted([NOTES.index([n for note_set in NOTES if n in note_set][0]) for n in notes]))\n    return DCT_CHORDS.get(chord, 'Not a chord')",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    for note, mode in DCT_CHORDS.items():\n        if set(note) == set(notes):\n            return mode\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        for i, note_group in enumerate(NOTES):\n            if note in note_group:\n                NOTES.index = i\n                break\n    notes = [NOTES.index(note) for note in notes]\n    notes.sort()\n    chord_type = DCT_CHORDS.get(tuple(notes))\n    return chord_type if chord_type else 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1 in NOTES:\n        if notes[0] in note1:\n            idx1 = NOTES.index(note1)\n            break\n    for note2 in NOTES:\n        if notes[1] in note2:\n            idx2 = NOTES.index(note2)\n            break\n    for note3 in NOTES:\n        if notes[2] in note3:\n            idx3 = NOTES.index(note3)\n            break\n    chord_tup = tuple(sorted([notes[0], notes[1], notes[2]]))\n    if idx2 - idx1 == 3 and idx3 - idx2 == 4:\n        return 'Minor'\n    elif idx2 - idx1 == 4 and idx3 - idx2 == 3:\n        return 'Major'\n    elif chord_tup in DCT_CHORDS:\n        return DCT_CHORDS[chord_tup]\n    else:\n        return 'Not a chord'"
        ],
        "1": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = ['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n    notes_flatten = [note if isinstance(note, str) else note[0] for note in notes] * 2\n\n    chord_notes = chord.split()\n    chord_notes_flatten = [note if note not in ['C#', 'Db', 'D#', 'Eb', 'F#', 'Gb', 'G#', 'Ab', 'A#', 'Bb'] else {'C#': 'Db', 'Db': 'C#', 'D#': 'Eb', 'Eb': 'D#', 'F#': 'Gb', 'Gb': 'F#', 'G#': 'Ab', 'Ab': 'G#', 'A#': 'Bb', 'Bb': 'A#'}[note] for note in chord_notes]\n\n    chord_notes_indices = [notes_flatten.index(note) for note in chord_notes_flatten]\n\n    intervals = [(chord_notes_indices[i + 1] - chord_notes_indices[i]) % 12 for i in range(len(chord_notes_indices) - 1)]\n\n    if intervals == [3, 4]:\n        return 'Minor'\n    elif intervals == [4, 3]:\n        return 'Major'\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note1, note2, note3 in DCT_CHORDS:\n        if set(notes) == set([note1, note2, note3]):\n            return DCT_CHORDS[(note1, note2, note3)]\n    return 'Not a chord'"
        ],
        "2": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[1:-1].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "3": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if '[' in note:\n            note = note[2:-2].replace(\"'\", \"\")\n            notes[notes.index(note)] = note\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ],
        "4": [
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for k, v in DCT_CHORDS.items():\n        if set(notes) == set(k):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return \"Not a chord\"\n    for c, mode in DCT_CHORDS.items():\n        if set(c) == set(notes):\n            return mode\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if len(notes) != 3:\n        return 'Not a chord'\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return 'Not a chord'\n    for k, v in DCT_CHORDS.items():\n        if set(k) == set(notes):\n            return v\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    for note in notes:\n        if note not in [n for sublist in NOTES for n in sublist]:\n            return \"Not a chord\"\n    for key in DCT_CHORDS:\n        if set(notes) == set(key):\n            return DCT_CHORDS[key]\n    return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return \"Not a chord\"",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'",
            "def minor_or_major(chord):\n    notes = chord.split()\n    if tuple(notes) in DCT_CHORDS:\n        return DCT_CHORDS[tuple(notes)]\n    else:\n        return 'Not a chord'"
        ]
    }
}