{"task_id":1614,"prompt":"\"\"\"\n=====Problem statement====\n\n# Connect Four\n\nTake a look at wiki description of Connect Four game:\n\n[Wiki Connect Four](https:\/\/en.wikipedia.org\/wiki\/Connect_Four)\n\nThe grid is 6 row by 7 columns, those being named from A to G.\n\nYou will receive a list of strings showing the order of the pieces which dropped in columns:\n\n```python\n  pieces_position_list = [\"A_Red\",\n                          \"B_Yellow\",\n                          \"A_Red\",\n                          \"B_Yellow\",\n                          \"A_Red\",\n                          \"B_Yellow\",\n                          \"G_Red\",\n                          \"B_Yellow\"]\n```\n\nThe list may contain up to 42 moves and shows the order the players are playing.\n\nThe first player who connects four items of the same color is the winner.\n\nYou should return \"Yellow\", \"Red\" or \"Draw\" accordingly.\n\"\"\"\n\n# ====== Solution ======\n\nCOLUMNS, ROWS = 'ABCDEFG', range(6)\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n","entry_point":"who_is_winner","test":"def check(candidate):\n    assert candidate(['C_Yellow', 'E_Red', 'G_Yellow', 'B_Red', 'D_Yellow', 'B_Red', 'B_Yellow', 'G_Red', 'C_Yellow', 'C_Red', 'D_Yellow', 'F_Red', 'E_Yellow', 'A_Red', 'A_Yellow', 'G_Red', 'A_Yellow', 'F_Red', 'F_Yellow', 'D_Red', 'B_Yellow', 'E_Red', 'D_Yellow', 'A_Red', 'G_Yellow', 'D_Red', 'D_Yellow', 'C_Red']) == 'Yellow'\n    assert candidate(['C_Yellow', 'B_Red', 'B_Yellow', 'E_Red', 'D_Yellow', 'G_Red', 'B_Yellow', 'G_Red', 'E_Yellow', 'A_Red', 'G_Yellow', 'C_Red', 'A_Yellow', 'A_Red', 'D_Yellow', 'B_Red', 'G_Yellow', 'A_Red', 'F_Yellow', 'B_Red', 'D_Yellow', 'A_Red', 'F_Yellow', 'F_Red', 'B_Yellow', 'F_Red', 'F_Yellow', 'G_Red', 'A_Yellow', 'F_Red', 'C_Yellow', 'C_Red', 'G_Yellow', 'C_Red', 'D_Yellow', 'D_Red', 'E_Yellow', 'D_Red', 'E_Yellow', 'C_Red', 'E_Yellow', 'E_Red']) == 'Yellow'\n    assert candidate(['F_Yellow', 'G_Red', 'D_Yellow', 'C_Red', 'A_Yellow', 'A_Red', 'E_Yellow', 'D_Red', 'D_Yellow', 'F_Red', 'B_Yellow', 'E_Red', 'C_Yellow', 'D_Red', 'F_Yellow', 'D_Red', 'D_Yellow', 'F_Red', 'G_Yellow', 'C_Red', 'F_Yellow', 'E_Red', 'A_Yellow', 'A_Red', 'C_Yellow', 'B_Red', 'E_Yellow', 'C_Red', 'E_Yellow', 'G_Red', 'A_Yellow', 'A_Red', 'G_Yellow', 'C_Red', 'B_Yellow', 'E_Red', 'F_Yellow', 'G_Red', 'G_Yellow', 'B_Red', 'B_Yellow', 'B_Red']) == 'Red'\n    assert candidate(['A_Yellow', 'B_Red', 'B_Yellow', 'C_Red', 'G_Yellow', 'C_Red', 'C_Yellow', 'D_Red', 'G_Yellow', 'D_Red', 'G_Yellow', 'D_Red', 'F_Yellow', 'E_Red', 'D_Yellow']) == 'Red'\n    assert candidate(['A_Red', 'B_Yellow', 'A_Red', 'B_Yellow', 'A_Red', 'B_Yellow', 'G_Red', 'B_Yellow']) == 'Yellow'\n\n","canonical_solution":"COLUMNS, ROWS = 'ABCDEFG', range(6)\nLINES = [{(COLUMNS[i+k], ROWS[j]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS))] \\\n        + [{(COLUMNS[i], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS)) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j+k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(len(ROWS) - 3)] \\\n        + [{(COLUMNS[i+k], ROWS[j-k]) for k in range(4)}\n           for i in range(len(COLUMNS) - 3) for j in range(3, len(ROWS))]\n\ndef who_is_winner(pieces_positions):\n    players = {}\n    board = dict.fromkeys(COLUMNS, 0)\n    for position in pieces_positions:\n        column, player = position.split('_')\n        pos = (column, board[column])\n        board[column] += 1\n        players.setdefault(player, set()).add(pos)\n        if any(line <= players[player] for line in LINES):\n            return player\n    return \"Draw\""}
{"task_id":1617,"prompt":"\"\"\"\n=====Problem statement====\n\nI started this as a joke among friends, telling that converting numbers to other integer bases is for n00bs, while an actual coder at least converts numbers to more complex bases like [pi (or \u03c0 or however you wish to spell it in your language)](http:\/\/en.wikipedia.org\/wiki\/Pi), so they dared me proving I was better.\n\nAnd I did it in few hours, discovering that what I started as a joke actually has [some math ground and application (particularly the conversion to base pi, it seems)](http:\/\/en.wikipedia.org\/wiki\/Non-integer_representation).\n\nThat said, now I am daring you to do the same, that is to build a function so that it takes a **number** (any number, you are warned!) and optionally the **number of decimals** (default: 0) and a **base** (default: pi), returning the proper conversion **as a string**:\n\n#Note\nIn Java there is no easy way with optional parameters so all three parameters will be given; the same in C# because, as of now, the used version is not known. \n\n```python\nconverter(13) #returns '103'\nconverter(13,3) #returns '103.010'\nconverter(-13,0,2) #returns '-1101'\n```\n\nI know most of the world uses a comma as a [decimal mark](http:\/\/en.wikipedia.org\/wiki\/Decimal_mark), but as English language and culture are *de facto* the Esperanto of us coders, we will stick to our common glorious traditions and uses, adopting the trivial dot (\".\") as decimal separator; if the absolute value of the result is <1, you have of course to put one (and only one) leading 0 before the decimal separator.\n\nFinally, you may assume that decimals if provided will always be >= 0 and that no test base will be smaller than 2 (because, you know, converting to base 1 is pretty lame) or greater than 36; as usual, for digits greater than 9 you can use uppercase alphabet letter, so your base of numeration is going to be: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'.\n\nThat is my first 3-languages-kata, so I count on you all to give me extensive feedback, no matter how harsh it may sound, so to improve myself even further :)\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import *\n\nDIGS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n","entry_point":"converter","test":"def check(candidate):\n    assert candidate(13) == '103'\n    assert candidate(10) == '100'\n    assert candidate(13,3) == '103.010'\n    assert candidate(13,0,8) == '15'\n    assert candidate(10,0,16) == 'A'\n    assert candidate(10000,4,13) == '4723.0000'\n    assert candidate(7,0,19) == '7'\n    assert candidate(13.5,4,16) == 'D.8000'\n    assert candidate(10.81,0,16) == 'A'\n    assert candidate(1,2,2) == '1.00'\n    assert candidate(-10,0,23) == '-A'\n    assert candidate(0,4,26) == '0.0000'\n    assert candidate(-15.5,2,23) == '-F.BB'\n    assert candidate(13,0,10) == '13'\n    assert candidate(5.5,1,10) == '5.5'\n\n","canonical_solution":"from math import *\n\nDIGS = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n\ndef converter(n, decimals=0, base=pi):\n    lst,n = ['-'*(n<0)], abs(n)\n    pMax  = max(0, n and int(log(n,base)))\n    \n    for p in reversed(range(-decimals,pMax+1)):\n        if p==-1: lst.append('.')\n        p   = base**p\n        d,n = n\/p, n%p\n        lst.append(DIGS[int(d)])\n        \n    return ''.join(lst)"}
{"task_id":1631,"prompt":"\"\"\"\n=====Problem statement====\n\n## Snail Sort\n\nGiven an `n x n` array, return the array elements arranged from outermost elements to the middle element, traveling clockwise.\n\n```\narray = [[1,2,3],\n         [4,5,6],\n         [7,8,9]]\nsnail(array) #=> [1,2,3,6,9,8,7,4,5]\n```\n\nFor better understanding, please follow the numbers of the next array consecutively:\n\n```\narray = [[1,2,3],\n         [8,9,4],\n         [7,6,5]]\nsnail(array) #=> [1,2,3,4,5,6,7,8,9]\n```\n\nThis image will illustrate things more clearly:\n\n\n\nNOTE: The idea is not sort the elements from the lowest value to the highest; the idea is to traverse the 2-d array in a clockwise snailshell pattern.\n\nNOTE 2: The 0x0 (empty matrix) is represented as en empty array inside an array `[[]]`.\n\"\"\"\n\n# ====== Solution ======\n\ndef snail(array):\n","entry_point":"snail","test":"def check(candidate):\n    assert candidate([[]]) == []\n    assert candidate([[1]]) == [1]\n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [1, 2, 3, 6, 9, 8, 7, 4, 5]\n    assert candidate([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25]]) == [1, 2, 3, 4, 5, 10, 15, 20, 25, 24, 23, 22, 21, 16, 11, 6, 7, 8, 9, 14, 19, 18, 17, 12, 13]\n    assert candidate([[1, 2, 3, 4, 5, 6], [20, 21, 22, 23, 24, 7], [19, 32, 33, 34, 25, 8], [18, 31, 36, 35, 26, 9], [17, 30, 29, 28, 27, 10], [16, 15, 14, 13, 12, 11]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]\n\n","canonical_solution":"def snail(array):\n    ret = []\n    if array and array[0]:\n        size = len(array)\n        for n in range((size + 1) \/\/ 2):\n            for x in range(n, size - n):\n                ret.append(array[n][x])\n            for y in range(1 + n, size - n):\n                ret.append(array[y][-1 - n])\n            for x in range(2 + n, size - n + 1):\n                ret.append(array[-1 - n][-x])\n            for y in range(2 + n, size - n):\n                ret.append(array[-y][n])\n    return ret\n"}
{"task_id":1633,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function that takes a Number as its argument and returns a Chinese numeral string. You don't need to validate the input argument, it will always be a Number in the range `[-99999.999, 99999.999]`, rounded to 8 decimal places.\n\nSimplified Chinese numerals have characters representing each number from 0 to 9 and additional numbers representing larger numbers like 10, 100, 1000, and 10000. \n\n```\n0 l\u00edng \u96f6\n1 y\u012b \u4e00\n2 \u00e8r \u4e8c\n3 s\u0101n \u4e09\n4 s\u00ec \u56db\n5 w\u01d4 \u4e94\n6 li\u00f9 \u516d\n7 q\u012b \u4e03\n8 b\u0101 \u516b\n9 ji\u01d4 \u4e5d\n10 sh\u00ed \u5341\n100 b\u01cei \u767e\n1000 qi\u0101n \u5343\n10000 w\u00e0n \u4e07\n```\n\nMultiple-digit numbers are constructed by first the digit value (1 to 9) and then the place multiplier (such as 10, 100, 1000), starting with the most significant digit. A special case is made for 10 - 19 where the leading digit value (y\u012b \u4e00) is dropped. Note that this special case is only made for the actual values 10 - 19, not any larger values.\n\n```\n10 \u5341\n11 \u5341\u4e00\n18 \u5341\u516b\n21 \u4e8c\u5341\u4e00\n110 \u4e00\u767e\u4e00\u5341\n123 \u4e00\u767e\u4e8c\u5341\u4e09\n24681 \u4e8c\u4e07\u56db\u5343\u516d\u767e\u516b\u5341\u4e00\n```\n\nTrailing zeros are omitted, but interior zeros are grouped together and indicated by a single \u96f6 character without giving the place multiplier.\n\n```\n10 \u5341\n20 \u4e8c\u5341\n104 \u4e00\u767e\u96f6\u56db\n1004 \u4e00\u5343\u96f6\u56db\n10004 \u4e00\u4e07\u96f6\u56db\n10000 \u4e00\u4e07\n```\n\nDecimal numbers are constructed by first writing the whole number part, and then inserting a point (di\u01cen \u70b9), followed by the decimal portion. The decimal portion is expressed using only the digits 0 to 9, without any positional characters and without grouping zeros.\n\n```\n0.1 \u96f6\u70b9\u4e00\n123.45 \u4e00\u767e\u4e8c\u5341\u4e09\u70b9\u56db\u4e94\n```\n\nNegative numbers are the same as other numbers, but add a \u8d1f (f\u00f9) before the number.\n\nFor more information, please see http:\/\/en.wikipedia.org\/wiki\/Chinese_numerals.\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\nNEG, DOT, _, *DIGS = \"\u8d1f\u70b9 \u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\"\nPOWS = \" \u5341 \u767e \u5343 \u4e07\".split(' ')\nNUMS = {str(i):c for i,c in enumerate(DIGS)}\nfor n in range(10): NUMS[str(n+10)] = POWS[1] + DIGS[n]*bool(n)\n\n\ndef to_chinese_numeral(n):\n","entry_point":"to_chinese_numeral","test":"def check(candidate):\n    assert candidate(0) == '\u96f6'\n    assert candidate(9) == '\u4e5d'\n    assert candidate(99) == '\u4e5d\u5341\u4e5d'\n    assert candidate(999) == '\u4e5d\u767e\u4e5d\u5341\u4e5d'\n    assert candidate(9999) == '\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d'\n    assert candidate(99999) == '\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d'\n    assert candidate(-5) == '\u8d1f\u4e94'\n    assert candidate(-54) == '\u8d1f\u4e94\u5341\u56db'\n    assert candidate(-543) == '\u8d1f\u4e94\u767e\u56db\u5341\u4e09'\n    assert candidate(-5432) == '\u8d1f\u4e94\u5343\u56db\u767e\u4e09\u5341\u4e8c'\n    assert candidate(-54321) == '\u8d1f\u4e94\u4e07\u56db\u5343\u4e09\u767e\u4e8c\u5341\u4e00'\n    assert candidate(0.5) == '\u96f6\u70b9\u4e94'\n    assert candidate(0.25) == '\u96f6\u70b9\u4e8c\u4e94'\n    assert candidate(0.125) == '\u96f6\u70b9\u4e00\u4e8c\u4e94'\n    assert candidate(0.0625) == '\u96f6\u70b9\u96f6\u516d\u4e8c\u4e94'\n    assert candidate(0.03125) == '\u96f6\u70b9\u96f6\u4e09\u4e00\u4e8c\u4e94'\n    assert candidate(10) == '\u5341'\n    assert candidate(14) == '\u5341\u56db'\n    assert candidate(18) == '\u5341\u516b'\n    assert candidate(20) == '\u4e8c\u5341'\n    assert candidate(24) == '\u4e8c\u5341\u56db'\n    assert candidate(50) == '\u4e94\u5341'\n    assert candidate(100) == '\u4e00\u767e'\n    assert candidate(110) == '\u4e00\u767e\u4e00\u5341'\n    assert candidate(111) == '\u4e00\u767e\u4e00\u5341\u4e00'\n    assert candidate(-10) == '\u8d1f\u5341'\n    assert candidate(-14) == '\u8d1f\u5341\u56db'\n    assert candidate(-18) == '\u8d1f\u5341\u516b'\n    assert candidate(-20) == '\u8d1f\u4e8c\u5341'\n    assert candidate(-100) == '\u8d1f\u4e00\u767e'\n    assert candidate(-110) == '\u8d1f\u4e00\u767e\u4e00\u5341'\n    assert candidate(-111) == '\u8d1f\u4e00\u767e\u4e00\u5341\u4e00'\n    assert candidate(1000) == '\u4e00\u5343'\n    assert candidate(10000) == '\u4e00\u4e07'\n    assert candidate(10306) == '\u4e00\u4e07\u96f6\u4e09\u767e\u96f6\u516d'\n    assert candidate(10006) == '\u4e00\u4e07\u96f6\u516d'\n    assert candidate(10006.005) == '\u4e00\u4e07\u96f6\u516d\u70b9\u96f6\u96f6\u4e94'\n    assert candidate(-10306.005) == '\u8d1f\u4e00\u4e07\u96f6\u4e09\u767e\u96f6\u516d\u70b9\u96f6\u96f6\u4e94'\n    assert candidate(-10.000001) == '\u8d1f\u5341\u70b9\u96f6\u96f6\u96f6\u96f6\u96f6\u4e00'\n    assert candidate(99999.999) == '\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u70b9\u4e5d\u4e5d\u4e5d'\n    assert candidate(-99999.999) == '\u8d1f\u4e5d\u4e07\u4e5d\u5343\u4e5d\u767e\u4e5d\u5341\u4e5d\u70b9\u4e5d\u4e5d\u4e5d'\n\n","canonical_solution":"import re\n\nNEG, DOT, _, *DIGS = \"\u8d1f\u70b9 \u96f6\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\"\nPOWS = \" \u5341 \u767e \u5343 \u4e07\".split(' ')\nNUMS = {str(i):c for i,c in enumerate(DIGS)}\nfor n in range(10): NUMS[str(n+10)] = POWS[1] + DIGS[n]*bool(n)\n\n\ndef to_chinese_numeral(n):\n    ss = str(abs(n)).split('.')\n    return NEG*(n<0) + parse(ss[0]) + (len(ss)>1 and decimals(ss[1]) or '')\n\ndef decimals(digs): return DOT + ''.join(NUMS[d] for d in digs)\n\ndef parse(s):\n    if s in NUMS: return NUMS[s]\n    s = ''.join(reversed([ NUMS[d] + POWS[i]*(d!='0') for i,d in enumerate(reversed(s)) ]))\n    return re.sub(f'\u96f6+$|(?<=\u96f6)\u96f6+', '', s)"}
{"task_id":1648,"prompt":"\"\"\"\n=====Problem statement====\n\nThis is the performance version of [this kata](https:\/\/www.codewars.com\/kata\/59afff65f1c8274f270020f5).\n\n---\n\nImagine two rings with numbers on them. The inner ring spins clockwise and the outer ring spins anti-clockwise. We start with both rings aligned on 0 at the top, and on each move we spin each ring by 1. How many moves will it take before both rings show the same number at the top again?\n\nThe inner ring has integers from 0 to innerMax and the outer ring has integers from 0 to outerMax, where innerMax and outerMax are integers >= 1.\n\n```\ne.g. if innerMax is 2 and outerMax is 3 then after\n1 move: inner = 2, outer = 1\n2 moves: inner = 1, outer = 2\n3 moves: inner = 0, outer = 3\n4 moves: inner = 2, outer = 0\n5 moves: inner = 1, outer = 1\nTherefore it takes 5 moves for the two rings to reach the same number\nTherefore spinningRings(2, 3) = 5\n```\n```\ne.g. if innerMax is 3 and outerMax is 2 then after\n1 move: inner = 3, outer = 1\n2 moves: inner = 2, outer = 2\nTherefore it takes 2 moves for the two rings to reach the same number\nspinningRings(3, 2) = 2\n```\n\n---\n\nTest input range:\n\n- `100` tests with `1 <= innerMax, outerMax <= 10000`\n- `400` tests with `1 <= innerMax, outerMax <= 2^48`\n\"\"\"\n\n# ====== Solution ======\n\ndef spinning_rings(inner_max, outer_max):\n","entry_point":"spinning_rings","test":"def check(candidate):\n    assert candidate(5,5) == 3\n    assert candidate(2,10) == 13\n    assert candidate(10,2) == 10\n    assert candidate(7,9) == 4\n    assert candidate(1,1) == 1\n    assert candidate(16777216,14348907) == 23951671\n\n","canonical_solution":"def spinning_rings(inner_max, outer_max):\n    p = inner_max + 1\n    q = outer_max + 1\n    move = 1\n    while (-move) % p != move % q:\n        if (-move) % p >= q:\n            move = move \/\/ p * p + p - q + 1\n        elif move % q >= p:\n            move = move \/\/ q * q + q\n        elif (-move) % p > move % q and ((-move) % p + move % q) % 2 == 0:\n            move += ((-move) % p - move % q) \/\/ 2\n        else:\n            move = min((move - 1) \/\/ p * p + p, (move - 1) \/\/ q * q + q) + 1\n    return move"}
{"task_id":1654,"prompt":"\"\"\"\n=====Problem statement====\n\nTo give credit where credit is due: This problem was taken from the ACMICPC-Northwest Regional Programming Contest. Thank you problem writers.\n\nYou are helping an archaeologist decipher some runes. He knows that this ancient society used a Base 10 system, and that they never start a number with a leading zero. He's figured out most of the digits as well as a few operators, but he needs your help to figure out the rest.\n\nThe professor will give you a simple math expression, of the form\n\n```\n[number][op][number]=[number]\n```\n\nHe has converted all of the runes he knows into digits. The only operators he knows are addition (`+`),subtraction(`-`), and multiplication (`*`), so those are the only ones that will appear. Each number will be in the range from -1000000 to 1000000, and will consist of only the digits 0-9, possibly a leading -, and maybe a few ?s. If there are ?s in an expression, they represent a digit rune that the professor doesn't know (never an operator, and never a leading -). All of the ?s in an expression will represent the same digit (0-9), and it won't be one of the other given digits in the expression. No number will begin with a 0 unless the number itself is  0, therefore 00 would not be a valid number. \n\nGiven an expression, figure out the value of the rune represented by the question mark. If more than one digit works, give the lowest one. If no digit works, well, that's bad news for the professor - it means that he's got some of his runes wrong. output -1 in that case.\n\nComplete the method to solve the expression to find the value of the unknown rune. The method takes a string as a paramater repressenting the expression and will return an int value representing the unknown rune or -1 if no such rune exists.\n\n~~~if:php\n**Most of the time, the professor will be able to figure out most of the runes himself, but sometimes, there may be exactly 1 rune present in the expression that the professor cannot figure out (resulting in all question marks where the digits are in the expression) so be careful ;)**\n~~~\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\ndef solve_runes(runes):\n","entry_point":"solve_runes","test":"def check(candidate):\n    assert candidate('123?45*?=?') == 0\n    assert candidate('?*123?45=?') == 0\n    assert candidate('??605*-63=-73???5') == 1\n    assert candidate('123?45+?=123?45') == 0\n    assert candidate('?8?170-1?6256=7?2?14') == 9\n    assert candidate('?38???+595???=833444') == 2\n    assert candidate('123?45-?=123?45') == 0\n    assert candidate('-7715?5--484?00=-28?9?5') == 6\n    assert candidate('50685?--1?5630=652?8?') == 4\n    assert candidate('??+??=??') == -1\n    assert candidate('-?56373--9216=-?47157') == 8\n\n","canonical_solution":"import re\n\ndef solve_runes(runes):\n    for d in sorted(set(\"0123456789\") - set(runes)):\n        toTest = runes.replace(\"?\",d)\n        if re.search(r'([^\\d]|\\b)0\\d+', toTest): continue\n        l,r = toTest.split(\"=\")\n        if eval(l) == eval(r): return int(d)\n    return -1"}
{"task_id":1660,"prompt":"\"\"\"\n=====Problem statement====\n\nWhen we attended middle school were asked to simplify mathematical expressions like \"3x-yx+2xy-x\" (or usually bigger), and that was easy-peasy (\"2x+xy\"). But tell that to your pc and we'll see! \n\nWrite a function: `simplify`, that takes a string in input, representing a *multilinear non-constant polynomial in integers coefficients* (like `\"3x-zx+2xy-x\"`), and returns another string as output where the same expression has been simplified in the following way ( `->` means application of `simplify`):\n\n- All possible sums and subtraction of equivalent monomials (\"xy==yx\") has been done, e.g.: `\"cb+cba\" -> \"bc+abc\"`, `\"2xy-yx\" -> \"xy\"`, `\"-a+5ab+3a-c-2a\" -> \"-c+5ab\"`\n\n- All monomials appears in order of increasing number of variables, e.g.: `\"-abc+3a+2ac\" -> \"3a+2ac-abc\"`, `\"xyz-xz\" -> \"-xz+xyz\"`\n \n- If two monomials have the same number of variables, they appears in lexicographic order, e.g.: `\"a+ca-ab\" -> \"a-ab+ac\"`, `\"xzy+zby\" ->\"byz+xyz\"`\n  \n- There is no leading `+` sign if the first coefficient is positive, e.g.: `\"-y+x\" -> \"x-y\"`, but no restrictions for `-`:  `\"y-x\" ->\"-x+y\"`\n\n---\n\n__N.B.__ to keep it simplest, the string in input is restricted to represent only *multilinear non-constant polynomials*, so you won't find something like `-3+yx^2'. **Multilinear** means in this context: **of degree 1 on each variable**.\n\n**Warning**: the string in input can contain arbitrary variables represented by lowercase characters in the english alphabet.\n\n__Good Work :)__\n\"\"\"\n\n# ====== Solution ======\n\ndef simplify(poly):\n","entry_point":"simplify","test":"def check(candidate):\n    assert candidate('dc+dcba') == 'cd+abcd'\n    assert candidate('2xy-yx') == 'xy'\n    assert candidate('-a+5ab+3a-c-2a') == '-c+5ab'\n    assert candidate('-abc+3a+2ac') == '3a+2ac-abc'\n    assert candidate('xyz-xz') == '-xz+xyz'\n    assert candidate('a+ca-ab') == 'a-ab+ac'\n    assert candidate('xzy+zby') == 'byz+xyz'\n    assert candidate('-y+x') == 'x-y'\n    assert candidate('y-x') == '-x+y'\n    assert candidate('3a+b+4ac+bc-ab+3a-cb-a-a') == '4a+b-ab+4ac'\n    assert candidate('+n-5hn+7tjhn-4nh-3n-6hnjt+2jhn+9hn') == '-2n+2hjn+hjnt'\n    assert candidate('-8fk+5kv-4yk+7kf-qk+yqv-3vqy+4ky+4kf+yvqkf') == '3fk-kq+5kv-2qvy+fkqvy'\n\n","canonical_solution":"def simplify(poly):\n    # I'm feeling verbose today\n    \n    # get 3 parts (even if non-existent) of each term: (+\/-, coefficient, variables)\n    import re\n    matches = re.findall(r'([+\\-]?)(\\d*)([a-z]+)', poly)\n    \n    # get the int equivalent of coefficient (including sign) and the sorted variables (for later comparison)\n    expanded = [[int(i[0] + (i[1] if i[1] != \"\" else \"1\")), ''.join(sorted(i[2]))] for i in matches]\n    \n    # get the unique variables from above list. Sort them first by length, then alphabetically\n    variables = sorted(list(set(i[1] for i in expanded)), key=lambda x: (len(x), x))\n    \n    # get the sum of coefficients (located in expanded) for each variable\n    coefficients = {v:sum(i[0] for i in expanded if i[1] == v) for v in variables}\n    \n    # clean-up: join them with + signs, remove '1' coefficients, and change '+-' to '-'\n    return '+'.join(str(coefficients[v]) + v for v in variables if coefficients[v] != 0).replace('1','').replace('+-','-')"}
{"task_id":2654,"prompt":"\"\"\"\n=====Problem statement====\n\nKate and Michael want to buy a pizza and share it. Depending on the price of the pizza, they are going to divide the costs:\n\n* If the pizza is less than \u20ac5,- Michael invites Kate, so Michael pays the full price.\n* Otherwise Kate will contribute 1\/3 of the price, but no more than \u20ac10 (she's broke :-) and Michael pays the rest.\n\nHow much is Michael going to pay? Calculate the amount with two decimals, if necessary.\n\"\"\"\n\n# ====== Solution ======\n\ndef michael_pays(cost):\n","entry_point":"michael_pays","test":"def check(candidate):\n    assert candidate(15) == 10\n    assert candidate(4) == 4\n    assert candidate(4.99) == 4.99\n    assert candidate(5) == 3.33\n    assert candidate(30) == 20\n    assert candidate(80) == 70\n    assert candidate(22) == 14.67\n    assert candidate(5.9181) == 3.95\n    assert candidate(28.789) == 19.19\n    assert candidate(4.325) == 4.33\n\n","canonical_solution":"def michael_pays(cost):\n    return round(cost if cost < 5 else max(cost*2\/3, cost-10), 2)"}
{"task_id":2662,"prompt":"\"\"\"\n=====Problem statement====\n\nPete and his mate Phil are out in the countryside shooting clay pigeons with a shotgun - amazing fun. \n\nThey decide to have a competition. 3 rounds, 2 shots each. Winner is the one with the most hits.\n\nSome of the clays have something attached to create lots of smoke when hit, guarenteed by the packaging to generate 'real excitement!' (genuinely this happened). None of the explosive things actually worked, but for this kata lets say they did.\n\nFor each round you will receive the following format:\n\n[{P1:'XX', P2:'XO'}, true]\n\nThat is an array containing an object and a boolean. Pl represents Pete, P2 represents Phil. X represents a hit and O represents a miss. If the boolean is true, any hit is worth 2. If it is false, any hit is worth 1.\n\nFind out who won. If it's Pete, return 'Pete Wins!'. If it is Phil, return 'Phil Wins!'. If the scores are equal, return 'Draw!'.\n\nNote that as there are three rounds, the actual input (x) will look something like this:\n\n[[{P1:'XX', P2:'XO'}, true], [{P1:'OX', P2:'OO'}, false], [{P1:'XX', P2:'OX'}, true]]\n\"\"\"\n\n# ====== Solution ======\n\ndef shoot(results):\n","entry_point":"shoot","test":"def check(candidate):\n    assert candidate([[{'P1': 'XX', 'P2': 'XO'}, True], [{'P1': 'OX', 'P2': 'OO'}, False], [{'P1': 'XX', 'P2': 'OX'}, True]]) == 'Pete Wins!'\n    assert candidate([[{'P1': 'XX', 'P2': 'XO'}, False], [{'P1': 'OX', 'P2': 'XX'}, False], [{'P1': 'OO', 'P2': 'XX'}, True]]) == 'Phil Wins!'\n    assert candidate([[{'P1': 'OO', 'P2': 'XX'}, False], [{'P1': 'OO', 'P2': 'XX'}, False], [{'P1': 'XX', 'P2': 'OO'}, True]]) == 'Draw!'\n    assert candidate([[{'P1': 'XX', 'P2': 'XX'}, True], [{'P1': 'XX', 'P2': 'OX'}, False], [{'P1': 'OO', 'P2': 'OX'}, True]]) == 'Phil Wins!'\n    assert candidate([[{'P1': 'XX', 'P2': 'XX'}, True], [{'P1': 'OO', 'P2': 'OO'}, False], [{'P1': 'XX', 'P2': 'XX'}, True]]) == 'Draw!'\n\n","canonical_solution":"def shoot(results):\n    pete = phil = 0\n    \n    for shots, double in results:\n        pete += shots[\"P1\"].count(\"X\") * (1 + double)\n        phil += shots[\"P2\"].count(\"X\") * (1 + double)\n    \n    return \"Pete Wins!\" if pete > phil else \"Phil Wins!\" if phil > pete else \"Draw!\""}
{"task_id":2664,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this Kata, you will check if it is possible to convert a string to a palindrome by changing one character. \n\nFor instance:\n```Haskell\nsolve (\"abbx\") = True, because we can convert 'x' to 'a' and get a palindrome. \nsolve (\"abba\") = False, because we cannot get a palindrome by changing any character. \nsolve (\"abcba\") = True. We can change the middle character. \nsolve (\"aa\") = False \nsolve (\"ab\") = True\n```\n\nGood luck!\n\nPlease also try [Single Character Palindromes](https:\/\/www.codewars.com\/kata\/5a2c22271f7f709eaa0005d3)\n\"\"\"\n\n# ====== Solution ======\n\ndef solve(s):\n","entry_point":"solve","test":"def check(candidate):\n    assert candidate('abba') == False\n    assert candidate('abbaa') == True\n    assert candidate('abbx') == True\n    assert candidate('aa') == False\n    assert candidate('ab') == True\n    assert candidate('abcba') == True\n\n","canonical_solution":"def solve(s):\n    v = sum(s[i] != s[-1-i] for i in range((len(s))\/\/2) )\n    return v == 1 or not v and len(s)%2"}
{"task_id":2668,"prompt":"\"\"\"\n=====Problem statement====\n\nStep through my `green glass door`.\n\nYou can take the `moon`, but not the `sun`.\n\nYou can take your `slippers`, but not your `sandals`.\n\nYou can go through `yelling`, but not `shouting`.\n\nYou can't run through `fast`, but you can run with `speed`.\n\nYou can take a `sheet`, but not your `blanket`.\n\nYou can wear your `glasses`, but not your `contacts`.\n\nHave you figured it out? Good! Then write a program that can figure it out as well.\n\"\"\"\n\n# ====== Solution ======\n\ndef step_through_with(s):\n","entry_point":"step_through_with","test":"def check(candidate):\n    assert candidate('moon') == True\n    assert candidate('test') == False\n    assert candidate('glasses') == True\n    assert candidate('airplane') == False\n    assert candidate('free') == True\n    assert candidate('branch') == False\n    assert candidate('aardvark') == True\n\n","canonical_solution":"def step_through_with(s):\n    return any(m == n for m, n in zip(s, s[1:]))"}
{"task_id":2671,"prompt":"\"\"\"\n=====Problem statement====\n\nYou will be given a string (x) featuring a cat 'C', a dog 'D' and a mouse 'm'. The rest of the string will be made up of '.'. \n\nYou need to find out if the cat can catch the mouse from it's current position. The cat can jump (j) characters. \n\nAlso, the cat cannot jump over the dog.\n\nSo:\n\nif j = 5:\n\n```..C.....m.``` returns 'Caught!'  <-- not more than j characters between\n\n```.....C............m......``` returns 'Escaped!'  <-- as there are more than j characters between the two, the cat can't jump far enough\n\nif j = 10:\n\n```...m.........C...D``` returns 'Caught!' <--Cat can jump far enough and jump is not over dog\n\n```...m....D....C.......``` returns 'Protected!' <-- Cat can jump far enough, but dog is in the way, protecting the mouse\n\nFinally, if all three animals are not present, return 'boring without all three'\n\"\"\"\n\n# ====== Solution ======\n\ndef cat_mouse(x,j):\n","entry_point":"cat_mouse","test":"def check(candidate):\n    assert candidate('..D.....C.m',2) == 'Caught!'\n    assert candidate('............C.............D..m...',8) == 'Escaped!'\n    assert candidate('m.C...',5) == 'boring without all three'\n    assert candidate('.CD......m.',10) == 'Protected!'\n    assert candidate('.CD......m.',1) == 'Escaped!'\n\n","canonical_solution":"def cat_mouse(x,j):\n    d, c, m = x.find('D'), x.find('C'), x.find('m')\n    if -1 in [d, c, m]:\n        return 'boring without all three'\n    if abs(c - m) <= j:\n        return 'Protected!' if c < d < m or m < d < c else 'Caught!' \n    return 'Escaped!'"}
{"task_id":2674,"prompt":"\"\"\"\n=====Problem statement====\n\nYou will be given a vector of strings. You must sort it alphabetically (case-sensitive, and based on the ASCII values of the chars) and then return the first value.\n\nThe returned value must be a string, and have `\"***\"` between each of its letters.\n\nYou should not remove or add elements from\/to the array.\n\"\"\"\n\n# ====== Solution ======\n\ndef two_sort(lst):\n","entry_point":"two_sort","test":"def check(candidate):\n    assert candidate(['bitcoin', 'take', 'over', 'the', 'world', 'maybe', 'who', 'knows', 'perhaps']) == 'b***i***t***c***o***i***n'\n    assert candidate(['turns', 'out', 'random', 'test', 'cases', 'are', 'easier', 'than', 'writing', 'out', 'basic', 'ones']) == 'a***r***e'\n    assert candidate(['lets', 'talk', 'about', 'javascript', 'the', 'best', 'language']) == 'a***b***o***u***t'\n    assert candidate(['i', 'want', 'to', 'travel', 'the', 'world', 'writing', 'code', 'one', 'day']) == 'c***o***d***e'\n    assert candidate(['Lets', 'all', 'go', 'on', 'holiday', 'somewhere', 'very', 'cold']) == 'L***e***t***s'\n\n","canonical_solution":"def two_sort(lst):\n    return '***'.join(min(lst))"}
{"task_id":2676,"prompt":"\"\"\"\n=====Problem statement====\n\nIn a far away country called AlgoLandia, there are `N` islands numbered `1` to `N`. Each island is denoted by `k[i]`. King Algolas, king of AlgoLandia, built `N - 1` bridges in the country. A bridge is built between islands `k[i]` and `k[i+1]`. Bridges are two-ways and are expensive to build.\n\nThe problem is that there are gangs who wants to destroy the bridges. In order to protect the bridges, the king wants to assign elite guards to the bridges. A bridge between islands `k[i]` and `k[i+1]` is safe when there is an elite guard in island `k[i]` or `k[i+1]`. There are already elite guards assigned in some islands.\n\nYour task now is to determine the minimum number of additional elite guards that needs to be hired to guard all the bridges.\n\n### Note:\nYou are given a sequence `k` with `N` length.\n`k[i] = true`, means that there is an elite guard in that island; `k[i] = false` means no elite guard. It is guaranteed that AlgoLandia have at least `2` islands.\n\n### Sample Input 1\n```\nk = [true, true, false, true, false]\n```\n\n### Sample Output 1\n```\n0\n```\n\n### Sample Input 2\n```\nk = [false, false, true, false, false]\n```\n### Sample Output 2\n```\n2\n```\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import groupby\n\ndef find_needed_guards(islands):\n","entry_point":"find_needed_guards","test":"def check(candidate):\n    assert candidate([True, True, False, True, False]) == 0\n    assert candidate([False, False, True, False, False]) == 2\n    assert candidate([False, False, False, False, False]) == 2\n    assert candidate([False, False, False, False, False, False]) == 3\n    assert candidate([False, False]) == 1\n    assert candidate([True, False]) == 0\n    assert candidate([False, False, False, True, False, False, False, True]) == 2\n    assert candidate([False, False, True, False, True, True, True, False, True, True, True, False, True, False, False, False, True, False, False, True, True, True, True, True, False, True, False, True, True, False]) == 3\n    assert candidate([True, False, True, True, False, True, False, False, False, True, True, False, True, True, False, True, False, False, True, True, False, True, False, True, True, False, False, False, True, False, False, False, True, False, True, True, True, True, True, True, False]) == 4\n    assert candidate([True, True, True, True, True, True, False, True, True, True, True, True, True, True, True, True, True, False, True, True, True, True, True, False, True, True, True, True, True, False, True, True, True, True, True, True, True, True, True, False, True, True, True, True]) == 0\n    assert candidate([True, True, True]) == 0\n    assert candidate([True, True, True, True, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, True, True, True, True, True, True, True, True, True, True, True, True]) == 1\n    assert candidate([True, True, True, False, True]) == 0\n    assert candidate([True, True, True, True, True, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, True, True, True, True, True, True, True, True, True, True, True, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, True, True, True, True, True, True, True, False, True, True, True, True, True, True, False, True, True, True, True, True, True, True, True, True]) == 1\n    assert candidate([True, True, True, True, True, True, True, True, True, True, True, True, False, True, True, True, False, True, True, True, True, True, True, False, True, True, True, False, True, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True]) == 1\n    assert candidate([True, True, True, True, True, True, True, True, True, True, True, False]) == 0\n    assert candidate([True, True]) == 0\n    assert candidate([True, True, True, True, True, True, False, False, False, True, True, True, True, False, True, True, True, True, True, False, True, True, True, False, True, True, True, True, True, True, True, True, True, True, True, True, True]) == 1\n    assert candidate([True, True, False, False, False, True, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, False, True, True, True, True, True, True, True, False, True, True, True, True, False, True, True, True, True, True, True, True, True, True, True, True, False, False, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True, True]) == 2\n\n","canonical_solution":"from itertools import groupby\n\ndef find_needed_guards(islands):\n    return sum(sum(1 for _ in g)>>1 for k,g in groupby(islands) if not k)"}
{"task_id":2681,"prompt":"\"\"\"\n=====Problem statement====\n\nYou drop a ball from a given height. After each bounce, the ball returns to some fixed proportion of its previous height. If the ball bounces to height 1 or less, we consider it to have stopped bouncing. Return the number of bounces it takes for the ball to stop moving.\n\n```\nbouncingBall(initialHeight, bouncingProportion)\n\nboucingBall(4, 0.5)\nAfter first bounce, ball bounces to height 2\nAfter second bounce, ball bounces to height 1\nTherefore answer is 2 bounces\n\nboucingBall(30, 0.3)\nAfter first bounce, ball bounces to height 9\nAfter second bounce, ball bounces to height 2.7\nAfter third bounce, ball bounces to height 0.81\nTherefore answer is 3 bounces\n\n\n```\n\nInitial height is an integer in range [2,1000]\n\nBouncing Proportion is a decimal in range [0, 1)\n\"\"\"\n\n# ====== Solution ======\n\nimport math\n\ndef bouncing_ball(initial, proportion):\n","entry_point":"bouncing_ball","test":"def check(candidate):\n    assert candidate(2,0.5) == 1\n    assert candidate(4,0.5) == 2\n    assert candidate(10,0.1) == 1\n    assert candidate(100,0.1) == 2\n    assert candidate(9,0.3) == 2\n    assert candidate(30,0.3) == 3\n\n","canonical_solution":"import math\n\ndef bouncing_ball(initial, proportion):\n    return math.ceil(math.log(initial, 1\/proportion))"}
{"task_id":2687,"prompt":"\"\"\"\n=====Problem statement====\n\nComplete the method so that it formats the words into a single comma separated value. The last word should be separated by the word 'and' instead of a comma. The method takes in an array of strings and returns a single formatted string. Empty string values should be ignored. Empty arrays or null\/nil values being passed into the method should result in an empty string being returned. \n\n```Python\nformat_words(['ninja', 'samurai', 'ronin']) # should return \"ninja, samurai and ronin\"\nformat_words(['ninja', '', 'ronin']) # should return \"ninja and ronin\"\nformat_words([]) # should return \"\"\n```\n```Haskell\nformatWords [\"ninja\", \"samurai\", \"ronin\"] -- should return \"ninja, samurai and ronin\"\nformatWords [\"ninja\", \"\", \"ronin\"] -- should return \"ninja and ronin\"\nformatWords [] -- should return \"\"\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef format_words(words):\n","entry_point":"format_words","test":"def check(candidate):\n    assert candidate(['one', 'two', 'three', 'four']) == 'one, two, three and four'\n    assert candidate(['one']) == 'one'\n    assert candidate(['one', '', 'three']) == 'one and three'\n    assert candidate(['', '', 'three']) == 'three'\n    assert candidate(['one', 'two', '']) == 'one and two'\n    assert candidate([]) == ''\n    assert candidate(None) == ''\n    assert candidate(['']) == ''\n\n","canonical_solution":"def format_words(words):\n    return ', '.join(word for word in words if word)[::-1].replace(',', 'dna ', 1)[::-1] if words else ''"}
{"task_id":2688,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n let F(N) be the sum square of digits of N. So:\n \n `F(1) = 1, F(3) = 9, F(123) = 14`\n\n Choose a number A, the sequence {A0, A1, ...} is defined as followed:\n  ```\n  A0 = A\n  A1 = F(A0)\n  A2 = F(A1) ...\n  ```\n  \n  if A = 123, we have:\n  ```\n  123 \u2192 14(1 x 1 + 2 x 2 + 3 x 3)\n      \u2192 17(1 x 1 + 4 x 4)\n      \u2192 50(1 x 1 + 7 x 7)\n      \u2192 25(5 x 5 + 0 x 0)\n      \u2192 29(2 x 2 + 5 x 5)\n      \u2192 85(2 x 2 + 9 x 9)\n      \u2192 89(8 x 8 + 5 x 5)             ---\n      \u2192 145(8 x 8 + 9 x 9)             |r\n      \u2192 42(1 x 1 + 4 x 4 + 5 x 5)      |e\n      \u2192 20(4 x 4 + 2 x 2)              |p\n      \u2192 4(2 x 2 + 0 x 0)               |e\n      \u2192 16(4 x 4)                      |a\n      \u2192 37(1 x 1 + 6 x 6)              |t\n      \u2192 58(3 x 3 + 7 x 7)              |\n      \u2192 89(5 x 5 + 8 x 8)             --- \n      \u2192 ......\n  ```\n\n As you can see, the sequence repeats itself. Interestingly, whatever A is, there's an index such that from it, the sequence repeats again and again.\n\n Let `G(A)` be the minimum length of the repeat sequence with A0 = A. \n\n So `G(85) = 8` (8 number : `89,145,42, 20,4,16,37,58`)\n\n Your task is to find G(A) and return it.\n\n# Input\/Output\n\n\n - `[input]` integer `a0`\n\n  the A0 number\n\n\n - `[output]` an integer\n\n  the length of the repeat sequence\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import count\n\n# Couldn't find the pattern of why it's 1 or 8, I'm sad :(\ndef repeat_sequence_len(n):\n","entry_point":"repeat_sequence_len","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(85) == 8\n    assert candidate(810) == 8\n    assert candidate(812) == 8\n    assert candidate(818) == 1\n    assert candidate(833) == 1\n\n","canonical_solution":"from itertools import count\n\n# Couldn't find the pattern of why it's 1 or 8, I'm sad :(\ndef repeat_sequence_len(n):\n    memo = {}\n    for i in count():\n        if n in memo: return i - memo[n]\n        memo[n] = i\n        n = sum(d*d for d in map(int, str(n)))"}
{"task_id":2689,"prompt":"\"\"\"\n=====Problem statement====\n\nYou get a new job working for Eggman Movers.  Your first task is to write a method that will allow the admin staff to enter a person\u2019s name and return what that person's role is in the company.\n\nYou will be given an array of object literals holding the current employees of the company.  You code must find the employee with the matching firstName and lastName and then return the role for that employee or if no employee is not found it should return \"Does not work here!\"\n\nThe array is preloaded and can be referenced using the variable `employees` (`$employees` in Ruby). It uses the following structure.\n\n```python\nemployees = [ {'first_name': \"Dipper\", 'last_name': \"Pines\", 'role': \"Boss\"}, ...... ]\n```\n\nThere are no duplicate names in the array and the name passed in will be a single string with a space between the first and last name i.e. Jane Doe or just a name.\n\"\"\"\n\n# ====== Solution ======\n\nemployees = [{'first_name': 'Ollie', 'last_name': 'Hepburn', 'role': 'Boss'}, {'first_name': 'Morty', 'last_name': 'Smith', 'role': 'Truck Driver'}, {'first_name': 'Peter', 'last_name': 'Ross', 'role': 'Warehouse Manager'}, {'first_name': 'Cal', 'last_name': 'Neil', 'role': 'Sales Assistant'}, {'first_name': 'Jesse', 'last_name': 'Saunders', 'role': 'Admin'}, {'first_name': 'Anna', 'last_name': 'Jones', 'role': 'Sales Assistant'}, {'first_name': 'Carmel', 'last_name': 'Hamm', 'role': 'Admin'}, {'first_name': 'Tori', 'last_name': 'Sparks', 'role': 'Sales Manager'}, {'first_name': 'Peter', 'last_name': 'Jones', 'role': 'Warehouse Picker'}, {'first_name': 'Mort', 'last_name': 'Smith', 'role': 'Warehouse Picker'}, {'first_name': 'Anna', 'last_name': 'Bell', 'role': 'Admin'}, {'first_name': 'Jewel', 'last_name': 'Bell', 'role': 'Receptionist'}, {'first_name': 'Colin', 'last_name': 'Brown', 'role': 'Trainee'}]\ndef find_employees_role(name):\n","entry_point":"find_employees_role","test":"def check(candidate):\n    assert candidate('Dipper Pines') == 'Does not work here!'\n    assert candidate('Morty Smith') == 'Truck Driver'\n    assert candidate('Anna Bell') == 'Admin'\n    assert candidate('Anna') == 'Does not work here!'\n    assert candidate('Bell Anna') == 'Does not work here!'\n    assert candidate('Jewel Bell') == 'Receptionist'\n    assert candidate('Bell Jewel') == 'Does not work here!'\n\n","canonical_solution":"employees = [{'first_name': 'Ollie', 'last_name': 'Hepburn', 'role': 'Boss'}, {'first_name': 'Morty', 'last_name': 'Smith', 'role': 'Truck Driver'}, {'first_name': 'Peter', 'last_name': 'Ross', 'role': 'Warehouse Manager'}, {'first_name': 'Cal', 'last_name': 'Neil', 'role': 'Sales Assistant'}, {'first_name': 'Jesse', 'last_name': 'Saunders', 'role': 'Admin'}, {'first_name': 'Anna', 'last_name': 'Jones', 'role': 'Sales Assistant'}, {'first_name': 'Carmel', 'last_name': 'Hamm', 'role': 'Admin'}, {'first_name': 'Tori', 'last_name': 'Sparks', 'role': 'Sales Manager'}, {'first_name': 'Peter', 'last_name': 'Jones', 'role': 'Warehouse Picker'}, {'first_name': 'Mort', 'last_name': 'Smith', 'role': 'Warehouse Picker'}, {'first_name': 'Anna', 'last_name': 'Bell', 'role': 'Admin'}, {'first_name': 'Jewel', 'last_name': 'Bell', 'role': 'Receptionist'}, {'first_name': 'Colin', 'last_name': 'Brown', 'role': 'Trainee'}]\ndef find_employees_role(name):\n    \n    for employee in employees:\n        if employee['first_name'] + ' ' + employee['last_name'] == name:\n            return employee['role']\n        \n    return \"Does not work here!\""}
{"task_id":2717,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array of integers, return the smallest common factors of all integers in the array.\n\nWhen i say **Smallest Common Factor** i mean the smallest number above 1 that can divide all numbers in the array without a remainder.\n\nIf there are no common factors above 1, return 1 (technically 1 is always a common factor).\n\"\"\"\n\n# ====== Solution ======\n\ndef scf(lst):\n","entry_point":"scf","test":"def check(candidate):\n    assert candidate([200, 30, 18, 8, 64, 34]) == 2\n    assert candidate([21, 45, 51, 27, 33]) == 3\n    assert candidate([133, 147, 427, 266]) == 7\n    assert candidate([3, 5, 7]) == 1\n    assert candidate([]) == 1\n\n","canonical_solution":"def scf(lst):\n    return next((k for k in range(2, 1 + min(lst, default=1)) if all(n % k == 0 for n in lst)), 1)\n"}
{"task_id":2723,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are given a string of numbers between 0-9. Find the average of these numbers and return it as a floored whole number (ie: no decimal places) written out as a string. Eg:\n\n\"zero nine five two\" -> \"four\"\n\nIf the string is empty or includes a number greater than 9, return \"n\/a\"\n\"\"\"\n\n# ====== Solution ======\n\nN = ['zero','one','two','three','four','five','six','seven','eight','nine']\n\ndef average_string(s):\n","entry_point":"average_string","test":"def check(candidate):\n    assert candidate('zero nine five two') == 'four'\n    assert candidate('four six two three') == 'three'\n    assert candidate('one two three four five') == 'three'\n    assert candidate('five four') == 'four'\n    assert candidate('zero zero zero zero zero') == 'zero'\n    assert candidate('one one eight one') == 'two'\n    assert candidate('one') == 'one'\n    assert candidate('') == 'n\/a'\n    assert candidate('ten') == 'n\/a'\n    assert candidate('pippi') == 'n\/a'\n\n","canonical_solution":"N = ['zero','one','two','three','four','five','six','seven','eight','nine']\n\ndef average_string(s):\n    try:\n        return N[sum(N.index(w) for w in s.split()) \/\/ len(s.split())]\n    except (ZeroDivisionError, ValueError):\n        return 'n\/a'"}
{"task_id":2724,"prompt":"\"\"\"\n=====Problem statement====\n\nModify the `kebabize` function so that it converts a camel case string into a kebab case.\n\nNotes:\n  - the returned string should only contain lowercase letters\n\"\"\"\n\n# ====== Solution ======\n\ndef kebabize(s):\n","entry_point":"kebabize","test":"def check(candidate):\n    assert candidate('myCamelCasedString') == 'my-camel-cased-string'\n    assert candidate('myCamelHas3Humps') == 'my-camel-has-humps'\n    assert candidate('SOS') == 's-o-s'\n    assert candidate('42') == ''\n    assert candidate('CodeWars') == 'code-wars'\n\n","canonical_solution":"def kebabize(s):\n    return ''.join(c if c.islower() else '-' + c.lower() for c in s if c.isalpha()).strip('-')"}
{"task_id":2728,"prompt":"\"\"\"\n=====Problem statement====\n\nA common problem in number theory is to find x given a such that:\n\na * x = 1 mod [n] \n\nThen x is called the inverse of a modulo n. \n\nYour goal is to code a function inverseMod wich take a and n as parameters and return x.\n\nYou may be interested by these pages:\n\nhttp:\/\/en.wikipedia.org\/wiki\/Modular_multiplicative_inverse\n\nhttp:\/\/en.wikipedia.org\/wiki\/Extended_Euclidean_algorithm\n\n\na and n should be co-prime to have a solution, if it is not the case, you should return None (Python), nil (Ruby) or null (Javascript). \n\na and n will be positive integers. The problem can easily be generalised to negative integer with some sign changes so we won't deal with them.\n\"\"\"\n\n# ====== Solution ======\n\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b \/\/ a) * y, y)\n\n\ndef inverseMod(a, m):\n","entry_point":"inverseMod","test":"def check(candidate):\n    assert candidate(2,5) == 3\n    assert candidate(48,101) == 40\n    assert candidate(7,733) == 419\n    assert candidate(48,733) == 168\n    assert candidate(2,733) == 367\n    assert candidate(229,101) == 15\n    assert candidate(229,103) == 9\n    assert candidate(229,105) == 94\n    assert candidate(5,5) == None\n    assert candidate(61965,17408) == None\n    assert candidate(101014,125445) == 7969\n    assert candidate(156435434,3543432125) == 1056765589\n\n","canonical_solution":"def egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, y, x = egcd(b % a, a)\n        return (g, x - (b \/\/ a) * y, y)\n\n\ndef inverseMod(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        return None\n    else:\n        return x % m\n    \n\n"}
{"task_id":2731,"prompt":"\"\"\"\n=====Problem statement====\n\n###Instructions\n\nWrite a function that takes a negative or positive integer, which represents the number of minutes before (-) or after (+) Sunday midnight, and returns the current day of the week and the current time in 24hr format ('hh:mm') as a string. \n\n```python\nday_and_time(0)       should return 'Sunday 00:00'\nday_and_time(-3)      should return 'Saturday 23:57'\nday_and_time(45)      should return 'Sunday 00:45'\nday_and_time(759)     should return 'Sunday 12:39'\nday_and_time(1236)    should return 'Sunday 20:36'\nday_and_time(1447)    should return 'Monday 00:07'\nday_and_time(7832)    should return 'Friday 10:32'\nday_and_time(18876)   should return 'Saturday 02:36'\nday_and_time(259180)  should return 'Thursday 23:40' \nday_and_time(-349000) should return 'Tuesday 15:20'\n```\n\"\"\"\n\n# ====== Solution ======\n\nfrom datetime import timedelta, datetime\ndef day_and_time(mins):\n","entry_point":"day_and_time","test":"def check(candidate):\n    assert candidate(0) == 'Sunday 00:00'\n    assert candidate(-3) == 'Saturday 23:57'\n    assert candidate(45) == 'Sunday 00:45'\n    assert candidate(759) == 'Sunday 12:39'\n    assert candidate(1236) == 'Sunday 20:36'\n    assert candidate(1447) == 'Monday 00:07'\n    assert candidate(7832) == 'Friday 10:32'\n    assert candidate(18876) == 'Saturday 02:36'\n    assert candidate(259180) == 'Thursday 23:40'\n    assert candidate(-349000) == 'Tuesday 15:20'\n\n","canonical_solution":"from datetime import timedelta, datetime\ndef day_and_time(mins):\n    return \"{:%A %H:%M}\".format(datetime(2017, 1, 1) + timedelta(minutes = mins))"}
{"task_id":2733,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a string of words (x), you need to return an array of the words, sorted alphabetically by the final character in each.\n\nIf two words have the same last letter, they returned array should show them in the order they appeared in the given string.\n\nAll inputs will be valid.\n\"\"\"\n\n# ====== Solution ======\n\ndef last(s):\n","entry_point":"last","test":"def check(candidate):\n    assert candidate('man i need a taxi up to ubud') == ['a', 'need', 'ubud', 'i', 'taxi', 'man', 'to', 'up']\n    assert candidate('what time are we climbing up the volcano') == ['time', 'are', 'we', 'the', 'climbing', 'volcano', 'up', 'what']\n    assert candidate('take me to semynak') == ['take', 'me', 'semynak', 'to']\n    assert candidate('massage yes massage yes massage') == ['massage', 'massage', 'massage', 'yes', 'yes']\n    assert candidate('take bintang and a dance please') == ['a', 'and', 'take', 'dance', 'please', 'bintang']\n\n","canonical_solution":"def last(s):\n    return sorted(s.split(), key=lambda x: x[-1])"}
{"task_id":2746,"prompt":"\"\"\"\n=====Problem statement====\n\nCheck if it is a vowel(a, e, i, o, u,) on the ```n``` position in a string (the first argument). Don't forget about uppercase.\n\nA few cases:\n\n```\n{\ncheckVowel('cat', 1)  ->   true \/\/ 'a' is a vowel\ncheckVowel('cat', 0)  ->   false \/\/ 'c' is not a vowel\ncheckVowel('cat', 4)  ->   false \/\/ this position doesn't exist\n}\n```\nP.S. If n < 0, return false\n\"\"\"\n\n# ====== Solution ======\n\ndef check_vowel(s,i):\n","entry_point":"check_vowel","test":"def check(candidate):\n    assert candidate('cat',1) == True\n    assert candidate('cat',0) == False\n    assert candidate('cat',4) == False\n    assert candidate('Amanda',-2) == False\n    assert candidate('Amanda',0) == True\n    assert candidate('Amanda',2) == True\n\n","canonical_solution":"def check_vowel(s,i):\n    return 0 <= i < len(s) and s[i] in \"aieouAEIOU\""}
{"task_id":2755,"prompt":"\"\"\"\n=====Problem statement====\n\nReturn a new array consisting of elements which are multiple of their own index in input array (length > 1).\n\nSome cases: \n\n```\n[22, -6, 32, 82, 9, 25] =>  [-6, 32, 25]\n\n[68, -1, 1, -7, 10, 10] => [-1, 10]\n\n[-56,-85,72,-26,-14,76,-27,72,35,-21,-67,87,0,21,59,27,-92,68] => [-85, 72, 0, 68]\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef multiple_of_index(l):\n","entry_point":"multiple_of_index","test":"def check(candidate):\n    assert candidate([22, -6, 32, 82, 9, 25]) == [-6, 32, 25]\n    assert candidate([68, -1, 1, -7, 10, 10]) == [-1, 10]\n    assert candidate([11, -11]) == [-11]\n    assert candidate([-56, -85, 72, -26, -14, 76, -27, 72, 35, -21, -67, 87, 0, 21, 59, 27, -92, 68]) == [-85, 72, 0, 68]\n    assert candidate([28, 38, -44, -99, -13, -54, 77, -51]) == [38, -44, -99]\n    assert candidate([-1, -49, -1, 67, 8, -60, 39, 35]) == [-49, 8, -60, 35]\n\n","canonical_solution":"def multiple_of_index(l):\n    return [l[i] for i in range(1, len(l)) if l[i] % i == 0]"}
{"task_id":2756,"prompt":"\"\"\"\n=====Problem statement====\n\nThe number `1035` is the smallest integer that exhibits a non frequent property: one its multiples, `3105 = 1035 * 3`, has its same digits but in different order, in other words, `3105`, is one of the permutations of `1035`.\n\nThe number `125874` is the first integer that has this property when the multiplier is `2`, thus: `125874 * 2 = 251748`\n\nMake the function `search_permMult()`, that receives an upper bound, nMax and a factor k and will output the amount of pairs bellow nMax that are permuted when an integer of this range is multiplied by `k`. The pair will be counted if the multiple is less than `nMax`, too\n\nLet'see some cases:\n```python\nsearch_permMult(10000, 7) === 1 # because we have the pair 1359, 9513\nsearch_permMult(5000, 7) === 0 # no pairs found, as 9513 > 5000\n\nsearch_permMult(10000, 4) === 2 # we have two pairs (1782, 7128) and (2178, 8712)\nsearch_permMult(8000, 4) === 1 # only the pair (1782, 7128) \n\nsearch_permMult(5000, 3) === 1 # only the pair (1035, 3105)\nsearch_permMult(10000, 3) === 2 # found pairs (1035, 3105) and (2475, 7425)\n```\nFeatures of the random Tests:\n```\n10000 <= nMax <= 100000\n3 <= k <= 7\n```\nEnjoy it and happy coding!!\n\"\"\"\n\n# ====== Solution ======\n\nfrom bisect import bisect\n\nmemo = {3: [3105, 7425, 30105, 31050, 37125, 42741, 44172, 71253, 72441, 74142, 74250, 74628, 74925, 82755, 85725],\n        4: [7128, 8712, 67128, 70416, 71208, 71280, 71328, 71928, 72108, 78912, 79128, 80712, 86712, 87120, 87132, 87192, 87912, 95832],\n        5: [],\n        6: [8316, 83160, 83916, 84510, 89154, 91152],\n        7: [9513, 81816, 83181, 90321, 91203, 93513, 94143, 95130, 95193, 95613]}\n\ndef search_permMult(nMax, k):\n","entry_point":"search_permMult","test":"def check(candidate):\n    assert candidate(10000,7) == 1\n    assert candidate(5000,7) == 0\n    assert candidate(10000,4) == 2\n    assert candidate(8000,4) == 1\n    assert candidate(5000,3) == 1\n    assert candidate(10000,3) == 2\n\n","canonical_solution":"from bisect import bisect\n\nmemo = {3: [3105, 7425, 30105, 31050, 37125, 42741, 44172, 71253, 72441, 74142, 74250, 74628, 74925, 82755, 85725],\n        4: [7128, 8712, 67128, 70416, 71208, 71280, 71328, 71928, 72108, 78912, 79128, 80712, 86712, 87120, 87132, 87192, 87912, 95832],\n        5: [],\n        6: [8316, 83160, 83916, 84510, 89154, 91152],\n        7: [9513, 81816, 83181, 90321, 91203, 93513, 94143, 95130, 95193, 95613]}\n\ndef search_permMult(nMax, k):\n    return bisect(memo[k], nMax)"}
{"task_id":2757,"prompt":"\"\"\"\n=====Problem statement====\n\nYour users passwords were all stole in the Yahoo! hack, and it turns out they have been lax in creating secure passwords.  Create a function that checks their new password (passed as a string) to make sure it meets the following requirements:\n\n\nBetween 8 - 20 characters\n\nContains only the following characters: (and at least one character from each category): uppercase letters, lowercase letters, digits, and the special characters !@#$%^&*?\n\n\n\n\nReturn \"valid\" if passed or else \"not valid\"\n\"\"\"\n\n# ====== Solution ======\n\nimport re;\ndef check_password(s):\n","entry_point":"check_password","test":"def check(candidate):\n    assert candidate('') == 'not valid'\n    assert candidate('password') == 'not valid'\n    assert candidate('P1@p') == 'not valid'\n    assert candidate('P1@pP1@p') == 'valid'\n    assert candidate('P1@pP1@pP1@pP1@pP1@pP1@p') == 'not valid'\n\n","canonical_solution":"import re;\ndef check_password(s):\n    if re.search('^(?=.*?[a-z])(?=.*?[A-Z])(?=.*?\\d)(?=.*?[!@#$%^&*?])[a-zA-Z\\d!@#$%^&*?]{8,20}$', s) :\n        return 'valid'\n    else:\n        return 'not valid'"}
{"task_id":2761,"prompt":"\"\"\"\n=====Problem statement====\n\nFind the length between 2 co-ordinates.  The co-ordinates are made of integers between -20 and 20 and will be given in the form of a 2D array:\n\n(0,0) and (5,-7) would be [ [ 0 , 0 ] , [ 5, -7 ] ]\n\nThe function must return the answer rounded to 2 decimal places in the form of a string.\n\n```python\nlength_of_line([[0, 0], [5, -7]]) => \"8.60\"\n```\n\nIf the 2 given co-ordinates are the same, the returned length should be \"0.00\"\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import sqrt\ndef length_of_line(array):\n","entry_point":"length_of_line","test":"def check(candidate):\n    assert candidate([[0, 0], [1, 1]]) == '1.41'\n    assert candidate([[0, 0], [-5, -6]]) == '7.81'\n    assert candidate([[0, 0], [10, 15]]) == '18.03'\n    assert candidate([[0, 0], [5, 1]]) == '5.10'\n    assert candidate([[0, 0], [5, 4]]) == '6.40'\n    assert candidate([[0, 0], [-7, 4]]) == '8.06'\n    assert candidate([[0, 0], [0, 0]]) == '0.00'\n    assert candidate([[-3, 4], [10, 5]]) == '13.04'\n\n","canonical_solution":"from math import sqrt\ndef length_of_line(array):\n   x1, y1, x2, y2 = array[0][0], array[0][1], array[1][0], array[1][1]\n   return '{:.2f}'.format((sqrt((x2-x1)**2 + (y2-y1)**2)))"}
{"task_id":2764,"prompt":"\"\"\"\n=====Problem statement====\n\nWe are interested in collecting the triples of positive integers ```(a, b, c)``` that fulfill the following equation:\n```python\na\u00b2 + b\u00b2 = c\u00b3\n```\nThe first triple with the lowest values that satisfies the equation we have above is (2, 2 ,2).\nIn effect:\n```python\n2\u00b2 + 2\u00b2 = 2\u00b3\n4  + 4  = 8\n```\nThe first pair of triples that \"shares\" the same value of ```c``` is: ```(2, 11, 5)``` and ```(5, 10, 5)```. \n\nBoth triples share the same value of ```c```  is ```c = 5```. \n```python\nTriple (2, 11, 5)                  Triple(5, 10, 5)\n2\u00b2 + 11\u00b2 =  5\u00b3                      5\u00b2 +  10\u00b2  =  5\u00b3\n4  + 121 = 125                     25  + 100   = 125\n```\nSo, we say that the value ```c``` has two solutions because there are two triples sharing the same value of ```c```.\n\nThere are some values of ```c``` with no solutions.\n\nThe first value of ```c``` that have a surprising number of solutions is ```65``` with ```8``` different triples.\n\nIn order to avoid duplications you will consider that ```a <= b``` always.\n\nMake the function ```find_abc_sumsqcube()```, that may give us the values of c for an specific number of solutions.\n\nFor that purpose the above required function will receive two arguments, ```c_max``` and ```num_sol```. It is understandable that ```c_max``` will give to our function the upper limit of ```c``` and ```num_sol```, the specific number of solutions.\n\nThe function will output a sorted list with the values of ```c``` that have a number of solutions equals to ```num_sol```\n\nLet's see some cases: \n```python\nfind_abc_sumsqcube(5, 1) == [2] # below or equal to c_max = 5 we have triple the (2, 2, 2) (see above)\n\nfind_abc_sumsqcube(5, 2) == [5] # now we want the values of ```c \u2264 c_max``` with two solutions (see above again)\n\nfind_abc_sumsqcube(10, 2) == [5, 10]\n\nfind_abc_sumsqcube(20, 8) == [] # There are no values of c equal and bellow 20 having 8 solutions.\n```\n\nOur tests will have the following ranges for our two arguments:\n```python\n5 \u2264 c_max \u2264 1000\n1 \u2264 num_sol \u2264 10\n```\nHappy coding!!\n\"\"\"\n\n# ====== Solution ======\n\ndic1 = {1: [2, 8, 18, 32, 72, 98, 128, 162, 242, 288, 392, 512, 648, 722, 882, 968], \n 2: [5, 10, 13, 17, 20, 26, 29, 34, 37, 40, 41, 45, 52, 53, 58, 61, 68, 73, 74, 80, 82, 89, 90, 97, 101, 104, 106, 109, 113, 116, 117, 122, 136, 137, 146, 148, 149, 153, 157, 160, 164, 173, 178, 180, 181, 193, 194, 197, 202, 208, 212, 218, 226, 229, 232, 233, 234, 241, 244, 245, 257, 261, 269, 272, 274, 277, 281, 292, 293, 296, 298, 306, 313, 314, 317, 320, 328, 333, 337, 346, 349, 353, 356, 360, 362, 369, 373, 386, 388, 389, 394, 397, 401, 404, 405, 409, 416, 421, 424, 433, 436, 449, 452, 457, 458, 461, 464, 466, 468, 477, 482, 488, 490, 509, 514, 521, 522, 538, 541, 544, 548, 549, 554, 557, 562, 569, 577, 584, 586, 592, 593, 596, 601, 605, 612, 613, 617, 626, 628, 634, 637, 640, 641, 653, 656, 657, 661, 666, 673, 674, 677, 692, 698, 701, 706, 709, 712, 720, 724, 733, 738, 746, 757, 761, 769, 772, 773, 776, 778, 788, 794, 797, 801, 802, 808, 809, 810, 818, 821, 829, 832, 833, 842, 848, 853, 857, 866, 872, 873, 877, 881, 898, 904, 909, 914, 916, 922, 928, 929, 932, 936, 937, 941, 953, 954, 964, 976, 977, 980, 981, 997], \n 3: [25, 100, 169, 225, 289, 400, 676, 841, 900], \n 4: [50, 200, 338, 450, 578, 800], \n 8: [65, 85, 130, 145, 170, 185, 205, 221, 260, 265, 290, 305, 340, 365, 370, 377, 410, 442, 445, 481, 485, 493, 505, 520, 530, 533, 545, 565, 580, 585, 610, 629, 680, 685, 689, 697, 730, 740, 745, 754, 765, 785, 793, 820, 865, 884, 890, 901, 905, 949, 962, 965, 970, 985, 986], \n 5: [125, 250, 500, 1000], 14: [325, 425, 650, 725, 845, 850, 925], 6: [625]}\n\nimport bisect\ndef find_abc_sumsqcube(c_max, num_sol):\n","entry_point":"find_abc_sumsqcube","test":"def check(candidate):\n    assert candidate(5,1) == [2]\n    assert candidate(5,2) == [5]\n    assert candidate(10,2) == [5, 10]\n    assert candidate(20,8) == []\n    assert candidate(100,8) == [65, 85]\n    assert candidate(100,3) == [25, 100]\n    assert candidate(100,2) == [5, 10, 13, 17, 20, 26, 29, 34, 37, 40, 41, 45, 52, 53, 58, 61, 68, 73, 74, 80, 82, 89, 90, 97]\n\n","canonical_solution":"dic1 = {1: [2, 8, 18, 32, 72, 98, 128, 162, 242, 288, 392, 512, 648, 722, 882, 968], \n 2: [5, 10, 13, 17, 20, 26, 29, 34, 37, 40, 41, 45, 52, 53, 58, 61, 68, 73, 74, 80, 82, 89, 90, 97, 101, 104, 106, 109, 113, 116, 117, 122, 136, 137, 146, 148, 149, 153, 157, 160, 164, 173, 178, 180, 181, 193, 194, 197, 202, 208, 212, 218, 226, 229, 232, 233, 234, 241, 244, 245, 257, 261, 269, 272, 274, 277, 281, 292, 293, 296, 298, 306, 313, 314, 317, 320, 328, 333, 337, 346, 349, 353, 356, 360, 362, 369, 373, 386, 388, 389, 394, 397, 401, 404, 405, 409, 416, 421, 424, 433, 436, 449, 452, 457, 458, 461, 464, 466, 468, 477, 482, 488, 490, 509, 514, 521, 522, 538, 541, 544, 548, 549, 554, 557, 562, 569, 577, 584, 586, 592, 593, 596, 601, 605, 612, 613, 617, 626, 628, 634, 637, 640, 641, 653, 656, 657, 661, 666, 673, 674, 677, 692, 698, 701, 706, 709, 712, 720, 724, 733, 738, 746, 757, 761, 769, 772, 773, 776, 778, 788, 794, 797, 801, 802, 808, 809, 810, 818, 821, 829, 832, 833, 842, 848, 853, 857, 866, 872, 873, 877, 881, 898, 904, 909, 914, 916, 922, 928, 929, 932, 936, 937, 941, 953, 954, 964, 976, 977, 980, 981, 997], \n 3: [25, 100, 169, 225, 289, 400, 676, 841, 900], \n 4: [50, 200, 338, 450, 578, 800], \n 8: [65, 85, 130, 145, 170, 185, 205, 221, 260, 265, 290, 305, 340, 365, 370, 377, 410, 442, 445, 481, 485, 493, 505, 520, 530, 533, 545, 565, 580, 585, 610, 629, 680, 685, 689, 697, 730, 740, 745, 754, 765, 785, 793, 820, 865, 884, 890, 901, 905, 949, 962, 965, 970, 985, 986], \n 5: [125, 250, 500, 1000], 14: [325, 425, 650, 725, 845, 850, 925], 6: [625]}\n\nimport bisect\ndef find_abc_sumsqcube(c_max, num_sol):\n    if num_sol not in dic1.keys():\n        return []\n    lst = dic1[num_sol]\n    idx = bisect.bisect_right(lst, c_max)\n    return lst[:idx]"}
{"task_id":2766,"prompt":"\"\"\"\n=====Problem statement====\n\nThe number `198` has the property that `198 = 11 + 99 + 88, i.e., if each of its digits is concatenated twice and then summed, the result will be the original number`. It turns out that `198` is the only number with this property. However, the property can be generalized so that each digit is concatenated `n` times and then summed. \n\neg:-\n```\noriginal number =2997 , n=3\n2997 = 222+999+999+777 and here each digit is concatenated three times.\n\noriginal number=-2997 , n=3\n\n-2997 = -222-999-999-777 and here each digit is concatenated three times.\n\n\n```\nWrite afunction named `check_concatenated_sum` that tests if a number has this generalized property.\n\"\"\"\n\n# ====== Solution ======\n\ndef check_concatenated_sum(n, r):\n","entry_point":"check_concatenated_sum","test":"def check(candidate):\n    assert candidate(2997,3) == True\n    assert candidate(-198,2) == True\n    assert candidate(-13332,4) == True\n    assert candidate(-9,1) == True\n    assert candidate(198,0) == False\n    assert candidate(123,2) == False\n    assert candidate(123456789,2) == False\n\n","canonical_solution":"def check_concatenated_sum(n, r):\n    return abs(n) == sum(int(e*r) for e in str(abs(n)) if r) "}
{"task_id":2771,"prompt":"\"\"\"\n=====Problem statement====\n\nHofstadter sequences are a family of related integer sequences, among which the first ones were described by an American professor Douglas Hofstadter in his book G\u00f6del, Escher, Bach. \n\n### Task\nToday we will be implementing the rather chaotic recursive sequence of integers called Hofstadter Q.\nThe Hofstadter Q is defined as:\n\nAs the author states in the aforementioned book:It is reminiscent of the Fibonacci definition in that each new value is a sum of two\nprevious values-but not of the immediately previous two values. Instead, the two\nimmediately previous values tell how far to count back to obtain the numbers to be added\nto make the new value.\nThe function produces the starting sequence:  \n`1, 1, 2, 3, 3, 4, 5, 5, 6 . . .`  \nTest info: 100 random tests, n is always positive\nGood luck!\n\"\"\"\n\n# ====== Solution ======\n\ndef hofstadter_Q(n):\n","entry_point":"hofstadter_Q","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(3) == 2\n    assert candidate(7) == 5\n    assert candidate(10) == 6\n    assert candidate(100) == 56\n    assert candidate(1000) == 502\n\n","canonical_solution":"def hofstadter_Q(n):\n    try:\n        return hofstadter_Q.seq[n]\n    except IndexError:\n        ans = hofstadter_Q(n - hofstadter_Q(n - 1)) + hofstadter_Q(n - hofstadter_Q(n - 2))\n        hofstadter_Q.seq.append(ans)\n        return ans\nhofstadter_Q.seq = [None, 1, 1]"}
{"task_id":2772,"prompt":"\"\"\"\n=====Problem statement====\n\nIt's 3AM and you get the dreaded call from a customer: the program your company sold them is hanging. You eventually trace the problem down to a call to a function named `mystery`. Usually, `mystery` works fine and produces an integer result for an integer input. However, on certain inputs, the `mystery` function just locks up.\n\nUnfortunately, the `mystery` function is part of a third-party library, and you don't have access to the source code. Uck. It may take a while to get support from the provider of the library, and in the meantime, your customer is getting frustrated.\n\nYour mission, should you choose to accept it, is to create a new function called `wrap_mystery` that returns the same results as `mystery`, but does not hang. Since you're not sure exactly what values `mystery` should be returning for hangs, just have `wrap_mystery` return -1 for problematic input. Your customer is counting on you!\n\n`wrap_mystery` will only be called with positive integers less than 1,000,000.\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"wrap_mystery","test":"def check(candidate):\n    assert candidate(1) == 0\n    assert candidate(2) == 1\n    assert candidate(3) == 5\n    assert candidate(4) == 2\n    assert candidate(5) == 2\n    assert candidate(6) == 6\n    assert candidate(7) == 65\n    assert candidate(8) == 3\n    assert candidate(9) == 62\n    assert candidate(10) == 3\n    assert candidate(11) == 69\n    assert candidate(12) == 7\n    assert candidate(13) == 0\n    assert candidate(14) == 66\n    assert candidate(15) == 14\n    assert candidate(16) == 4\n    assert candidate(18) == 63\n    assert candidate(19) == 11\n    assert candidate(20) == 4\n    assert candidate(21) == 63\n    assert candidate(22) == 70\n    assert candidate(23) == 60\n    assert candidate(24) == 8\n    assert candidate(25) == 80\n    assert candidate(26) == 1\n    assert candidate(28) == 67\n    assert candidate(29) == 57\n    assert candidate(30) == 15\n    assert candidate(31) == 67\n    assert candidate(32) == 5\n    assert candidate(33) == 8\n    assert candidate(35) == 74\n    assert candidate(36) == 64\n    assert candidate(37) == 51\n    assert candidate(38) == 12\n    assert candidate(39) == 64\n    assert candidate(40) == 5\n    assert candidate(41) == 38\n    assert candidate(42) == 64\n    assert candidate(44) == 71\n    assert candidate(45) == 95\n    assert candidate(46) == 61\n    assert candidate(47) == 58\n    assert candidate(48) == 9\n    assert candidate(49) == 61\n    assert candidate(50) == 81\n    assert candidate(51) == 9\n    assert candidate(52) == 2\n    assert candidate(53) == 61\n    assert candidate(55) == 35\n    assert candidate(56) == 68\n    assert candidate(57) == 78\n    assert candidate(58) == 58\n    assert candidate(59) == 55\n    assert candidate(60) == 16\n    assert candidate(61) == 121\n    assert candidate(62) == 68\n    assert candidate(63) == 78\n    assert candidate(64) == 6\n    assert candidate(65) == 16\n    assert candidate(66) == 9\n    assert candidate(67) == 68\n    assert candidate(69) == 32\n    assert candidate(70) == 75\n    assert candidate(71) == 109\n    assert candidate(72) == 65\n    assert candidate(73) == 55\n    assert candidate(74) == 52\n    assert candidate(75) == 62\n    assert candidate(76) == 13\n    assert candidate(77) == 55\n    assert candidate(78) == 65\n    assert candidate(79) == 75\n    assert candidate(80) == 6\n    assert candidate(81) == 59\n    assert candidate(82) == 39\n    assert candidate(83) == 6\n    assert candidate(84) == 65\n    assert candidate(85) == 36\n    assert candidate(87) == 96\n    assert candidate(88) == 72\n    assert candidate(89) == 106\n    assert candidate(90) == 96\n    assert candidate(91) == 82\n    assert candidate(92) == 62\n    assert candidate(93) == 49\n    assert candidate(94) == 59\n    assert candidate(95) == 26\n    assert candidate(96) == 10\n    assert candidate(97) == 20\n    assert candidate(98) == 62\n    assert candidate(99) == 72\n    assert candidate(100) == 82\n    assert candidate(101) == 26\n    assert candidate(102) == 10\n    assert candidate(103) == 36\n    assert candidate(104) == 3\n    assert candidate(105) == 53\n    assert candidate(106) == 62\n    assert candidate(107) == 72\n    assert candidate(109) == 93\n    assert candidate(110) == 36\n    assert candidate(111) == 103\n    assert candidate(112) == 69\n    assert candidate(113) == 93\n    assert candidate(114) == 79\n    assert candidate(115) == 69\n    assert candidate(116) == 59\n    assert candidate(117) == 39\n    assert candidate(118) == 56\n    assert candidate(119) == 23\n    assert candidate(120) == 17\n    assert candidate(121) == 46\n    assert candidate(122) == 122\n    assert candidate(123) == 59\n    assert candidate(124) == 69\n    assert candidate(125) == 132\n    assert candidate(126) == 79\n    assert candidate(127) == 53\n    assert candidate(128) == 7\n    assert candidate(129) == 33\n    assert candidate(130) == 17\n    assert candidate(131) == 43\n    assert candidate(132) == 10\n    assert candidate(133) == 59\n    assert candidate(134) == 69\n    assert candidate(135) == 129\n    assert candidate(137) == 37\n    assert candidate(138) == 33\n    assert candidate(139) == 100\n    assert candidate(140) == 76\n    assert candidate(141) == 43\n    assert candidate(142) == 110\n    assert candidate(143) == 76\n    assert candidate(144) == 66\n    assert candidate(145) == 120\n    assert candidate(146) == 56\n    assert candidate(147) == 66\n    assert candidate(148) == 53\n    assert candidate(149) == 20\n    assert candidate(150) == 63\n    assert candidate(151) == 46\n    assert candidate(152) == 14\n    assert candidate(153) == 119\n    assert candidate(154) == 56\n    assert candidate(155) == 24\n    assert candidate(156) == 66\n    assert candidate(157) == 43\n    assert candidate(158) == 76\n    assert candidate(159) == 50\n    assert candidate(160) == 7\n    assert candidate(161) == 86\n    assert candidate(162) == 60\n    assert candidate(163) == 14\n    assert candidate(164) == 40\n    assert candidate(165) == 47\n    assert candidate(166) == 7\n    assert candidate(167) == 77\n    assert candidate(168) == 66\n    assert candidate(169) == 126\n    assert candidate(170) == 37\n    assert candidate(171) == 76\n    assert candidate(173) == 30\n    assert candidate(174) == 97\n    assert candidate(175) == 44\n    assert candidate(176) == 73\n    assert candidate(177) == 87\n    assert candidate(178) == 107\n    assert candidate(179) == 73\n    assert candidate(180) == 97\n    assert candidate(181) == 47\n    assert candidate(182) == 83\n    assert candidate(183) == 53\n    assert candidate(184) == 63\n    assert candidate(185) == 57\n    assert candidate(186) == 50\n    assert candidate(187) == 43\n    assert candidate(188) == 60\n    assert candidate(189) == 43\n    assert candidate(190) == 27\n    assert candidate(191) == 53\n    assert candidate(192) == 11\n    assert candidate(193) == 53\n    assert candidate(194) == 21\n    assert candidate(195) == 126\n    assert candidate(196) == 63\n    assert candidate(197) == 34\n    assert candidate(198) == 73\n    assert candidate(199) == 47\n    assert candidate(200) == 83\n    assert candidate(201) == 24\n    assert candidate(202) == 27\n    assert candidate(203) == 57\n    assert candidate(204) == 11\n    assert candidate(205) == 83\n    assert candidate(206) == 37\n    assert candidate(207) == 67\n    assert candidate(208) == 4\n    assert candidate(209) == 74\n    assert candidate(210) == 54\n    assert candidate(211) == 14\n    assert candidate(212) == 63\n    assert candidate(213) == 34\n    assert candidate(214) == 73\n    assert candidate(215) == 64\n    assert candidate(217) == 54\n    assert candidate(218) == 94\n    assert candidate(219) == 41\n    assert candidate(220) == 37\n    assert candidate(221) == 113\n    assert candidate(222) == 104\n    assert candidate(223) == 104\n    assert candidate(224) == 70\n    assert candidate(225) == 80\n    assert candidate(226) == 94\n    assert candidate(227) == 114\n    assert candidate(228) == 80\n    assert candidate(229) == 50\n    assert candidate(230) == 70\n    assert candidate(231) == 104\n    assert candidate(232) == 60\n    assert candidate(233) == 47\n    assert candidate(234) == 40\n    assert candidate(235) == 70\n    assert candidate(236) == 57\n    assert candidate(237) == 37\n    assert candidate(238) == 24\n    assert candidate(239) == 50\n    assert candidate(240) == 18\n    assert candidate(241) == 90\n    assert candidate(242) == 47\n    assert candidate(243) == 18\n    assert candidate(244) == 123\n    assert candidate(245) == 51\n    assert candidate(246) == 60\n    assert candidate(247) == 77\n    assert candidate(248) == 70\n    assert candidate(249) == 44\n    assert candidate(250) == 133\n    assert candidate(251) == 47\n    assert candidate(252) == 80\n    assert candidate(253) == 24\n    assert candidate(254) == 54\n    assert candidate(255) == 80\n    assert candidate(256) == 8\n    assert candidate(257) == 31\n    assert candidate(258) == 34\n    assert candidate(259) == 64\n    assert candidate(260) == 18\n    assert candidate(261) == 90\n    assert candidate(262) == 44\n    assert candidate(263) == 51\n    assert candidate(264) == 11\n    assert candidate(265) == 57\n    assert candidate(266) == 60\n    assert candidate(267) == 81\n    assert candidate(268) == 70\n    assert candidate(269) == 61\n    assert candidate(270) == 130\n    assert candidate(271) == 70\n    assert candidate(273) == 91\n    assert candidate(274) == 38\n    assert candidate(276) == 34\n    assert candidate(277) == 81\n    assert candidate(278) == 101\n    assert candidate(279) == 101\n    assert candidate(280) == 77\n    assert candidate(281) == 74\n    assert candidate(282) == 44\n    assert candidate(283) == 91\n    assert candidate(284) == 111\n    assert candidate(285) == 120\n    assert candidate(286) == 77\n    assert candidate(287) == 64\n    assert candidate(288) == 67\n    assert candidate(289) == 101\n    assert candidate(290) == 121\n    assert candidate(291) == 87\n    assert candidate(292) == 57\n    assert candidate(293) == 37\n    assert candidate(294) == 67\n    assert candidate(295) == 64\n    assert candidate(296) == 54\n    assert candidate(297) == 131\n    assert candidate(298) == 21\n    assert candidate(299) == 47\n    assert candidate(17) == -1\n    assert candidate(27) == -1\n    assert candidate(34) == -1\n    assert candidate(43) == -1\n    assert candidate(54) == -1\n    assert candidate(68) == -1\n    assert candidate(86) == -1\n    assert candidate(108) == -1\n    assert candidate(136) == -1\n    assert candidate(172) == -1\n    assert candidate(216) == -1\n    assert candidate(272) == -1\n    assert candidate(275) == -1\n\n","canonical_solution":"def mystery_solved(n):\n    \"\"\"\nRecreated mystery function from bytecode using the dis module.\n   How to print the bytecode: import dis\n                              print(dis.dis(mystery)) \n    Apparently,                \n    the function is a wrong implementation of the 5n+1 problem ->  \n    https:\/\/math.stackexchange.com\/questions\/14569\/the-5n1-problem\n    http:\/\/www.sciencedirect.com\/science\/article\/pii\/S0304414905001602\n    \"\"\"\n    c=0\n    while(n != 1 and n != 13 and n < 1000000): # Should have \"n != 17\" too.\n              c=c+1\n              # Without the line below the function hangs for some n > 0.\n              if(n==17): return -1\n              if (n&1): \n                     n=n+n+n+n+n+1 # n = 5n+1  \n                     continue\n              n=n>>1 # n = n\/2\n    return c\n    \ndef wrap_mystery(n): return mystery_solved(n)"}
{"task_id":2783,"prompt":"\"\"\"\n=====Problem statement====\n\n## Grade book\n\nComplete the function so that it finds the mean of the three scores passed to it and returns the letter value associated with that grade.\n\nNumerical Score    | Letter Grade\n---                | ---\n90 <= score <= 100 | 'A'\n80 <= score < 90   | 'B'\n70 <= score < 80   | 'C'\n60 <= score < 70   | 'D'\n 0 <= score < 60   | 'F'\n\nTested values are all between 0 and 100. Theres is no need to check for negative values or values greater than 100.\n\"\"\"\n\n# ====== Solution ======\n\ndef get_grade(s1, s2, s3):\n","entry_point":"get_grade","test":"def check(candidate):\n    assert candidate(95,90,93) == 'A'\n    assert candidate(100,85,96) == 'A'\n    assert candidate(92,93,94) == 'A'\n    assert candidate(100,100,100) == 'A'\n    assert candidate(70,70,100) == 'B'\n    assert candidate(82,85,87) == 'B'\n    assert candidate(84,79,85) == 'B'\n    assert candidate(70,70,70) == 'C'\n    assert candidate(75,70,79) == 'C'\n    assert candidate(60,82,76) == 'C'\n    assert candidate(65,70,59) == 'D'\n    assert candidate(66,62,68) == 'D'\n    assert candidate(58,62,70) == 'D'\n    assert candidate(44,55,52) == 'F'\n    assert candidate(48,55,52) == 'F'\n    assert candidate(58,59,60) == 'F'\n    assert candidate(0,0,0) == 'F'\n\n","canonical_solution":"def get_grade(s1, s2, s3):\n    m = (s1 + s2 + s3) \/ 3.0\n    if 90 <= m <= 100:\n        return 'A'\n    elif 80 <= m < 90:\n        return 'B'\n    elif 70 <= m < 80:\n        return 'C'\n    elif 60 <= m < 70:\n        return 'D'\n    return \"F\"\n"}
{"task_id":2789,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite function bmi that calculates body mass index (bmi = weight \/ height ^ 2).\n\n\nif bmi <= 18.5 return \"Underweight\"\n\nif bmi <= 25.0 return \"Normal\"\n\nif bmi <= 30.0 return \"Overweight\"\n\nif bmi > 30 return \"Obese\"\n\"\"\"\n\n# ====== Solution ======\n\ndef bmi(weight, height):\n","entry_point":"bmi","test":"def check(candidate):\n    assert candidate(50,1.8) == 'Underweight'\n    assert candidate(80,1.8) == 'Normal'\n    assert candidate(90,1.8) == 'Overweight'\n    assert candidate(110,1.8) == 'Obese'\n    assert candidate(50,1.5) == 'Normal'\n\n","canonical_solution":"def bmi(weight, height):\n    bmi = weight \/ height ** 2\n    if bmi <= 18.5:\n        return \"Underweight\"\n    elif bmi <= 25:\n        return \"Normal\"\n    elif bmi <= 30:\n        return \"Overweight\"\n    else:\n        return \"Obese\""}
{"task_id":2794,"prompt":"\"\"\"\n=====Problem statement====\n\nPhilip's just turned four and he wants to know how old he will be in various years in the future such as 2090 or 3044. His parents can't keep up calculating this so they've begged you to help them out by writing a programme that can answer Philip's endless questions.\n\nYour task is to write a function that takes two parameters: the year of birth and the year to count years in relation to. As Philip is getting more curious every day he may soon want to know how many years it was until he would be born, so your function needs to work with both dates in the future and in the past.\n\nProvide output in this format: For dates in the future: \"You are ... year(s) old.\" For dates in the past: \"You will be born in ... year(s).\" If the year of birth equals the year requested return: \"You were born this very year!\"\n\n\"...\" are to be replaced by the number, followed and proceeded by a single space. Mind that you need to account for both \"year\" and \"years\", depending on the result.\n\nGood Luck!\n\"\"\"\n\n# ====== Solution ======\n\ndef calculate_age(year_of_birth, current_year):\n","entry_point":"calculate_age","test":"def check(candidate):\n    assert candidate(2012,2016) == 'You are 4 years old.'\n    assert candidate(1989,2016) == 'You are 27 years old.'\n    assert candidate(2000,2090) == 'You are 90 years old.'\n    assert candidate(2000,1990) == 'You will be born in 10 years.'\n    assert candidate(2000,2000) == 'You were born this very year!'\n    assert candidate(900,2900) == 'You are 2000 years old.'\n    assert candidate(2010,1990) == 'You will be born in 20 years.'\n    assert candidate(2010,1500) == 'You will be born in 510 years.'\n    assert candidate(2011,2012) == 'You are 1 year old.'\n    assert candidate(2000,1999) == 'You will be born in 1 year.'\n\n","canonical_solution":"def calculate_age(year_of_birth, current_year):\n    diff = abs(current_year - year_of_birth)\n    plural = '' if diff == 1 else 's'\n    if year_of_birth < current_year:\n        return 'You are {} year{} old.'.format(diff, plural)\n    elif year_of_birth > current_year:\n        return 'You will be born in {} year{}.'.format(diff, plural)\n    return 'You were born this very year!'"}
{"task_id":2796,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function which answers the question \"Are you playing banjo?\".  \nIf your name starts with the letter \"R\" or lower case \"r\", you are playing banjo!\n\nThe function takes a name as its only argument, and returns one of the following strings:\n```\nname + \" plays banjo\" \nname + \" does not play banjo\"\n```\nNames given are always valid strings.\n\"\"\"\n\n# ====== Solution ======\n\ndef areYouPlayingBanjo(name):\n","entry_point":"areYouPlayingBanjo","test":"def check(candidate):\n    assert candidate('Adam') == 'Adam does not play banjo'\n    assert candidate('Paul') == 'Paul does not play banjo'\n    assert candidate('Ringo') == 'Ringo plays banjo'\n    assert candidate('bravo') == 'bravo does not play banjo'\n    assert candidate('rolf') == 'rolf plays banjo'\n\n","canonical_solution":"def areYouPlayingBanjo(name):\n    return name + (' plays' if name[0].lower() == 'r' else ' does not play') + \" banjo\";"}
{"task_id":2797,"prompt":"\"\"\"\n=====Problem statement====\n\nMobile Display Keystrokes\n\nDo you remember the old mobile display keyboards? Do you also remember how inconvenient it was to write on it?\nWell, here you have to calculate how much keystrokes you have to do for a specific word.\n\nThis is the layout:\n\n\n\nReturn the amount of keystrokes of input str (! only letters, digits and special characters in lowercase included in layout without whitespaces !)\n\ne.g:\n\n\nmobileKeyboard(\"123\") => 3 (1+1+1)\nmobileKeyboard(\"abc\") => 9 (2+3+4)\nmobileKeyboard(\"codewars\") => 26 (4+4+2+3+2+2+4+5)\n\"\"\"\n\n# ====== Solution ======\n\ndef mobile_keyboard(s):\n","entry_point":"mobile_keyboard","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('123') == 3\n    assert candidate('codewars') == 26\n    assert candidate('zruf') == 16\n    assert candidate('thisisasms') == 37\n    assert candidate('longwordwhichdontreallymakessense') == 107\n\n","canonical_solution":"def mobile_keyboard(s):\n    lookup = {\n        c: i \n        for s in \"1,2abc,3def,4ghi,5jkl,6mno,7pqrs,8tuv,9wxyz,*,0,#\".split(\",\") \n        for i, c in enumerate(s, start=1)\n    }\n    return sum(lookup[c] for c in s)"}
{"task_id":2799,"prompt":"\"\"\"\n=====Problem statement====\n\nYou're in ancient Greece and giving Philoctetes a hand in preparing a training exercise for Hercules! You've filled a pit with two different ferocious mythical creatures for Hercules to battle!\n\nThe formidable **\"Orthus\"** is a 2 headed dog with 1 tail.  The mighty **\"Hydra\"** has 5 heads and 1 tail. \n\nBefore Hercules goes in, he asks you \"How many of each beast am  I up against!?\".\n\nYou know the total number of heads and the total number of tails, that's the dangerous parts, right? But you didn't consider how many of each beast. \n\n## Task\n\nGiven the number of heads and the number of tails, work out the number of each mythical beast! \n\nThe data is given as two parameters. Your answer should be returned as an array:\n```python \n VALID ->      [24 , 15]           INVALID ->  \"No solutions\"\n```\n\nIf there aren't any cases for the given amount of heads and tails - return \"No solutions\" or null (C#).\n\"\"\"\n\n# ====== Solution ======\n\ndef beasts(heads, tails):\n","entry_point":"beasts","test":"def check(candidate):\n    assert candidate(123,39) == [24, 15]\n    assert candidate(371,88) == [23, 65]\n    assert candidate(24,12) == [12, 0]\n    assert candidate(113,37) == [24, 13]\n    assert candidate(635,181) == [90, 91]\n    assert candidate(25,555) == 'No solutions'\n    assert candidate(12,25) == 'No solutions'\n    assert candidate(54,956) == 'No solutions'\n    assert candidate(5455,54956) == 'No solutions'\n    assert candidate(0,0) == [0, 0]\n    assert candidate(-1,-1) == 'No solutions'\n    assert candidate(-45,5) == 'No solutions'\n    assert candidate(99,0) == 'No solutions'\n    assert candidate(0,99) == 'No solutions'\n    assert candidate(5,-55) == 'No solutions'\n\n","canonical_solution":"def beasts(heads, tails):\n    orthus = (5 * tails - heads) \/ 3\n    hydra = tails - orthus\n    return [orthus, hydra] if orthus >= 0 and hydra >= 0 else 'No solutions'"}
{"task_id":2813,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array of numbers (in string format), you must return a string. The numbers correspond to the letters of the alphabet in reverse order: a=26, z=1 etc. You should also account for `'!'`, `'?'` and `' '` that are represented by '27', '28' and '29' respectively.\n\nAll inputs will be valid.\n\"\"\"\n\n# ====== Solution ======\n\ndef switcher(arr):\n","entry_point":"switcher","test":"def check(candidate):\n    assert candidate(['24', '12', '23', '22', '4', '26', '9', '8']) == 'codewars'\n    assert candidate(['25', '7', '8', '4', '14', '23', '8', '25', '23', '29', '16', '16', '4']) == 'btswmdsbd kkw'\n    assert candidate(['4', '24']) == 'wc'\n    assert candidate(['12']) == 'o'\n    assert candidate(['12', '28', '25', '21', '25', '7', '11', '22', '15']) == 'o?bfbtpel'\n\n","canonical_solution":"def switcher(arr):\n    d = {str(i): chr(123-i) for i in range(1,27)}\n    d.update({'27':'!'})\n    d.update({'28':'?'})\n    d.update({'29':' '})\n    d.update({'0':''})\n    return ''.join([d[str(i)] for i in arr])"}
{"task_id":2817,"prompt":"\"\"\"\n=====Problem statement====\n\nDeoxyribonucleic acid (DNA) is a chemical found in the nucleus of cells and carries the \"instructions\" for the development and functioning of living organisms.\n\nIf you want to know more http:\/\/en.wikipedia.org\/wiki\/DNA\n\nIn DNA strings, symbols \"A\" and \"T\" are complements of each other, as \"C\" and \"G\". \nYou have function with one side of the DNA (string, except for Haskell); you need to get the other complementary side. DNA strand is never empty or there is no DNA at all (again, except for Haskell).\n\nMore similar exercise are found here http:\/\/rosalind.info\/problems\/list-view\/ (source)\n\n```python\nDNA_strand (\"ATTGC\") # return \"TAACG\"\n\nDNA_strand (\"GTAT\") # return \"CATA\"\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef DNA_strand(dna):\n","entry_point":"DNA_strand","test":"def check(candidate):\n    assert candidate('AAAA') == 'TTTT'\n    assert candidate('ATTGC') == 'TAACG'\n    assert candidate('GTAT') == 'CATA'\n    assert candidate('AAGG') == 'TTCC'\n    assert candidate('CGCG') == 'GCGC'\n    assert candidate('GTATCGATCGATCGATCGATTATATTTTCGACGAGATTTAAATATATATATATACGAGAGAATACAGATAGACAGATTA') == 'CATAGCTAGCTAGCTAGCTAATATAAAAGCTGCTCTAAATTTATATATATATATGCTCTCTTATGTCTATCTGTCTAAT'\n\n","canonical_solution":"def DNA_strand(dna):\n    pairs = [(\"A\", \"T\"), (\"C\", \"G\")]\n    replacing_rules = pairs_to_dict(pairs)\n    return \"\".join(list([replacing_rules[a] for a in dna]))\n\n\ndef pairs_to_dict(pairs):\n    d = {}\n    for pair in pairs:  # Add two replacing rules for each pair\n        d[pair[0]] = pair[1]\n        d[pair[1]] = pair[0]\n    return d\n"}
{"task_id":2827,"prompt":"\"\"\"\n=====Problem statement====\n\nWhen provided with a number between 0-9, return it in words.\n\nInput :: 1\n\nOutput :: \"One\".\n\nIf your language supports it, try using a switch statement.\n\"\"\"\n\n# ====== Solution ======\n\ndef switch_it_up(n):\n","entry_point":"switch_it_up","test":"def check(candidate):\n    assert candidate(0) == 'Zero'\n    assert candidate(1) == 'One'\n    assert candidate(2) == 'Two'\n    assert candidate(3) == 'Three'\n    assert candidate(4) == 'Four'\n    assert candidate(5) == 'Five'\n    assert candidate(6) == 'Six'\n    assert candidate(7) == 'Seven'\n    assert candidate(8) == 'Eight'\n    assert candidate(9) == 'Nine'\n\n","canonical_solution":"def switch_it_up(n):\n    return ['Zero','One','Two','Three','Four','Five','Six','Seven','Eight','Nine'][n]"}
{"task_id":2830,"prompt":"\"\"\"\n=====Problem statement====\n\nSimple enough this one - you will be given an array. The values in the array will either be numbers or strings, or a mix of both. You will not get an empty array, nor a sparse one.\n\nYour job is to return a single array that has first the numbers sorted in ascending order, followed by the strings sorted in alphabetic order. The values must maintain their original type. \n\nNote that numbers written as strings are strings and must be sorted with the other strings.\n\"\"\"\n\n# ====== Solution ======\n\ndef db_sort(arr): \n","entry_point":"db_sort","test":"def check(candidate):\n    assert candidate([6, 2, 3, 4, 5]) == [2, 3, 4, 5, 6]\n    assert candidate([14, 32, 3, 5, 5]) == [3, 5, 5, 14, 32]\n    assert candidate([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert candidate(['Banana', 'Orange', 'Apple', 'Mango', 0, 2, 2]) == [0, 2, 2, 'Apple', 'Banana', 'Mango', 'Orange']\n    assert candidate(['C', 'W', 'W', 'W', 1, 2, 0]) == [0, 1, 2, 'C', 'W', 'W', 'W']\n    assert candidate(['Hackathon', 'Katathon', 'Code', 'CodeWars', 'Laptop', 'Macbook', 'JavaScript', 1, 5, 2]) == [1, 2, 5, 'Code', 'CodeWars', 'Hackathon', 'JavaScript', 'Katathon', 'Laptop', 'Macbook']\n    assert candidate([66, 't', 101, 0, 1, 1]) == [0, 1, 1, 66, 101, 't']\n    assert candidate([78, 117, 110, 99, 104, 117, 107, 115, 4, 6, 5, 'west']) == [4, 5, 6, 78, 99, 104, 107, 110, 115, 117, 117, 'west']\n    assert candidate([101, 45, 75, 105, 99, 107, 'y', 'no', 'yes', 1, 2, 4]) == [1, 2, 4, 45, 75, 99, 101, 105, 107, 'no', 'y', 'yes']\n    assert candidate([80, 117, 115, 104, 45, 85, 112, 115, 6, 7, 2]) == [2, 6, 7, 45, 80, 85, 104, 112, 115, 115, 117]\n    assert candidate([1, 1, 1, 1, 1, 2, '1', '2', 'three', 1, 2, 3]) == [1, 1, 1, 1, 1, 1, 2, 2, 3, '1', '2', 'three']\n    assert candidate([78, 33, 22, 44, 88, 9, 6, 0, 5, 0]) == [0, 0, 5, 6, 9, 22, 33, 44, 78, 88]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 1, 2, 3]) == [1, 1, 2, 2, 3, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([82, 18, 72, 1, 11, 12, 12, 12, 12, 115, 667, 12, 2, 8, 3]) == [1, 2, 3, 8, 11, 12, 12, 12, 12, 12, 18, 72, 82, 115, 667]\n    assert candidate(['t', 'e', 's', 't', 3, 4, 1]) == [1, 3, 4, 'e', 's', 't', 't']\n    assert candidate(['what', 'a', 'great', 'kata', 1, 2, 2]) == [1, 2, 2, 'a', 'great', 'kata', 'what']\n    assert candidate([66, 'codewars', 11, 'alex loves pushups', 2, 3, 0]) == [0, 2, 3, 11, 66, 'alex loves pushups', 'codewars']\n    assert candidate(['come', 'on', 110, '2500', 10, '!', 7, 15, 5, 6, 6]) == [5, 6, 6, 7, 10, 15, 110, '!', '2500', 'come', 'on']\n    assert candidate([\"when's\", 'the', 'next', 'Katathon?', 9, 7, 0, 1, 2]) == [0, 1, 2, 7, 9, 'Katathon?', 'next', 'the', \"when's\"]\n    assert candidate([8, 7, 5, 'bored', 'of', 'writing', 'tests', 115, 6, 7, 0]) == [0, 5, 6, 7, 7, 8, 115, 'bored', 'of', 'tests', 'writing']\n    assert candidate(['anyone', 'want', 'to', 'hire', 'me?', 2, 4, 1]) == [1, 2, 4, 'anyone', 'hire', 'me?', 'to', 'want']\n\n","canonical_solution":"def db_sort(arr): \n    return sorted(arr, key=lambda x: (isinstance(x,str),x))"}
{"task_id":2834,"prompt":"\"\"\"\n=====Problem statement====\n\n\"Point reflection\" or \"point symmetry\" is a basic concept in geometry where a given point, P, at a given position relative to a mid-point, Q has a corresponding point, P1, which is the same distance from Q but in the opposite direction.\n\n## Task\n\nGiven two points P and Q, output the symmetric point of point P about Q.\nEach argument is a two-element array of integers representing the point's X and Y coordinates.  Output should be in the same format, giving the X and Y coordinates of point P1.  You do not have to validate the input.\n\nThis kata was inspired by the Hackerrank challenge [Find Point](https:\/\/www.hackerrank.com\/challenges\/find-point)\n\"\"\"\n\n# ====== Solution ======\n\ndef symmetric_point(p, q):\n","entry_point":"symmetric_point","test":"def check(candidate):\n    assert candidate([0, 0],[1, 1]) == [2, 2]\n    assert candidate([2, 6],[-2, -6]) == [-6, -18]\n    assert candidate([10, -10],[-10, 10]) == [-30, 30]\n    assert candidate([1, -35],[-12, 1]) == [-25, 37]\n    assert candidate([1000, 15],[-7, -214]) == [-1014, -443]\n    assert candidate([0, 0],[0, 0]) == [0, 0]\n\n","canonical_solution":"def symmetric_point(p, q):\n    return [2*q[0] - p[0], 2*q[1] - p[1]]"}
{"task_id":2836,"prompt":"\"\"\"\n=====Problem statement====\n\nCheesy Cheeseman just got a new monitor! He is happy with it, but he just discovered that his old desktop wallpaper no longer fits. He wants to find a new wallpaper, but does not know which size wallpaper he should be looking for, and alas, he just threw out the new monitor's box. Luckily he remembers the width and the aspect ratio of the monitor from when Bob Mortimer sold it to him. Can you help Cheesy out?\n# The Challenge\n\nGiven an integer `width` and a string `ratio` written as `WIDTH:HEIGHT`, output the screen dimensions as a string written as `WIDTHxHEIGHT`.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_screen_height(width, ratio): \n","entry_point":"find_screen_height","test":"def check(candidate):\n    assert candidate(1024,'4:3') == '1024x768'\n    assert candidate(1280,'16:9') == '1280x720'\n    assert candidate(3840,'32:9') == '3840x1080'\n    assert candidate(1600,'4:3') == '1600x1200'\n    assert candidate(1280,'5:4') == '1280x1024'\n    assert candidate(2160,'3:2') == '2160x1440'\n    assert candidate(1920,'16:9') == '1920x1080'\n    assert candidate(5120,'32:9') == '5120x1440'\n\n","canonical_solution":"def find_screen_height(width, ratio): \n    a, b = map(int, ratio.split(\":\"))\n    return f\"{width}x{int(width \/ a * b)}\""}
{"task_id":2837,"prompt":"\"\"\"\n=====Problem statement====\n\nPeter can see a clock in the mirror from the place he sits in the office.\nWhen he saw the clock shows 12:22\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nHe knows that the time is 11:38\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n\nin the same manner:\n\n05:25 --> 06:35\n\n01:50 --> 10:10\n\n11:58 --> 12:02\n\n12:01 --> 11:59\n\nPlease complete the function `WhatIsTheTime(timeInMirror)`, where `timeInMirror` is the mirrored time (what Peter sees) as string.\n\nReturn the _real_ time as a string.\n\nConsider hours to be between 1 <= hour < 13.\n\nSo there is no 00:20, instead it is 12:20.\n\nThere is no 13:20, instead it is 01:20.\n\"\"\"\n\n# ====== Solution ======\n\ndef what_is_the_time(time_in_mirror):\n","entry_point":"what_is_the_time","test":"def check(candidate):\n    assert candidate('06:35') == '05:25'\n    assert candidate('11:59') == '12:01'\n    assert candidate('12:02') == '11:58'\n    assert candidate('04:00') == '08:00'\n    assert candidate('06:00') == '06:00'\n    assert candidate('12:00') == '12:00'\n\n","canonical_solution":"def what_is_the_time(time_in_mirror):\n    h, m = map(int, time_in_mirror.split(':'))\n    return '{:02}:{:02}'.format(-(h + (m != 0)) % 12 or 12, -m % 60)"}
{"task_id":2842,"prompt":"\"\"\"\n=====Problem statement====\n\nConstruct a function 'coordinates', that will return the distance between two points on a cartesian plane, given the x and y coordinates of each point.\n\nThere are two parameters in the function, ```p1``` and ```p2```. ```p1``` is a list ```[x1,y1]``` where ```x1``` and ```y1``` are the x and y coordinates of the first point. ```p2``` is a list ```[x2,y2]``` where ```x2``` and ```y2``` are the x and y coordinates of the second point. \n\nThe distance between the two points should be rounded to the `precision` decimal if provided, otherwise to the nearest integer.\n\"\"\"\n\n# ====== Solution ======\n\ndef coordinates(p1,p2, precision = 0):\n","entry_point":"coordinates","test":"def check(candidate):\n    assert candidate([3, 6],[14, 6]) == 11\n    assert candidate([-2, 5],[-2, -10],2) == 15\n    assert candidate([1, 2],[4, 6]) == 5\n    assert candidate([5, 3],[10, 15],2) == 13\n    assert candidate([-2, -10],[6, 5]) == 17\n    assert candidate([4, 7],[6, 2],3) == 5.385\n    assert candidate([-4, -5],[-5, -4],1) == 1.4\n    assert candidate([3, 8],[3, 8]) == 0\n    assert candidate([-3, 8],[3, 8]) == 6\n    assert candidate([3, 8],[3, -8]) == 16\n\n","canonical_solution":"def coordinates(p1,p2, precision = 0):\n    return round(sum( (b-a)**2 for a,b in zip(p1,p2) )**.5, precision)"}
{"task_id":2850,"prompt":"\"\"\"\n=====Problem statement====\n\nGordon Ramsay shouts. He shouts and swears. There may be something wrong with him.\n\nAnyway, you will be given a string of four words. Your job is to turn them in to Gordon language. \n\nRules:\n\nObviously the words should be Caps,\nEvery word should end with '!!!!',\nAny letter 'a' or 'A' should become '@',\nAny other vowel should become '*'.\n\"\"\"\n\n# ====== Solution ======\n\ndef gordon(a):\n","entry_point":"gordon","test":"def check(candidate):\n    assert candidate('What feck damn cake') == 'WH@T!!!! F*CK!!!! D@MN!!!! C@K*!!!!'\n    assert candidate('are you stu pid') == '@R*!!!! Y**!!!! ST*!!!! P*D!!!!'\n    assert candidate('i am a chef') == '*!!!! @M!!!! @!!!! CH*F!!!!'\n    assert candidate('dont you talk tome') == 'D*NT!!!! Y**!!!! T@LK!!!! T*M*!!!!'\n    assert candidate('how dare you feck') == 'H*W!!!! D@R*!!!! Y**!!!! F*CK!!!!'\n\n","canonical_solution":"def gordon(a):\n    return '!!!! '.join(a.upper().split()).translate(str.maketrans('AEIOU', '@****'))+'!!!!'"}
{"task_id":2855,"prompt":"\"\"\"\n=====Problem statement====\n\nThe number 81 has a special property, a certain power of the sum of its digits is equal to 81 (nine squared). Eighty one (81), is the first number in having this property (not considering numbers of one digit). \nThe next one, is 512.\nLet's see both cases with the details\n\n8 + 1 = 9 and 9^(2) = 81\n\n512 = 5 + 1 + 2 = 8 and 8^(3) = 512\n\nWe need to make a function, ```power_sumDigTerm()```, that receives a number ```n``` and may output the ```n-th term``` of this sequence of numbers.\nThe cases we presented above means that\n\npower_sumDigTerm(1) == 81\n\npower_sumDigTerm(2) == 512\n\n\nHappy coding!\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"power_sumDigTerm","test":"def check(candidate):\n    assert candidate(1) == 81\n    assert candidate(2) == 512\n    assert candidate(3) == 2401\n    assert candidate(4) == 4913\n    assert candidate(5) == 5832\n    assert candidate(6) == 17576\n    assert candidate(7) == 19683\n\n","canonical_solution":"series = [0]\nfor a in range(2, 99):\n    for b in range(2, 42):\n        c = a**b\n        if a == sum(map(int, str(c))):\n            series.append(c)\npower_sumDigTerm = sorted(series).__getitem__"}
{"task_id":2866,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n Mobius function - an important function in number theory. For each given n, it only has 3 values:\n```\n0  -- if n divisible by square of a prime. Such as: 4, 8, 9\n1  -- if n not divisible by any square of a prime \n        and have even number of prime factor. Such as: 6, 10, 21\n-1 -- otherwise. Such as: 3, 5, 7, 30```\nYour task is to find mobius(`n`)\n\n# Input\/Output\n\n\n - `[input]` integer `n`\n\n\n `2 <= n <= 1e12`\n\n\n - `[output]` an integer\n\"\"\"\n\n# ====== Solution ======\n\ndef mobius(n):\n","entry_point":"mobius","test":"def check(candidate):\n    assert candidate(10) == 1\n    assert candidate(9) == 0\n    assert candidate(8) == 0\n    assert candidate(100000000001) == 0\n    assert candidate(7) == -1\n    assert candidate(5) == -1\n\n","canonical_solution":"def mobius(n):\n    sP, p = set(), 2\n    while n>1 and p <= n**.5:\n        while not n%p:\n            if p in sP: return 0\n            sP.add(p)\n            n \/\/= p\n        p += 1 + (p!=2)\n    return (-1)**((len(sP) + (n!= 1)) % 2)"}
{"task_id":2869,"prompt":"\"\"\"\n=====Problem statement====\n\nDefine a function that removes duplicates from an array of numbers and returns it as a result.\n\nThe order of the sequence has to stay the same.\n\"\"\"\n\n# ====== Solution ======\n\ndef distinct(seq):\n","entry_point":"distinct","test":"def check(candidate):\n    assert candidate([1]) == [1]\n    assert candidate([1, 2]) == [1, 2]\n    assert candidate([1, 1, 2]) == [1, 2]\n    assert candidate([1, 1, 1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n    assert candidate([1, 2, 2, 3, 3, 4, 4, 5, 6, 7, 7, 7]) == [1, 2, 3, 4, 5, 6, 7]\n\n","canonical_solution":"def distinct(seq):\n    return sorted(set(seq), key = seq.index)"}
{"task_id":2870,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven two arrays, the purpose of this Kata is to check if these two arrays are the same. \"The same\" in this Kata means the two arrays contains arrays of 2 numbers which are same and not necessarily sorted the same way. i.e. [[2,5], [3,6]] is same as [[5,2], [3,6]] or [[6,3], [5,2]] or [[6,3], [2,5]] etc\n\n[[2,5], [3,6]] is NOT the same as [[2,3], [5,6]]\nTwo empty arrays [] are the same\n[[2,5], [5,2]] is the same as [[2,5], [2,5]] but NOT the same as [[2,5]]\n[[2,5], [3,5], [6,2]] is the same as [[2,6], [5,3], [2,5]] or [[3,5], [6,2], [5,2]], etc\nAn array can be empty or contain a minimun of one array of 2 integers and up to 100 array of 2 integers \n\n\nNote:\n1. [[]] is not applicable because if the array of array are to contain anything, there have to be two numbers.\n2. 100 randomly generated tests that can contains either \"same\" or \"not same\" arrays.\n\"\"\"\n\n# ====== Solution ======\n\ndef same(arr_a, arr_b):\n","entry_point":"same","test":"def check(candidate):\n    assert candidate([[2, 5], [3, 6]],[[5, 2], [3, 6]]) == True\n    assert candidate([[2, 5], [3, 6]],[[6, 3], [5, 2]]) == True\n    assert candidate([[2, 5], [3, 6]],[[6, 3], [2, 5]]) == True\n    assert candidate([[2, 5], [3, 5], [6, 2]],[[2, 6], [5, 3], [2, 5]]) == True\n    assert candidate([[2, 5], [3, 5], [6, 2]],[[3, 5], [6, 2], [5, 2]]) == True\n    assert candidate([],[]) == True\n    assert candidate([[2, 3], [3, 4]],[[4, 3], [2, 4]]) == False\n    assert candidate([[2, 3], [3, 2]],[[2, 3]]) == False\n\n","canonical_solution":"def same(arr_a, arr_b):\n    return sorted(map(sorted, arr_a)) == sorted(map(sorted, arr_b))"}
{"task_id":2873,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this kata you have to correctly return who is the \"survivor\", ie: the last element of a Josephus permutation.\n\nBasically you have to assume that n people are put into a circle and that they are eliminated in steps of k elements, like this:\n\n```\njosephus_survivor(7,3) => means 7 people in a circle;\none every 3 is eliminated until one remains\n[1,2,3,4,5,6,7] - initial sequence\n[1,2,4,5,6,7] => 3 is counted out\n[1,2,4,5,7] => 6 is counted out\n[1,4,5,7] => 2 is counted out\n[1,4,5] => 7 is counted out\n[1,4] => 5 is counted out\n[4] => 1 counted out, 4 is the last element - the survivor!\n```\n\nThe above link about the \"base\" kata description will give you a more thorough insight about the origin of this kind of permutation, but basically that's all that there is to know to solve this kata.\n\n**Notes and tips:** using the solution to the other kata to check your function may be helpful, but as much larger numbers will be used, using an array\/list to compute the number of the survivor may be too slow; you may assume that both n and k will always be >=1.\n\"\"\"\n\n# ====== Solution ======\n\ndef josephus_survivor(n, k):\n","entry_point":"josephus_survivor","test":"def check(candidate):\n    assert candidate(7,3) == 4\n    assert candidate(11,19) == 10\n    assert candidate(40,3) == 28\n    assert candidate(14,2) == 13\n    assert candidate(100,1) == 100\n    assert candidate(1,300) == 1\n    assert candidate(2,300) == 1\n    assert candidate(5,300) == 1\n    assert candidate(7,300) == 7\n    assert candidate(300,300) == 265\n\n","canonical_solution":"def josephus_survivor(n, k):\n    v = 0\n    for i in range(1, n + 1): v = (v + k) % i\n    return v + 1"}
{"task_id":2879,"prompt":"\"\"\"\n=====Problem statement====\n\nThe objective is to disambiguate two given names: the original with another\n\nThis kata is slightly more evolved than the previous one: [Author Disambiguation: to the point!](https:\/\/www.codewars.com\/kata\/580a429e1cb4028481000019).\n\nThe function ```could_be``` is still given the original name and another one to test\nagainst. \n\n```python\n# should return True even with 'light' variations (more details in section below)\n> could_be(\"Chuck Norris\", u\"ch\u00fcck!\")\nTrue\n\n# should False otherwise (whatever you may personnaly think)\n> could_be(\"Chuck Norris\", \"superman\")\nFalse\n``` \n\n**Watch out**: When accents comes into the game, they will enter through **UTF-8 unicodes. **\n\nThe function should be tolerant with regards to:\n\n * upper and lower cases: ```could_be(A, a) : True```\n * accents: ```could_be(E, \u00e9) : True```\n * dots: ```could_be(E., E) : True```\n * same for other ending punctuations in [!,;:?]: ```could_be(A, A!) : True```\n\nOn the other hand, more consideration needs to be given to *composed names*...\nLet's be bold about it: if you have any, they will be considered as a whole :\n\n```python\n# We still have:\n> could_be(\"Carlos Ray Norris\", \"Carlos Ray Norris\")\nTrue\n> could_be(\"Carlos-Ray Norris\", \"Carlos-Ray Norris\")\nTrue\n\n# But:\n> could_be(\"Carlos Ray Norris\", \"Carlos-Ray Norris\")\nFalse\n> could_be(\"Carlos-Ray Norris\", \"Carlos Ray Norris\")\nFalse\n> could_be(\"Carlos-Ray Norris\", \"Carlos Ray-Norris\")\nFalse\n```\n \nAmong the valid combinaisons of the fullname \"Carlos Ray Norris\", you will find\n\n```python\ncould_be(\"Carlos Ray Norris\", \"carlos ray\") : True\ncould_be(\"Carlos Ray Norris\", \"Carlos. Ray, Norris;\") : True\ncould_be(\"Carlos Ray Norris\", u\"Carl\u00f2s! Norris\") : True\n```\n\nToo easy ? Try the next step: [Author Disambiguation: Signatures worth it](https:\/\/www.codewars.com\/kata\/author-disambiguation-signatures-worth-it)\n\"\"\"\n\n# ====== Solution ======\n\nimport re\nimport unicodedata\n\nNAME = re.compile(\"[\\w-]+\")\n\ndef decompose(name):\n    standarized = unicodedata.normalize('NFKD', name.lower()) \\\n        .encode('ascii', 'ignore') if type(name) != str \\\n        else name.lower()\n    return re.findall(NAME, standarized)\n\ndef could_be(original, another):\n","entry_point":"could_be","test":"def check(candidate):\n    assert candidate('Carlos Ray Norris','Carlos Ray Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos Ray') == True\n    assert candidate('Carlos Ray Norris','Ray Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos Norris') == True\n    assert candidate('Carlos Ray Norris','Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos') == True\n    assert candidate('Carlos Ray Norris','Norris Carlos') == True\n    assert candidate('Carlos Ray Norris','carlos ray norris') == True\n    assert candidate('Carlos Ray Norris','Norris! ?ray') == True\n    assert candidate('Carlos Ray Norris','Carlos. Ray; Norris,') == True\n    assert candidate('Carlos Ray Norris','Carlos:Ray Norris') == True\n    assert candidate('Carlos-Ray Norris','Carlos-Ray Norris:') == True\n    assert candidate('Carlos Ray-Norris','Carlos? Ray-Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos Ray Norr') == False\n    assert candidate('Carlos Ray Norris','Ra Norris') == False\n    assert candidate('','C') == False\n    assert candidate('','') == False\n    assert candidate('Carlos Ray Norris',' ') == False\n    assert candidate('Carlos-Ray Norris','Carlos Ray-Norris') == False\n    assert candidate('Carlos Ray Norris','Carlos-Ray Norris') == False\n    assert candidate('Carlos Ray Norris','Carlos Ray-Norris') == False\n    assert candidate('Carlos Ray','Carlos Ray Norris') == False\n    assert candidate('Carlos','Carlos Ray Norris') == False\n\n","canonical_solution":"import re\nimport unicodedata\n\nNAME = re.compile(\"[\\w-]+\")\n\ndef decompose(name):\n    standarized = unicodedata.normalize('NFKD', name.lower()) \\\n        .encode('ascii', 'ignore') if type(name) != str \\\n        else name.lower()\n    return re.findall(NAME, standarized)\n\ndef could_be(original, another):\n    if not another.strip(): return False\n    std_original = decompose(original)\n    std_another = decompose(another)\n    return all( name in std_original for name in std_another )"}
{"task_id":2881,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this Kata, you will implement the [Luhn Algorithm](http:\/\/en.wikipedia.org\/wiki\/Luhn_algorithm), which is used to help validate credit card numbers.\n\nGiven a positive integer of up to 16 digits, return ```true``` if it is a valid credit card number, and ```false``` if it is not.\n\nHere is the algorithm:\n  \n* Double every other digit, scanning **from right to left**, starting from the second digit (from the right).\n\n  Another way to think about it is: if there are an **even** number of digits, double every other digit starting with the **first**; if there are an **odd** number of digits, double every other digit starting with the **second**:\n\n  ```\n  1714 ==> [1*, 7, 1*, 4] ==> [2, 7, 2, 4]\n  \n  12345 ==> [1, 2*, 3, 4*, 5] ==> [1, 4, 3, 8, 5]\n  \n  891 ==> [8, 9*, 1] ==> [8, 18, 1]\n  ```\n\n*  If a resulting number is greater than `9`, replace it with the sum of its own digits (which is the same as subtracting `9` from it):\n\n  ```\n  [8, 18*, 1] ==> [8, (1+8), 1] ==> [8, 9, 1]\n  \n  or:\n  \n  [8, 18*, 1] ==> [8, (18-9), 1] ==> [8, 9, 1]\n  ```\n  \n* Sum all of the final digits:\n\n  ```\n  [8, 9, 1] ==> 8 + 9 + 1 = 18\n  ```\n\n* Finally, take that sum and divide it by `10`.  If the remainder equals zero, the original credit card number is valid.\n    ```\n    18 (modulus) 10 ==> 8 , which is not equal to 0, so this is not a valid credit card number\n    ```\n\n```if:fsharp,csharp\nFor F# and C# users:\n\nThe input will be a string of spaces and digits `0..9`\n\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef validate(n):\n","entry_point":"validate","test":"def check(candidate):\n    assert candidate(123) == False\n    assert candidate(1) == False\n    assert candidate(2121) == True\n    assert candidate(1230) == True\n    assert candidate(8675309) == False\n    assert candidate(4111111111111111) == True\n    assert candidate(26) == True\n    assert candidate(2626262626262626) == True\n    assert candidate(91) == True\n    assert candidate(92) == False\n    assert candidate(912030) == True\n    assert candidate(922030) == False\n\n","canonical_solution":"def validate(n):\n    digits = [int(x) for x in str(n)]\n    even = [x*2 if x*2 <= 9 else x*2 - 9 for x in digits[-2::-2]]\n    odd  = [x for x in digits[-1::-2]]\n    return (sum(even + odd)%10) == 0\n"}
{"task_id":2882,"prompt":"\"\"\"\n=====Problem statement====\n\nImagine a triangle of numbers which follows this pattern:\n\n * Starting with the number \"1\", \"1\" is positioned at the top of the triangle. As this is the 1st row, it can only support a single number.\n * The 2nd row can support the next 2 numbers: \"2\" and \"3\"\n * Likewise, the 3rd row, can only support the next 3 numbers: \"4\", \"5\", \"6\"\n * And so on; this pattern continues.\n\n```\n    1\n   2 3\n  4 5 6\n 7 8 9 10\n...\n```\n\nGiven N, return the sum of all numbers on the Nth Row:\n\n1 <= N <= 10,000\n\"\"\"\n\n# ====== Solution ======\n\ndef cumulative_triangle(n):\n","entry_point":"cumulative_triangle","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 5\n    assert candidate(3) == 15\n    assert candidate(4) == 34\n    assert candidate(15) == 1695\n    assert candidate(150) == 1687575\n    assert candidate(100) == 500050\n    assert candidate(500) == 62500250\n    assert candidate(1000) == 500000500\n    assert candidate(10000) == 500000005000\n\n","canonical_solution":"def cumulative_triangle(n):\n    return n*(n*n+1)\/2"}
{"task_id":2896,"prompt":"\"\"\"\n=====Problem statement====\n\nA carpet shop sells carpets in different varieties. Each carpet can come in a different roll width and can have a different price per square meter. \n\nWrite a function `cost_of_carpet` which calculates the cost (rounded to 2 decimal places) of carpeting a room, following these constraints:\n\n* The carpeting has to be done in one unique piece. If not possible, retrun `\"error\"`.\n* The shop sells any length of a roll of carpets, but always with a full width.\n* The cost has to be minimal.\n* The length of the room passed as argument can sometimes be shorter than its width (because we define these relatively to the position of the door in the room).\n* A length or width equal to zero is considered invalid, return `\"error\"` if it occurs.\n\n\nINPUTS:\n\n`room_width`, `room_length`, `roll_width`, `roll_cost` as floats.\n\nOUTPUT:\n\n`\"error\"` or the minimal cost of the room carpeting, rounded to two decimal places.\n\"\"\"\n\n# ====== Solution ======\n\ndef cost_of_carpet(room_length, room_width, roll_width, roll_cost):\n","entry_point":"cost_of_carpet","test":"def check(candidate):\n    assert candidate(3,5,4,10) == 200\n    assert candidate(4,5,4,10) == 200\n    assert candidate(0,0,4,10) == 'error'\n    assert candidate(3,2,4,10) == 80\n    assert candidate(3.9,2,4,10) == 80\n    assert candidate(5,6,4,10) == 'error'\n    assert candidate(3,2,4,0) == 0\n    assert candidate(3,2,2,10) == 60\n\n","canonical_solution":"def cost_of_carpet(room_length, room_width, roll_width, roll_cost):\n    x, y = sorted((room_length, room_width))\n    if y == 0 or x > roll_width: return \"error\"\n    if y < roll_width: return round(x * roll_width * roll_cost, 2)\n    return round(y * roll_width * roll_cost, 2)"}
{"task_id":2898,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are given two arrays `arr1` and `arr2`, where `arr2` always contains integers.\n\nWrite the function `find_array(arr1, arr2)` such that:\n\nFor `arr1 = ['a', 'a', 'a', 'a', 'a']`, `arr2 = [2, 4]`\n`find_array returns ['a', 'a']`\n\nFor `arr1 = [0, 1, 5, 2, 1, 8, 9, 1, 5]`, `arr2 = [1, 4, 7]`\n`find_array returns [1, 1, 1]`\n\nFor `arr1 = [0, 3, 4]`, `arr2 = [2, 6]`\n`find_array returns [4]`\n\nFor `arr1=[\"a\",\"b\",\"c\",\"d\"]` , `arr2=[2,2,2]`,\n`find_array returns [\"c\",\"c\",\"c\"]`\n\nFor `arr1=[\"a\",\"b\",\"c\",\"d\"]`, `arr2=[3,0,2]`\n`find_array returns [\"d\",\"a\",\"c\"]`\n\nIf either `arr1` or `arr2` is empty, you should return an empty arr (empty list in python,\nempty vector in c++). Note for c++ use std::vector arr1, arr2.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_array(arr1, arr2):\n","entry_point":"find_array","test":"def check(candidate):\n    assert candidate(['a', 'a', 'a', 'a', 'a'],[2, 4]) == ['a', 'a']\n    assert candidate([0, 1, 5, 2, 1, 8, 9, 1, 5],[1, 4, 7]) == [1, 1, 1]\n    assert candidate([1, 2, 3, 4, 5],[0]) == [1]\n    assert candidate(['this', 'is', 'test'],[0, 1, 2]) == ['this', 'is', 'test']\n    assert candidate([0, 3, 4],[2, 6]) == [4]\n    assert candidate([1],[]) == []\n    assert candidate([],[2]) == []\n    assert candidate([],[]) == []\n\n","canonical_solution":"def find_array(arr1, arr2):\n    return [ arr1[i] for i in arr2 if i< len(arr1) ]"}
{"task_id":2905,"prompt":"\"\"\"\n=====Problem statement====\n\nNickname Generator\n\nWrite a function, `nicknameGenerator` that takes a string name as an argument and returns the first 3 or 4 letters as a nickname.\n\nIf the 3rd letter is a consonant, return the first 3 letters.\n\nIf the 3rd letter is a vowel, return the first 4 letters. \n\nIf the string is less than 4 characters, return \"Error: Name too short\".\n\n**Notes:**\n\n- Vowels are \"aeiou\", so discount the letter \"y\".\n- Input will always be a string.\n- Input will always have the first letter capitalised and the rest lowercase (e.g. Sam).\n- The input can be modified\n\"\"\"\n\n# ====== Solution ======\n\ndef nickname_generator(name):\n","entry_point":"nickname_generator","test":"def check(candidate):\n    assert candidate('Jimmy') == 'Jim'\n    assert candidate('Samantha') == 'Sam'\n    assert candidate('Sam') == 'Error: Name too short'\n    assert candidate('Kayne') == 'Kay'\n    assert candidate('Melissa') == 'Mel'\n    assert candidate('James') == 'Jam'\n    assert candidate('Gregory') == 'Greg'\n    assert candidate('Jeannie') == 'Jean'\n    assert candidate('Kimberly') == 'Kim'\n    assert candidate('Timothy') == 'Tim'\n    assert candidate('Dani') == 'Dan'\n    assert candidate('Saamy') == 'Saam'\n    assert candidate('Saemy') == 'Saem'\n    assert candidate('Saimy') == 'Saim'\n    assert candidate('Saomy') == 'Saom'\n    assert candidate('Saumy') == 'Saum'\n    assert candidate('Boyna') == 'Boy'\n    assert candidate('Kiyna') == 'Kiy'\n    assert candidate('Sayma') == 'Say'\n    assert candidate('Ni') == 'Error: Name too short'\n    assert candidate('Jam') == 'Error: Name too short'\n    assert candidate('Suv') == 'Error: Name too short'\n\n","canonical_solution":"def nickname_generator(name):\n    return \"Error: Name too short\" if len(name) < 4 else name[:3+(name[2] in \"aeiuo\")]"}
{"task_id":2906,"prompt":"\"\"\"\n=====Problem statement====\n\nAt the start of each season, every player in a football team is assigned their own unique squad number. Due to superstition or their history certain numbers are more desirable than others.\n\nWrite a function generateNumber() that takes two arguments, an array of the current squad numbers (squad) and the new player's desired number (n). If the new player's desired number is not already taken, return n, else if the desired number can be formed by adding two digits between 1 and 9, return the number formed by joining these two digits together. E.g. If 2 is taken, return 11 because 1 + 1 = 2. Otherwise return null. \n\nNote: Often there will be several different ways to form a replacement number. In these cases the number with lowest first digit should be given priority. E.g. If n = 15, but squad already contains 15, return 69, not 78.\n\"\"\"\n\n# ====== Solution ======\n\ndef generate_number(squad, n):\n","entry_point":"generate_number","test":"def check(candidate):\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 15, 69],11) == 11\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 69],11) == 29\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 29, 69],11) == 38\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 29, 38, 47, 56, 65, 69, 74, 83, 92],11) == None\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 18, 23, 69],18) == 99\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 15, 69],34) == 34\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 29, 34, 38, 47, 56, 65, 69, 74, 83, 92],34) == None\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 18, 27, 29, 34, 36, 38, 45, 47, 54, 56, 63, 65, 69, 72, 74, 81, 83, 92],9) == None\n    assert candidate([1, 2, 3, 4, 6, 9, 10, 11, 15, 18, 27, 29, 34, 36, 38, 45, 47, 54, 56, 63, 65, 69, 72, 74, 81, 83, 90, 92],9) == None\n\n","canonical_solution":"def generate_number(squad, n):\n    if n not in squad: return n\n    for i in range(1, 10):\n        for j in range(1, 10):\n            if i + j == n and i * 10 + j not in squad:\n                return i * 10 + j"}
{"task_id":2914,"prompt":"\"\"\"\n=====Problem statement====\n\nYour goal in this kata is to implement a difference function, which subtracts one list from another and returns the result.\n\nIt should remove all values from list `a`, which are present in list `b`.\n\n```python\narray_diff([1,2],[1]) == [2]\n```\n\nIf a value is present in `b`, all of its occurrences must be removed from the other:\n\n```python\narray_diff([1,2,2,2,3],[2]) == [1,3]\n```\n~~~ if:c\nNOTE: In C, assign return array length to pointer *z\n~~~\n\"\"\"\n\n# ====== Solution ======\n\ndef array_diff(a, b):\n","entry_point":"array_diff","test":"def check(candidate):\n    assert candidate([1, 2],[1]) == [2]\n    assert candidate([1, 2, 2],[1]) == [2, 2]\n    assert candidate([1, 2, 2],[2]) == [1]\n    assert candidate([1, 2, 2],[]) == [1, 2, 2]\n    assert candidate([],[1, 2]) == []\n\n","canonical_solution":"def array_diff(a, b):\n    return [x for x in a if x not in b]"}
{"task_id":2927,"prompt":"\"\"\"\n=====Problem statement====\n\nI'm afraid you're in a rather unfortunate situation. You've injured your leg, and are unable to walk, and a number of zombies are shuffling towards you, intent on eating your brains. Luckily, you're a crack shot, and have your trusty rifle to hand.\n\nThe zombies start at `range` metres, and move at 0.5 metres per second. Each second, you first shoot one zombie, and then the remaining zombies shamble forwards another 0.5 metres.\n\nIf any zombies manage to get to 0 metres, you get eaten. If you run out of ammo before shooting all the zombies, you'll also get eaten. To keep things simple, we can ignore any time spent reloading.\n\nWrite a function that accepts the total number of zombies, a range in metres, and the number of bullets you have.\n\nIf you shoot all the zombies, return \"You shot all X zombies.\"\nIf you get eaten before killing all the zombies, and before running out of ammo, return \"You shot X zombies before being eaten: overwhelmed.\"\nIf you run out of ammo before shooting all the zombies, return \"You shot X zombies before being eaten: ran out of ammo.\"\n\n(If you run out of ammo at the same time as the remaining zombies reach you, return \"You shot X zombies before being eaten: overwhelmed.\".)\n\nGood luck! (I think you're going to need it.)\n\"\"\"\n\n# ====== Solution ======\n\ndef zombie_shootout(zombies, distance, ammo, shot=0):\n","entry_point":"zombie_shootout","test":"def check(candidate):\n    assert candidate(3,10,10) == 'You shot all 3 zombies.'\n    assert candidate(100,8,200) == 'You shot 16 zombies before being eaten: overwhelmed.'\n    assert candidate(50,10,8) == 'You shot 8 zombies before being eaten: ran out of ammo.'\n    assert candidate(10,10,10) == 'You shot all 10 zombies.'\n    assert candidate(17,8,200) == 'You shot 16 zombies before being eaten: overwhelmed.'\n    assert candidate(9,10,8) == 'You shot 8 zombies before being eaten: ran out of ammo.'\n    assert candidate(20,10,20) == 'You shot all 20 zombies.'\n    assert candidate(100,49,200) == 'You shot 98 zombies before being eaten: overwhelmed.'\n    assert candidate(50,10,19) == 'You shot 19 zombies before being eaten: ran out of ammo.'\n    assert candidate(50,10,49) == 'You shot 20 zombies before being eaten: overwhelmed.'\n    assert candidate(100,10,20) == 'You shot 20 zombies before being eaten: overwhelmed.'\n    assert candidate(19,10,20) == 'You shot all 19 zombies.'\n    assert candidate(20,10,100) == 'You shot all 20 zombies.'\n    assert candidate(20,10,19) == 'You shot 19 zombies before being eaten: ran out of ammo.'\n    assert candidate(19,15,19) == 'You shot all 19 zombies.'\n    assert candidate(19,3,19) == 'You shot 6 zombies before being eaten: overwhelmed.'\n\n","canonical_solution":"def zombie_shootout(zombies, distance, ammo, shot=0):\n    \n    if not zombies:\n        return f'You shot all {shot} zombies.'\n    \n    if distance <= 0:\n        return f'You shot {shot} zombies before being eaten: overwhelmed.'\n    \n    if not ammo:\n        return f'You shot {shot} zombies before being eaten: ran out of ammo.'\n    \n    return zombie_shootout(zombies - 1, distance - 0.5, ammo - 1, shot + 1)"}
{"task_id":2935,"prompt":"\"\"\"\n=====Problem statement====\n\nImplement the function which should return `true` if given object is a vowel (meaning `a, e, i, o, u`), and `false` otherwise.\n\"\"\"\n\n# ====== Solution ======\n\ndef is_vowel(s):\n","entry_point":"is_vowel","test":"def check(candidate):\n    assert candidate('') == False\n    assert candidate('a') == True\n    assert candidate('E') == True\n    assert candidate('ou') == False\n    assert candidate('z') == False\n    assert candidate('lol') == False\n\n","canonical_solution":"def is_vowel(s):\n    return s.lower() in set(\"aeiou\")"}
{"task_id":2939,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function\n\n```python\nhas_two_cube_sums(n)\n```\n\nwhich checks if a given number `n` can be written as the sum of two cubes in two different ways: `n = a\u00b3+b\u00b3 = c\u00b3+d\u00b3`.\nAll the numbers `a`, `b`, `c` and `d` should be different and greater than `0`.\n\nE.g. 1729 = 9\u00b3+10\u00b3 = 1\u00b3+12\u00b3.\n\n```python\nhas_two_cube_sums(1729); \/\/ true\nhas_two_cube_sums(42);   \/\/ false\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef has_two_cube_sums(n):\n","entry_point":"has_two_cube_sums","test":"def check(candidate):\n    assert candidate(1) == False\n    assert candidate(1729) == True\n    assert candidate(42) == False\n    assert candidate(4103) == False\n    assert candidate(4102) == False\n    assert candidate(4104) == True\n    assert candidate(4105) == False\n    assert candidate(4106) == False\n    assert candidate(0) == False\n    assert candidate(46163) == False\n\n","canonical_solution":"def has_two_cube_sums(n):\n    cubic_list = [i**3 for i in range(1, int((n)**(1.\/3.)) + 1)]\n    return sum([(n != 2*c) and ((n-c) in cubic_list) for c in cubic_list]) > 3\n"}
{"task_id":2942,"prompt":"\"\"\"\n=====Problem statement====\n\nHave you heard about the myth that [if you fold a paper enough times, you can reach the moon with it](http:\/\/scienceblogs.com\/startswithabang\/2009\/08\/31\/paper-folding-to-the-moon\/)? Sure you have, but exactly how many? Maybe it's time to write a program to figure it out.\n\nYou know that a piece of paper has a thickness of `0.0001m`. Given `distance` in units of meters, calculate how many times you have to fold the paper to make the paper reach this distance.  \n(If you're not familiar with the concept of folding a paper: Each fold doubles its total thickness.)\n\nNote: Of course you can't do half a fold. You should know what this means ;P\n\nAlso, if somebody is giving you a negative distance, it's clearly bogus and you should yell at them by returning `null` (or whatever equivalent in your language. In Shell please return `None`).\n\"\"\"\n\n# ====== Solution ======\n\ndef fold_to(distance, thickness=0.0001, folds=0):\n","entry_point":"fold_to","test":"def check(candidate):\n    assert candidate(384000000) == 42\n    assert candidate(5e-05) == 0\n    assert candidate(1e-07) == 0\n    assert candidate(0) == 0\n    assert candidate(-1) == None\n\n","canonical_solution":"def fold_to(distance, thickness=0.0001, folds=0):\n    if distance < 0:\n        return\n    \n    while thickness < distance:\n        thickness *= 2\n        folds += 1\n    \n    return folds"}
{"task_id":2946,"prompt":"\"\"\"\n=====Problem statement====\n\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #29\n\nYour friend Nhoj has dislexia, but can easily read messages if the words are written backwards.  \nCreate a function called `reverseSentence()\/reverse_sentence()` that accepts a string argument. The function returns a string of the same length with each word reversed, but still in their original order.\n\n```python\nreverse_sentence(\"Hello !Nhoj Want to have lunch?\") # \"olleH johN! tnaW ot evah ?hcnul\"\n```\nNote:  \nA \"word\" should be considered a string split by a space character, \" \"\nLetter capitalization should be maintained.\n\"\"\"\n\n# ====== Solution ======\n\ndef reverse_sentence(sentence):\n","entry_point":"reverse_sentence","test":"def check(candidate):\n    assert candidate('Hello !Nhoj Want to have lunch?') == 'olleH johN! tnaW ot evah ?hcnul'\n    assert candidate('1 2 3 4 5') == '1 2 3 4 5'\n    assert candidate('CodeWars') == 'sraWedoC'\n    assert candidate('CodeWars rules!') == 'sraWedoC !selur'\n    assert candidate('') == ''\n\n","canonical_solution":"def reverse_sentence(sentence):\n    return ' '.join(w[::-1] for w in sentence.split())"}
{"task_id":2948,"prompt":"\"\"\"\n=====Problem statement====\n\nFor an integer ```k``` rearrange all the elements of the given array in such way, that:\n\nall elements that are less than ```k``` are placed before elements that are not less than ```k```;\nall elements that are less than ```k``` remain in the same order with respect to each other;\nall elements that are not less than ```k``` remain in the same order with respect to each other.\n\nFor ```k = 6``` and ```elements = [6, 4, 10, 10, 6]```, the output should be\n```splitByValue(k, elements) = [4, 6, 10, 10, 6]```.\n\nFor ```k``` = 5 and ```elements = [1, 3, 5, 7, 6, 4, 2]```, the output should be\n```splitByValue(k, elements) = [1, 3, 4, 2, 5, 7, 6]```.\n\nS: codefights.com\n\"\"\"\n\n# ====== Solution ======\n\ndef split_by_value(k, elements):\n","entry_point":"split_by_value","test":"def check(candidate):\n    assert candidate(5,[1, 3, 5, 7, 6, 4, 2]) == [1, 3, 4, 2, 5, 7, 6]\n    assert candidate(0,[5, 2, 7, 3, 2]) == [5, 2, 7, 3, 2]\n    assert candidate(6,[6, 4, 10, 10, 6]) == [4, 6, 10, 10, 6]\n    assert candidate(1,[3, 2, 8, 3, 2, 1]) == [3, 2, 8, 3, 2, 1]\n    assert candidate(10,[9, 2, 4, 3, 4]) == [9, 2, 4, 3, 4]\n\n","canonical_solution":"def split_by_value(k, elements):\n    return sorted(elements, key=lambda x: x >= k)"}
{"task_id":2951,"prompt":"\"\"\"\n=====Problem statement====\n\nI found this interesting interview question just today:\n\n> *8 coins are given where all the coins have equal weight, except one. The odd one weights less than the others, not being of pure gold. In the worst case, how many iterations are actually needed to find the odd one out on a two plates scale*.\n\nI am asking you then to tell me what is the *minimum* amount of weighings it will take to measure `n` coins in every possible occurrence (including worst case scenario, ie: without relying on luck at all).\n\n`n` is guaranteed to be a positive integer.\n\n***Tip:*** being able to think *recursively* might help here :p\n\n***Note:*** albeit this is more clearly a logical than a coding problem, do not underestimate (or under-rank) the kata for requiring not necessarily wizard-class coding skills: a good coder is a master of pattern recognition and subsequent optimization ;)\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil, log\n\ndef how_many_measurements(n):\n","entry_point":"how_many_measurements","test":"def check(candidate):\n    assert candidate(1) == 0\n    assert candidate(2) == 1\n    assert candidate(3) == 1\n    assert candidate(8) == 2\n    assert candidate(100) == 5\n\n","canonical_solution":"from math import ceil, log\n\ndef how_many_measurements(n):\n    return ceil(log(n, 3))"}
{"task_id":2954,"prompt":"\"\"\"\n=====Problem statement====\n\n# A History Lesson\n\nThe Pony Express was a mail service operating in the US in 1859-60.\n\n\n\n\nIt reduced the time for messages to travel between the Atlantic and Pacific coasts to about 10 days, before it was made obsolete by the [transcontinental telegraph](https:\/\/en.wikipedia.org\/wiki\/First_transcontinental_telegraph).\n\n# How it worked\n\nThere were a number of *stations*, where:\n\n* The rider switched to a fresh horse and carried on, or\n* The mail bag was handed over to the next rider\n\n\n# Kata Task\n\n`stations` is a list\/array of distances (miles) from one station to the next along the Pony Express route.\n\nImplement the `riders` method\/function, to return how many riders are necessary to get the mail from one end to the other.\n\n**NOTE:** Each rider travels as far as he can, but never more than 100 miles.\n\n---\n*Good Luck.\nDM.*\n\n---\n\nSee also\n\n* The Pony Express\n* The Pony Express (missing rider)\n\"\"\"\n\n# ====== Solution ======\n\ndef riders(stations):\n","entry_point":"riders","test":"def check(candidate):\n    assert candidate([18, 15]) == 1\n    assert candidate([43, 23, 40, 13]) == 2\n    assert candidate([33, 8, 16, 47, 30, 30, 46]) == 3\n    assert candidate([6, 24, 6, 8, 28, 8, 23, 47, 17, 29, 37, 18, 40, 49]) == 4\n    assert candidate([50, 50]) == 1\n    assert candidate([50, 50, 25, 50, 24]) == 2\n    assert candidate([50, 50, 25, 50, 25]) == 2\n    assert candidate([50, 50, 25, 50, 26]) == 3\n    assert candidate([90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90]) == 100\n\n","canonical_solution":"def riders(stations):\n    riders, travelled = 1, 0\n    \n    for dist in stations:\n        if travelled + dist > 100:\n            riders += 1\n            travelled = dist\n        else:\n            travelled += dist\n    \n    return riders"}
{"task_id":2978,"prompt":"\"\"\"\n=====Problem statement====\n\nWe need a function ```count_sel()``` that receives an array or list of integers (positive and negative) and may give us the following information in the order and  structure presented bellow:\n\n```[(1), (2), (3), [[(4)], 5]]```\n\n(1) - Total amount of received integers.\n\n(2) - Total amount of different values the array has.\n\n(3) - Total amount of values that occur only once.\n\n(4) and (5) both in a list\n\n(4) - It is (or they are) the element(s) that has (or have) the maximum occurrence. If there are more than one, the elements should be sorted (by their value obviously)\n\n(5) - Maximum occurrence of the integer(s)\n\nLet's see some cases\n```python\n____ count_sel([-3, -2, -1, 3, 4, -5, -5, 5, -1, -5]) ----> [10, 7, 5, [[-5], 3]]\n\n(1) - The list has ten elements (10 numbers)\n\n(2) - We have seven different values: -5, -3, -2, -1, 3, 4, 5 (7 values)\n\n(3) - The numbers that occur only once: -3, -2, 3, 4, 5 (5 values)\n\n(4) and (5) - The number -5 occurs three times (3 occurrences)\n\n____ count_sel([4, 4, 2, -3, 1, 4, 3, 2, 0, -5, 2, -2, -2, -5]) ----> [14, 8, 4, [[2, 4], 3]]\n```\nEnjoy it and happy coding!!\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import defaultdict, Counter\n\n\ndef count_sel(nums):\n","entry_point":"count_sel","test":"def check(candidate):\n    assert candidate([-3, -2, -1, 3, 4, -5, -5, 5, -1, -5]) == [10, 7, 5, [[-5], 3]]\n    assert candidate([5, -1, 1, -1, -2, 5, 0, -2, -5, 3]) == [10, 7, 4, [[-2, -1, 5], 2]]\n    assert candidate([-2, 4, 4, -2, -2, -1, 3, 5, -5, 5]) == [10, 6, 3, [[-2], 3]]\n    assert candidate([4, -5, 1, -5, 2, 4, -1, 4, -1, 1]) == [10, 5, 1, [[4], 3]]\n    assert candidate([4, 4, 2, -3, 1, 4, 3, 2, 0, -5, 2, -2, -2, -5]) == [14, 8, 4, [[2, 4], 3]]\n\n","canonical_solution":"from collections import defaultdict, Counter\n\n\ndef count_sel(nums):\n    cnt = Counter(nums)\n    d = defaultdict(list)\n    total = 0\n    unique = 0\n    for k, v in cnt.items():\n        d[v].append(k)\n        total += v\n        unique += 1\n    maximum = max(d)\n    return [total, unique, len(d[1]), [sorted(d[maximum]), maximum]]\n"}
{"task_id":2979,"prompt":"\"\"\"\n=====Problem statement====\n\nAsk a small girl - \"How old are you?\". She always says strange things... Lets help her!\n\n\nFor correct answer program should return int from 0 to 9.\n\nAssume test input string always valid and may look like \n\"1 year old\" or \"5 years old\", etc.. The first char is number only.\n\"\"\"\n\n# ====== Solution ======\n\ndef get_age(age):\n","entry_point":"get_age","test":"def check(candidate):\n    assert candidate('1 year old') == 1\n    assert candidate('2 years old') == 2\n    assert candidate('3 years old') == 3\n    assert candidate('4 years old') == 4\n    assert candidate('5 years old') == 5\n    assert candidate('6 years old') == 6\n    assert candidate('7 years old') == 7\n    assert candidate('8 years old') == 8\n    assert candidate('9 years old') == 9\n\n","canonical_solution":"def get_age(age):\n    return int(age[0])"}
{"task_id":2984,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this kata, the number 0 is infected. You are given a list. Every turn, any item in the list that is adjacent to a 0 becomes infected and transforms into a 0. How many turns will it take for the whole list to become infected?\n\n```\n[0,1,1,0] ==> [0,0,0,0] \nAll infected in 1 turn.\n\n[1,1,0,1,1] --> [1,0,0,0,1] --> [0,0,0,0,0]\nAll infected in 2 turns\n\n[0,1,1,1] --> [0,0,1,1] --> [0,0,0,1] --> [0,0,0,0]\nAll infected in 3 turns.\n```\n\nAll lists will contain at least one item, and at least one zero, and the only items will be 0s and 1s. Lists may be very very long, so pure brute force approach will not work.\n\"\"\"\n\n# ====== Solution ======\n\ndef infected_zeroes(s):\n","entry_point":"infected_zeroes","test":"def check(candidate):\n    assert candidate([0]) == 0\n    assert candidate([0, 1, 1, 0]) == 1\n    assert candidate([0, 1, 1, 1, 0]) == 2\n    assert candidate([1, 1, 0, 1, 1]) == 2\n    assert candidate([0, 1, 1, 1]) == 3\n    assert candidate([1, 1, 1, 0]) == 3\n\n","canonical_solution":"def infected_zeroes(s):\n    m=0; l=0\n    for i,n in enumerate(s):\n        if n==0: m=i if l==0 else max(m, (i-l+1)\/\/2); l=i+1\n    return max(m,len(s)-l)"}
{"task_id":2987,"prompt":"\"\"\"\n=====Problem statement====\n\nYour task is to create function```isDivideBy``` (or ```is_divide_by```) to check if an integer number is divisible by each out of two arguments.\n\nA few cases:\n\n```\n\n(-12, 2, -6)  ->  true\n(-12, 2, -5)  ->  false\n\n(45, 1, 6)    ->  false\n(45, 5, 15)   ->  true\n\n(4, 1, 4)     ->  true\n(15, -5, 3)   ->  true\n\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef is_divide_by(number, a, b):\n","entry_point":"is_divide_by","test":"def check(candidate):\n    assert candidate(8,2,4) == True\n    assert candidate(12,-3,4) == True\n    assert candidate(8,3,4) == False\n    assert candidate(48,2,-5) == False\n    assert candidate(-100,-25,10) == True\n    assert candidate(10000,5,-3) == False\n    assert candidate(4,4,2) == True\n    assert candidate(5,2,3) == False\n    assert candidate(-96,25,17) == False\n    assert candidate(33,1,33) == True\n\n","canonical_solution":"def is_divide_by(number, a, b):\n    return number % a == 0 and number % b == 0"}
{"task_id":2991,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n You are a magician. You're going to perform a trick.\n\n You have `b` black marbles and `w` white marbles in your magic hat, and an infinite supply of black and white marbles that you can pull out of nowhere. \n \n You ask your audience to repeatedly remove a pair of marbles from your hat and, for each pair removed, you add one marble to the hat according to the following rule until there is only 1 marble left. \n\n If the marbles of the pair that is removed are of the same color, you add a white marble to the hat. Otherwise, if one is black and one is white, you add a black marble.\n \n Given the initial number of black and white marbles in your hat, your trick is to predict the color of the last marble.\n \n Note: A magician may confuse your eyes, but not your mind ;-)\n\n# Input\/Output\n\n\n - `[input]` integer `b`\n\n  Initial number of black marbles in the hat. \n  \n  `1 <= b <= 10^9`\n\n\n - `[input]` integer `w`\n\n  Initial number of white marbles in the hat. \n  \n  `1 <= w <= 10^9`\n\n\n - `[output]` a string\n\n  `\"Black\"` or `\"White\"` if you can safely predict the color of the last marble. If not, return `\"Unsure\"`.\n\"\"\"\n\n# ====== Solution ======\n\ndef not_so_random(b,w):\n","entry_point":"not_so_random","test":"def check(candidate):\n    assert candidate(1,1) == 'Black'\n    assert candidate(2,1) == 'White'\n    assert candidate(1,2) == 'Black'\n    assert candidate(2,2) == 'White'\n    assert candidate(6,9) == 'White'\n    assert candidate(10000,10000) == 'White'\n    assert candidate(11111,22222) == 'Black'\n\n","canonical_solution":"def not_so_random(b,w):\n  return ['White', 'Black'][b % 2]"}
{"task_id":2993,"prompt":"\"\"\"\n=====Problem statement====\n\n## Nova polynomial add\n\nThis kata is from a series on polynomial handling. ( [#1](http:\/\/www.codewars.com\/kata\/nova-polynomial-1-add-1) [#2](http:\/\/www.codewars.com\/kata\/570eb07e127ad107270005fe) [#3](http:\/\/www.codewars.com\/kata\/5714041e8807940ff3001140 ) [#4](http:\/\/www.codewars.com\/kata\/571a2e2df24bdfd4e20001f5) )\n\nConsider a polynomial in a list where each element in the list element corresponds to a factor. The factor order is the position in the list. The first element is the zero order factor (the constant).\n\n`p = [a0, a1, a2, a3]` signifies the polynomial `a0 + a1x + a2x^2 + a3*x^3`\n\nIn this kata add two polynomials:\n\n```python\npoly_add ( [1, 2], [1] ) = [2, 2]\n```\n\"\"\"\n\n# ====== Solution ======\n\n# return the sum of the two polynomials p1 and p2.  \ndef poly_add(p1,p2):\n","entry_point":"poly_add","test":"def check(candidate):\n    assert candidate([1],[1]) == [2]\n    assert candidate([1, 2],[1]) == [2, 2]\n    assert candidate([1, 2, 3, 4],[4, 3, 2, 1]) == [5, 5, 5, 5]\n    assert candidate([],[]) == []\n    assert candidate([1, 2, 3, 4, 5, 6],[]) == [1, 2, 3, 4, 5, 6]\n    assert candidate([],[1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n\n","canonical_solution":"# return the sum of the two polynomials p1 and p2.  \ndef poly_add(p1,p2):\n    if p1 == []:\n        return p2\n    if p2 == []:\n        return p1\n    return [p1[0] + p2[0]] + poly_add(p1[1:], p2[1:])\n"}
{"task_id":2996,"prompt":"\"\"\"\n=====Problem statement====\n\nEverybody know that you passed to much time awake during night time...\n\nYour task here is to define how much coffee you need to stay awake after your night. \nYou will have to complete a function that take an array of events in arguments, according to this list you will return the number of coffee you need to stay awake during day time. **Note**: If the count exceed 3 please return 'You need extra sleep'.\n\nThe list of events can contain the following:\n\n- You come here, to solve some kata ('cw').\n\n- You have a dog or a cat that just decide to wake up too early ('dog' | 'cat').\n\n- You just watch a movie ('movie').\n\n- Other events can be present and it will be represent by arbitrary string, just ignore this one.\n\nEach event can be downcase\/lowercase, or uppercase. If it is downcase\/lowercase you need 1 coffee by events and if it is uppercase you need 2 coffees.\n\"\"\"\n\n# ====== Solution ======\n\ncs={'cw':1,'CW':2,'cat':1,'CAT':2,'dog':1,'DOG':2,'movie':1,'MOVIE':2}\n\ndef how_much_coffee(events):\n","entry_point":"how_much_coffee","test":"def check(candidate):\n    assert candidate([]) == 0\n    assert candidate(['cw']) == 1\n    assert candidate(['CW']) == 2\n    assert candidate(['cw', 'CAT']) == 3\n    assert candidate(['cw', 'CAT', 'DOG']) == 'You need extra sleep'\n    assert candidate(['cw', 'CAT', 'cw=others']) == 3\n\n","canonical_solution":"cs={'cw':1,'CW':2,'cat':1,'CAT':2,'dog':1,'DOG':2,'movie':1,'MOVIE':2}\n\ndef how_much_coffee(events):\n    c=sum(cs.get(e,0) for e in events)\n    return 'You need extra sleep' if c>3 else c"}
{"task_id":3001,"prompt":"\"\"\"\n=====Problem statement====\n\n# Invalid Login - Bug Fixing #11\n\nOh NO! Timmy has moved divisions... but now he's in the field of security. Timmy, being the top coder he is, has allowed some bad code through. You must help Timmy and filter out any injected code!\n\n## Task\n\nYour task is simple, search the password string for any injected code (Injected code is any thing that would be used to exploit flaws in the current code, so basically anything that contains `||` or `\/\/`) if you find any you must return `\"Wrong username or password!\"` because no one likes someone trying to cheat their way in!\n\n## Preloaded\n\nYou will be given a preloaded class called `Database` with a method `login` this takes two parameters `username` and `password`. This is a generic login function which will check the database for the user it will return either `'Successfully Logged in!'` if it passes the test or `'Wrong username or password!'` if either the password is wrong or username does not exist.\n\n## Usage\n\n```python\ndatabase = Database()\ndatabase.login('Timmy', 'password')\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef validate(username, password):\n","entry_point":"validate","test":"def check(candidate):\n    assert candidate('Timmy','password') == 'Successfully Logged in!'\n    assert candidate('Timmy','h4x0r') == 'Wrong username or password!'\n    assert candidate('Alice','alice') == 'Successfully Logged in!'\n    assert candidate('Timmy','password\"||\"\"==\"') == 'Wrong username or password!'\n    assert candidate('Admin','gs5bw\"||1==1\/\/') == 'Wrong username or password!'\n\n","canonical_solution":"def validate(username, password):\n    print (username, password)\n    if username == 'Timmy' and password == 'password':\n        return 'Successfully Logged in!'\n    elif username == 'Alice' and password == 'alice':\n        return 'Successfully Logged in!'\n    elif username == 'Johny' and password == 'Hf7FAbf6':\n        return 'Successfully Logged in!'  \n    elif username == 'Roger' and password == 'Cheater':\n        return 'Successfully Logged in!'\n    elif username == 'Simon' and password == 'password':\n        return 'Successfully Logged in!'\n    elif username == 'Simon' and password == 'says':\n        return 'Successfully Logged in!'\n    elif username == 'Roger' and password == 'pass':\n        return 'Successfully Logged in!'\n    elif username == 'Admin' and password == 'ads78adsg7dasga':\n        return 'Successfully Logged in!'\n    else:\n        return 'Wrong username or password!'"}
{"task_id":3002,"prompt":"\"\"\"\n=====Problem statement====\n\n## Task:\nYou have to create a function `isPronic` to check whether the argument passed is a Pronic Number and return true if it is & false otherwise.\n\n### Description:\n\n`Pronic Number` -A pronic number, oblong number, rectangular number or heteromecic number, is a number which is the product of two consecutive integers, that is, n(n + 1).\n\n> The first few Pronic Numbers are - 0, 2, 6, 12, 20, 30, 42...\n\n### Explanation:\n    \n      0 = 0 \u00d7 1   \/\/ \u2234  0 is a Pronic Number\n      2 = 1 \u00d7 2   \/\/ \u2234  2 is a Pronic Number\n      6 = 2 \u00d7 3   \/\/ \u2234  6 is a Pronic Number\n     12 = 3 \u00d7 4   \/\/ \u2234 12 is a Pronic Number\n     20 = 4 \u00d7 5   \/\/ \u2234 20 is a Pronic Number\n     30 = 5 \u00d7 6   \/\/ \u2234 30 is a Pronic Number\n     42 = 6 \u00d7 7   \/\/ \u2234 42 is a Pronic Number\n\"\"\"\n\n# ====== Solution ======\n\nimport math\ndef is_pronic(n):\n","entry_point":"is_pronic","test":"def check(candidate):\n    assert candidate(2) == True\n    assert candidate(3) == False\n    assert candidate(4) == False\n    assert candidate(5) == False\n    assert candidate(6) == True\n    assert candidate(-3) == False\n    assert candidate(-27) == False\n\n","canonical_solution":"import math\ndef is_pronic(n):\n    return n >= 0 and math.sqrt(1 + 4 * n) % 1 == 0"}
{"task_id":3006,"prompt":"\"\"\"\n=====Problem statement====\n\nReducing Problems - Bug Fixing #8\n\nOh no! Timmy's reduce is causing problems, Timmy's goal is to calculate the two teams scores and return the winner but timmy has gotten confused and sometimes teams don't enter their scores, total the scores out of 3! Help timmy fix his program!\n\nReturn true if team 1 wins or false if team 2 wins!\n\"\"\"\n\n# ====== Solution ======\n\ndef calculate_total(team1, team2):\n","entry_point":"calculate_total","test":"def check(candidate):\n    assert candidate([1, 2, 2],[1, 0, 0]) == True\n    assert candidate([6, 45, 1],[1, 55, 0]) == False\n    assert candidate([57, 2, 1],[]) == True\n    assert candidate([],[3, 4, 3]) == False\n    assert candidate([],[]) == False\n\n","canonical_solution":"def calculate_total(team1, team2):\n    return sum(team1) > sum(team2)"}
{"task_id":3008,"prompt":"\"\"\"\n=====Problem statement====\n\nFailed Sort - Bug Fixing #4\nOh no, Timmy's Sort doesn't seem to be working? Your task is to fix the sortArray function to sort all numbers in ascending order\n\"\"\"\n\n# ====== Solution ======\n\ndef sort_array(value):\n","entry_point":"sort_array","test":"def check(candidate):\n    assert candidate('12345') == '12345'\n    assert candidate('54321') == '12345'\n    assert candidate('34251') == '12345'\n    assert candidate('11111') == '11111'\n    assert candidate('10101') == '00111'\n\n","canonical_solution":"def sort_array(value):\n    return \"\".join(sorted(value))"}
{"task_id":3016,"prompt":"\"\"\"\n=====Problem statement====\n\nCheck if given chord is minor or major.\n\n_____________________________________________________________\nRules:\n\n1. Basic minor\/major chord have three elements.\n\n2. Chord is minor when interval between first and second element equals 3 and between second and third -> 4.\n\n3. Chord is major when interval between first and second element equals 4 and between second and third -> 3.\n\n4. In minor\/major chord interval between first and third element equals... 7.\n\n_______________________________________________________________\nThere is a preloaded list of the 12 notes of a chromatic scale built on C. This means that there are (almost) all allowed note' s names in music.\n\nnotes = \n['C', ['C#', 'Db'], 'D', ['D#', 'Eb'], 'E', 'F', ['F#', 'Gb'], 'G', ['G#', 'Ab'], 'A', ['A#', 'Bb'], 'B']\n\nNote that e. g. 'C#' - 'C' = 1, 'C' - 'C#' = 1, 'Db' - 'C' = 1 and 'B' - 'C' = 1. \n\nInput:\nString of notes separated by whitespace, e. g. 'A C# E'\n\nOutput:\nString message: 'Minor', 'Major' or 'Not a chord'.\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import product\n\nNOTES =  [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']]*2\nconfig = [('Major', 4), ('Minor', 3)]\n\nDCT_CHORDS = {c: mode for mode, offset in config\n                      for i in range(len(NOTES)\/\/2)\n                      for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef minor_or_major(chord):\n","entry_point":"minor_or_major","test":"def check(candidate):\n    assert candidate('C E G') == 'Major'\n    assert candidate('Db F Ab') == 'Major'\n    assert candidate('D F# A') == 'Major'\n    assert candidate('Eb G Bb') == 'Major'\n    assert candidate('E G# B') == 'Major'\n    assert candidate('F A C') == 'Major'\n    assert candidate('F# A# C#') == 'Major'\n    assert candidate('Gb Bb Db') == 'Major'\n    assert candidate('G B D') == 'Major'\n    assert candidate('Ab C Eb') == 'Major'\n    assert candidate('A C# E') == 'Major'\n    assert candidate('Bb D F') == 'Major'\n    assert candidate('B D# F#') == 'Major'\n    assert candidate('C Eb G') == 'Minor'\n    assert candidate('C# E G#') == 'Minor'\n    assert candidate('D F A') == 'Minor'\n    assert candidate('D# F# A#') == 'Minor'\n    assert candidate('Eb Gb Bb') == 'Minor'\n    assert candidate('E G B') == 'Minor'\n    assert candidate('F Ab C') == 'Minor'\n    assert candidate('F# A C#') == 'Minor'\n    assert candidate('G Bb D') == 'Minor'\n    assert candidate('G# B D#') == 'Minor'\n    assert candidate('A C E') == 'Minor'\n    assert candidate('Bb Db F') == 'Minor'\n    assert candidate('B D F#') == 'Minor'\n    assert candidate('C D G') == 'Not a chord'\n    assert candidate('A C D') == 'Not a chord'\n    assert candidate('A C# D#') == 'Not a chord'\n    assert candidate('D F A G') == 'Not a chord'\n    assert candidate('D F') == 'Not a chord'\n    assert candidate('D F A C#') == 'Not a chord'\n    assert candidate('K L M') == 'Not a chord'\n    assert candidate('C A G') == 'Not a chord'\n    assert candidate('C H G') == 'Not a chord'\n    assert candidate('G E C') == 'Not a chord'\n    assert candidate('E C A') == 'Not a chord'\n    assert candidate('G# E C#') == 'Not a chord'\n    assert candidate('Bb Gb Eb') == 'Not a chord'\n\n","canonical_solution":"from itertools import product\n\nNOTES =  [['C'], ['C#', 'Db'], ['D'], ['D#', 'Eb'], ['E'], ['F'], ['F#', 'Gb'], ['G'], ['G#', 'Ab'], ['A'], ['A#', 'Bb'], ['B']]*2\nconfig = [('Major', 4), ('Minor', 3)]\n\nDCT_CHORDS = {c: mode for mode, offset in config\n                      for i in range(len(NOTES)\/\/2)\n                      for c in product(NOTES[i], NOTES[i + offset], NOTES[i + 7])}\n\ndef minor_or_major(chord):\n    chord = tuple(chord.split()) if isinstance(chord, str) else \"\"\n    return DCT_CHORDS.get(chord, \"Not a chord\")"}
{"task_id":3019,"prompt":"\"\"\"\n=====Problem statement====\n\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #18\n\nCreate a function called that accepts 2 string arguments and returns an integer of the count of occurrences the 2nd argument is found in the first one.\n\nIf no occurrences can be found, a count of 0 should be returned.\n\nNotes:\n* The first argument can be an empty string  \n* The second string argument will always be of length 1\n\"\"\"\n\n# ====== Solution ======\n\ndef str_count(strng, letter):\n","entry_point":"str_count","test":"def check(candidate):\n    assert candidate('hello','l') == 2\n    assert candidate('hello','e') == 1\n    assert candidate('codewars','c') == 1\n    assert candidate('ggggg','g') == 5\n    assert candidate('hello world','o') == 2\n\n","canonical_solution":"def str_count(strng, letter):\n    counter = 0\n    \n    for chr in strng:\n        if chr == letter:\n            counter += 1\n        \n    return counter"}
{"task_id":3024,"prompt":"\"\"\"\n=====Problem statement====\n\nMake a program that filters a list of strings and returns a list with only your friends name in it.\n\nIf a name has exactly 4 letters in it, you can be sure that it has to be a friend of yours! Otherwise, you can be sure he's not...\n\nEx: Input = [\"Ryan\", \"Kieran\", \"Jason\", \"Yous\"], Output = [\"Ryan\", \"Yous\"]\n\ni.e.\n\nNote: keep the original order of the names in the output.\n\"\"\"\n\n# ====== Solution ======\n\ndef friend(x):\n","entry_point":"friend","test":"def check(candidate):\n    assert candidate(['Ryan', 'Kieran', 'Mark']) == ['Ryan', 'Mark']\n    assert candidate(['Ryan', 'Jimmy', '123', '4', 'Cool Man']) == ['Ryan']\n    assert candidate(['Jimm', 'Cari', 'aret', 'truehdnviegkwgvke', 'sixtyiscooooool']) == ['Jimm', 'Cari', 'aret']\n    assert candidate(['Love', 'Your', 'Face', '1']) == ['Love', 'Your', 'Face']\n    assert candidate(['Hell', 'Is', 'a', 'badd', 'word']) == ['Hell', 'badd', 'word']\n    assert candidate(['Issa', 'Issac', 'Issacs', 'ISISS']) == ['Issa']\n    assert candidate(['Robot', 'Your', 'MOMOMOMO']) == ['Your']\n    assert candidate(['Your', 'BUTT']) == ['Your', 'BUTT']\n    assert candidate(['Hello', 'I', 'AM', 'Sanjay', 'Gupt']) == ['Gupt']\n    assert candidate(['This', 'IS', 'enough', 'TEst', 'CaSe']) == ['This', 'TEst', 'CaSe']\n    assert candidate([]) == []\n\n","canonical_solution":"def friend(x):\n    return [f for f in x if len(f) == 4]"}
{"task_id":3029,"prompt":"\"\"\"\n=====Problem statement====\n\n> In information theory and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences. Informally, the Levenshtein distance between two words is the minimum number of single-character edits (i.e. insertions, deletions or substitutions) required to change one word into the other.\n\n(http:\/\/en.wikipedia.org\/wiki\/Levenshtein_distance)\n\n\nYour task is to implement a function which calculates the Levenshtein distance for two arbitrary strings.\n\"\"\"\n\n# ====== Solution ======\n\ndef levenshtein(a,b):\n","entry_point":"levenshtein","test":"def check(candidate):\n    assert candidate('kitten','sitting') == 3\n    assert candidate('book','back') == 2\n    assert candidate('book','book') == 0\n    assert candidate('qlzcfayxiz','vezkvgejzb') == 9\n    assert candidate('nayvyedosf','sjxen') == 9\n    assert candidate('sjxen','sjxen') == 0\n    assert candidate('peter','peter') == 0\n\n","canonical_solution":"def levenshtein(a,b):\n    d = [[0] * (len(b) + 1) for _ in range(len(a) + 1)]\n\n    d[0][:] = list(range(len(b)+1))\n    for i in range(1, len(a) + 1):\n        d[i][0] = i\n\n    for i, x in enumerate(a):\n        for j, y in enumerate(b):\n            d[i+1][j+1] = min(1 + d[i][j+1], 1 + d[i+1][j], d[i][j] + (1 if x != y else 0))\n\n    return d[-1][-1]\n\n"}
{"task_id":3034,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n\nYour task is to write a function for calculating the score of a 10 pin bowling game. The input for the function is a list of pins knocked down per roll for one player. Output is the player's total score.\n\n# Rules\n\n## General rules\nRules of bowling in a nutshell:\n\n* A game consists of 10 frames. In each frame the player rolls 1 or 2 balls, except for the 10th frame, where the player rolls 2 or 3 balls.\n\n* The total score is the sum of your scores for the 10 frames\n\n* If you knock down fewer than 10 pins with 2 balls, your frame score is the number of pins knocked down\n\n* If you knock down all 10 pins with 2 balls (spare), you score the amount of pins knocked down plus a bonus - amount of pins knocked down with the next ball\n\n* If you knock down all 10 pins with 1 ball (strike), you score the amount of pins knocked down plus a bonus - amount of pins knocked down with the next 2 balls\n\n## Rules for 10th frame\nAs the 10th frame is the last one, in case of spare or strike there will be no next balls for the bonus. To account for that:\n\n* if the last frame is a spare, player rolls 1 bonus ball.\n* if the last frame is a strike, player rolls 2 bonus balls.\n\nThese bonus balls on 10th frame are only counted as a bonus to the respective spare or strike.\n\n# More information\nhttp:\/\/en.wikipedia.org\/wiki\/Ten-pin_bowling#Scoring\n\n# Input\nYou may assume that the input is always valid. This means:\n\n* input list length is correct\n* number of pins knocked out per roll is valid\n\"\"\"\n\n# ====== Solution ======\n\ndef bowling_score(rolls):\n","entry_point":"bowling_score","test":"def check(candidate):\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 0\n    assert candidate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 20\n    assert candidate([4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]) == 80\n    assert candidate([9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9]) == 190\n    assert candidate([10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) == 300\n    assert candidate([10, 5, 5, 10, 5, 5, 10, 5, 5, 10, 5, 5, 10, 5, 5, 10]) == 200\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 0]) == 11\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 1, 0]) == 12\n    assert candidate([10, 10, 2, 8, 10, 9, 1, 10, 10, 4, 6, 0, 10, 7, 3, 7]) == 190\n\n","canonical_solution":"def bowling_score(rolls):\n  \"Compute the total score for a player's game of bowling.\"\n  \n  def is_spare(rolls):\n    return 10 == sum(rolls[:2])\n\n  def is_strike(rolls):\n    return 10 == rolls[0]\n\n  def calc_score(rolls, frame):\n    return (sum(rolls) if frame == 10 else\n            sum(rolls[:3]) + calc_score(rolls[1:], frame+1) if is_strike(rolls) else\n            sum(rolls[:3]) + calc_score(rolls[2:], frame+1) if is_spare(rolls) else\n            sum(rolls[:2]) + calc_score(rolls[2:], frame+1))\n  \n  return calc_score(rolls,1)\n"}
{"task_id":3040,"prompt":"\"\"\"\n=====Problem statement====\n\n# Description\n\"It's the end of trick-or-treating and we have a list\/array representing how much candy each child in our group has made out with. We don't want the kids to start arguing, and using our parental intuition we know trouble is brewing as many of the children in the group have received different amounts of candy from each home. \n\nSo we want each child to have the same amount of candies, only we can't exactly take any candy away from the kids, that would be even worse. Instead we decide to give each child extra candy until they all have the same amount.\n# Task\nYour job is to find out how much candy each child has, and give them each additional candy until they too have as much as the child(ren) with the most candy. You also want to keep a total of how much candy you've handed out because reasons.\"\n\nYour job is to give all the kids the same amount of candies as the kid with the most candies and then return the total number candies that have been given out. If there are no kids, or only one, return -1. \n\nIn the first case (look below) the most candies are given to second kid (i.e second place in list\/array), 8. Because of that we will give the first kid 3 so he can have 8 and the third kid 2 and the fourth kid 4, so all kids will have 8 candies.So we end up handing out 3 + 2 + 4 = 9.\n\n```python\ncandies ([5,8,6,4]) # return 9\n\ncandies ([1,2,4,6]) # return 11\n\ncandies ([1,6]) # return 5\n\ncandies ([]) # return -1\n\ncandies ([6]) # return -1 (because only one kid)\n```\n```cs\nCandyProblem.GetMissingCandies(new [] {5, 6, 8, 4}) \/\/ return 9\n\nCandyProblem.GetMissingCandies(new [] {1, 2, 4, 6}) \/\/ return 11\n\nCandyProblem.GetMissingCandies(new [] { }) \/\/ return -1\n\nCandyProblem.GetMissingCandies(new [] {1, 6}) \/\/ return 5\n\n```\n```haskell \ncandies [5,8,6,4] -- return 9\n\ncandies [1,2,4,6] -- return 11\n\ncandies [] -- return -1\n\ncandies [1,6] -- return 5\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef candies(s):\n","entry_point":"candies","test":"def check(candidate):\n    assert candidate([5, 8, 6, 4]) == 9\n    assert candidate([1, 2, 4, 6]) == 11\n    assert candidate([1, 2]) == 1\n    assert candidate([4, 2]) == 2\n    assert candidate([1, 3, 3, 7]) == 14\n    assert candidate([7, 7, 7, 7]) == 0\n    assert candidate([17, 20, 50, 61, 42, 44]) == 132\n    assert candidate([0]) == -1\n    assert candidate([]) == -1\n    assert candidate([4]) == -1\n    assert candidate([None]) == -1\n\n","canonical_solution":"def candies(s):\n    if not s or len(s) == 1:\n        return -1\n    return len(s) * max(s) - sum(s)\n"}
{"task_id":3048,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite function alternateCase which switch every letter in string from upper to lower and from lower to upper.\nE.g: Hello World -> hELLO wORLD\n\"\"\"\n\n# ====== Solution ======\n\ndef alternateCase(s):\n","entry_point":"alternateCase","test":"def check(candidate):\n    assert candidate('ABC') == 'abc'\n    assert candidate('') == ''\n    assert candidate(' ') == ' '\n    assert candidate('Hello World') == 'hELLO wORLD'\n    assert candidate('cODEwARS') == 'CodeWars'\n    assert candidate('i LIKE MAKING KATAS VERY MUCH') == 'I like making katas very much'\n    assert candidate('HuMpTy DuMpTy SaT On A WaLl') == 'hUmPtY dUmPtY sAt oN a wAlL'\n    assert candidate('aBracaDabRa') == 'AbRACAdABrA'\n    assert candidate('Hickory DICKORY dock') == 'hICKORY dickory DOCK'\n    assert candidate('Jack JUMPED over THE CaNdLeStIcK') == 'jACK jumped OVER the cAnDlEsTiCk'\n\n","canonical_solution":"def alternateCase(s):\n    return s.swapcase()"}
{"task_id":3059,"prompt":"\"\"\"\n=====Problem statement====\n\nYou have an award-winning garden and everyday the plants need exactly 40mm of water. You created a great piece of JavaScript to calculate the amount of water your plants will need when you have taken into consideration the amount of rain water that is forecast for the day. Your jealous neighbour hacked your computer and filled your code with bugs. \n\nYour task is to debug the code before your plants die!\n\"\"\"\n\n# ====== Solution ======\n\ndef rain_amount(mm):\n","entry_point":"rain_amount","test":"def check(candidate):\n    assert candidate(100) == 'Your plant has had more than enough water for today!'\n    assert candidate(40) == 'Your plant has had more than enough water for today!'\n    assert candidate(39) == 'You need to give your plant 1mm of water'\n    assert candidate(5) == 'You need to give your plant 35mm of water'\n    assert candidate(0) == 'You need to give your plant 40mm of water'\n\n","canonical_solution":"def rain_amount(mm):\n    if mm < 40:\n             return \"You need to give your plant \" + str(40 - mm) + \"mm of water\"\n    else:\n             return \"Your plant has had more than enough water for today!\""}
{"task_id":3068,"prompt":"\"\"\"\n=====Problem statement====\n\nYou need to play around with the provided string (s).\n\nMove consonants forward 9 places through the alphabet.\nIf they pass 'z', start again at 'a'.\n\nMove vowels back 5 places through the alphabet.\nIf they pass 'a', start again at 'z'.\nFor our Polish friends this kata does not count 'y' as a vowel.\n\nExceptions:\n\nIf the character is 'c' or 'o', move it back 1 place.\nFor 'd' move it back 3, and for 'e', move it back 4.\n\nIf a moved letter becomes 'c', 'o', 'd' or 'e', revert it back to it's original value.\n\nProvided string will always be lower case, won't be empty and will have no special characters.\n\"\"\"\n\n# ====== Solution ======\n\ndef vowel_back(st):\n","entry_point":"vowel_back","test":"def check(candidate):\n    assert candidate('testcase') == 'tabtbvba'\n    assert candidate('codewars') == 'bnaafvab'\n    assert candidate('exampletesthere') == 'agvvyuatabtqaaa'\n    assert candidate('returnofthespacecamel') == 'aatpawnftqabyvbabvvau'\n    assert candidate('bringonthebootcamp') == 'kaiwpnwtqaknntbvvy'\n    assert candidate('weneedanofficedog') == 'fawaaavwnffibaanp'\n\n","canonical_solution":"def vowel_back(st):\n    return st.translate(str.maketrans(\"abcdefghijklmnopqrstuvwxyz\", \"vkbaafpqistuvwnyzabtpvfghi\"))"}
{"task_id":3069,"prompt":"\"\"\"\n=====Problem statement====\n\nYour start-up's BA has told marketing that your website has a large audience in Scandinavia and surrounding countries. Marketing thinks it would be great to welcome visitors to the site in their own language. Luckily you already use an API that detects the user's location, so this is an easy win. \n\n### The Task\n- Think of a way to store the languages as a database (eg an object). The languages are listed below so you can copy and paste!\n- Write a 'welcome' function that takes a parameter 'language' (always a string), and returns a greeting - if you have it in your database. It should default to English if the language is not in the database, or in the event of an invalid input.\n\n### The Database\n\n```python\n'english': 'Welcome',\n'czech': 'Vitejte',\n'danish': 'Velkomst',\n'dutch': 'Welkom',\n'estonian': 'Tere tulemast',\n'finnish': 'Tervetuloa',\n'flemish': 'Welgekomen',\n'french': 'Bienvenue',\n'german': 'Willkommen',\n'irish': 'Failte',\n'italian': 'Benvenuto',\n'latvian': 'Gaidits',\n'lithuanian': 'Laukiamas',\n'polish': 'Witamy',\n'spanish': 'Bienvenido',\n'swedish': 'Valkommen',\n'welsh': 'Croeso'\n```\n``` java\nenglish: \"Welcome\",\nczech: \"Vitejte\",\ndanish: \"Velkomst\",\ndutch: \"Welkom\",\nestonian: \"Tere tulemast\",\nfinnish: \"Tervetuloa\",\nflemish: \"Welgekomen\",\nfrench: \"Bienvenue\",\ngerman: \"Willkommen\",\nirish: \"Failte\",\nitalian: \"Benvenuto\",\nlatvian: \"Gaidits\",\nlithuanian: \"Laukiamas\",\npolish: \"Witamy\",\nspanish: \"Bienvenido\",\nswedish: \"Valkommen\",\nwelsh: \"Croeso\"\n```\n\nPossible invalid inputs include:\n~~~~\nIP_ADDRESS_INVALID - not a valid ipv4 or ipv6 ip address\nIP_ADDRESS_NOT_FOUND - ip address not in the database\nIP_ADDRESS_REQUIRED - no ip address was supplied\n~~~~\n\"\"\"\n\n# ====== Solution ======\n\ndef greet(language):\n","entry_point":"greet","test":"def check(candidate):\n    assert candidate('english') == 'Welcome'\n    assert candidate('dutch') == 'Welkom'\n    assert candidate('IP_ADDRESS_INVALID') == 'Welcome'\n    assert candidate('') == 'Welcome'\n    assert candidate(2) == 'Welcome'\n\n","canonical_solution":"def greet(language):\n    return {\n        'czech': 'Vitejte',\n        'danish': 'Velkomst',\n        'dutch': 'Welkom',\n        'english': 'Welcome',\n        'estonian': 'Tere tulemast',\n        'finnish': 'Tervetuloa',\n        'flemish': 'Welgekomen',\n        'french': 'Bienvenue',\n        'german': 'Willkommen',\n        'irish': 'Failte',\n        'italian': 'Benvenuto',\n        'latvian': 'Gaidits',\n        'lithuanian': 'Laukiamas',\n        'polish': 'Witamy',\n        'spanish': 'Bienvenido',\n        'swedish': 'Valkommen',\n        'welsh': 'Croeso'\n    }.get(language, 'Welcome')"}
{"task_id":3072,"prompt":"\"\"\"\n=====Problem statement====\n\nWell, those numbers were right and we're going to feed their ego.\n\nWrite a function, isNarcissistic, that takes in any amount of numbers and returns true if all the numbers are narcissistic. Return false for invalid arguments (numbers passed in as strings are ok).\n\nFor more information about narcissistic numbers (and believe me, they love it when you read about them) follow this link: https:\/\/en.wikipedia.org\/wiki\/Narcissistic_number\n\"\"\"\n\n# ====== Solution ======\n\ndef get_digits(n):\n    return [int(x) for x in list(str(n))]\n\n\ndef is_narc(n):\n    return n == sum([x**len(get_digits(n)) for x in get_digits(n)])\n\n\ndef is_narcissistic(*values):\n","entry_point":"is_narcissistic","test":"def check(candidate):\n    assert candidate(11) == False\n    assert candidate(0,1,2,3,4,5,6,7,8,9) == True\n    assert candidate(0,1,2,3,4,5,6,7,22,9) == False\n    assert candidate('4') == True\n    assert candidate('4',7,'9') == True\n    assert candidate('words') == False\n    assert candidate([1, 2]) == False\n    assert candidate(407,8208) == True\n    assert candidate(-1) == False\n    assert candidate('') == False\n    assert candidate('',407) == False\n    assert candidate(407,'') == False\n    assert candidate(5,'',407) == False\n    assert candidate(9474) == True\n    assert candidate({}) == False\n\n","canonical_solution":"def get_digits(n):\n    return [int(x) for x in list(str(n))]\n\n\ndef is_narc(n):\n    return n == sum([x**len(get_digits(n)) for x in get_digits(n)])\n\n\ndef is_narcissistic(*values):\n    try:\n        return all(type(n) in [int,str] and is_narc(int(n)) for n in values)\n    except ValueError:\n        return False"}
{"task_id":3079,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a certain integer ```n```, we need a function ```big_primefac_div()```, that give an array with the highest prime factor and the highest divisor (not equal to n).\n\nLet's see some cases:\n```python\nbig_primefac_div(100) == [5, 50]\nbig_primefac_div(1969) == [179, 179]\n```\nIf n is a prime number the function will output an empty list:\n```python\nbig_primefac_div(997) == []\n```\nIf ```n``` is an negative integer number, it should be considered the division with tha absolute number of the value.\n```python\nbig_primefac_div(-1800) == [5, 900]\n```\nIf ```n``` is a float type, will be rejected if it has a decimal part with some digits different than 0. The output \"The number has a decimal part. No Results\". But  ```n ``` will be converted automatically to an integer if all the digits of the decimal part are 0.\n\n```python\nbig_primefac_div(-1800.00) == [5, 900]\nbig_primefac_div(-1800.1) == \"The number has a decimal part. No Results\"\n```\nOptimization and fast algorithms are a key factor to solve this kata.\nHappy coding and enjoy it!\n\"\"\"\n\n# ====== Solution ======\n\ndef big_primefac_div(n):\n","entry_point":"big_primefac_div","test":"def check(candidate):\n    assert candidate(100) == [5, 50]\n    assert candidate(1969) == [179, 179]\n    assert candidate(997) == []\n    assert candidate(-1800) == [5, 900]\n    assert candidate(-1800.1) == 'The number has a decimal part. No Results'\n\n","canonical_solution":"def big_primefac_div(n):\n    bpf, bd = 0, 1\n    frac = []\n    \n    if n % 1 != 0:\n        return \"The number has a decimal part. No Results\"\n    else:\n        n = abs(int(n))\n        n_copy = n\n  \n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            n \/\/= i\n            frac.append(i)\n        else:\n            i += 1\n    if n > 1: frac.append(n)\n\n    bpf = max(frac)\n    bd = n_copy \/ frac[0]\n            \n    if bpf == 0 or bd == 1:\n        return []\n    else:\n        return [bpf, bd]"}
{"task_id":3080,"prompt":"\"\"\"\n=====Problem statement====\n\nDon Drumphet lives in a nice neighborhood, but one of his neighbors has started to let his house go.  Don Drumphet wants to build a wall between his house and his neighbor\u2019s, and is trying to get the neighborhood association to pay for it.  He begins to solicit his neighbors to petition to get the association to build the wall.  Unfortunately for Don Drumphet, he cannot read very well, has a very limited attention span, and can only remember two letters from each of his neighbors\u2019 names.  As he collects signatures, he insists that his neighbors keep truncating their names until two letters remain, and he can finally read them.\n\nYour code will show Full name of the neighbor and the truncated version of the name as an array. If the number of the characters in name is less than or equal to two, it will return an array containing only the name as is\"\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"who_is_paying","test":"def check(candidate):\n    assert candidate('Mexico') == ['Mexico', 'Me']\n    assert candidate('Melania') == ['Melania', 'Me']\n    assert candidate('Melissa') == ['Melissa', 'Me']\n    assert candidate('Me') == ['Me']\n    assert candidate('') == ['']\n    assert candidate('I') == ['I']\n\n","canonical_solution":"who_is_paying = lambda n: [n, n[:2]] if len(n)>2 else [n]"}
{"task_id":3097,"prompt":"\"\"\"\n=====Problem statement====\n\nComprised of a team of five incredibly brilliant women, \"The ladies of ENIAC\" were the first \u201ccomputors\u201d working at the University of Pennsylvania\u2019s Moore School of Engineering (1945). Through their contributions, we gained the first software application and the first programming classes! The ladies of ENIAC were inducted into the WITI Hall of Fame in 1997!\n\nWrite a function which reveals \"The ladies of ENIAC\" names, so that you too can add them to your own hall of tech fame!\n\nTo keep: only alpha characters, space characters and exclamation marks.  \nTo remove: numbers and these characters: ```%$&\/\u00a3?@```\n\nResult should be all in uppercase.\n\"\"\"\n\n# ====== Solution ======\n\nimport re\ndef rad_ladies(name):\n","entry_point":"rad_ladies","test":"def check(candidate):\n    assert candidate('k?%35a&&\/y@@@5599 m93753&$$$c$n\/\/\/79u??@@%l?975$t?%5y%&$3$1!') == 'KAY MCNULTY!'\n    assert candidate('9?9?9?m335%$@a791%&$r$$$l@53$&y&n%$5@ $5577w&7e931%s$c$o%%%f351f??%!%%') == 'MARLYN WESCOFF!'\n    assert candidate('%&$557f953\/\/1\/$@%r%935$$a@3111$@???%n???5 $%157b%\/\/\/$i%55&31@l?%&$$a%@$s5757!$$%%%%53') == 'FRAN BILAS!'\n    assert candidate('\/\/\/$%&$553791r357%??@$%u?$%@7993111@$%t$h3% 3$l$311i3%@?&c3h%&t&&?%11e%$?@11957r79%&m$$a55n1!111%%') == 'RUTH LICHTERMAN!'\n    assert candidate('??@%&a5d15??e599713%l%%e%75913 1$%&@g@%o&$@13l5d11s$%&t15i9n&5%%@%e@$!%$') == 'ADELE GOLDSTINE!'\n\n","canonical_solution":"import re\ndef rad_ladies(name):\n    return \"\".join(re.findall(\"[A-Z\\s!]+\", name.upper()))"}
{"task_id":3099,"prompt":"\"\"\"\n=====Problem statement====\n\nBased on [this kata, Connect Four.](https:\/\/www.codewars.com\/kata\/connect-four-1)\n\nIn this kata we play a modified game of connect four. It's connect X, and there can be multiple players.\n\nWrite the function ```whoIsWinner(moves,connect,size)```.\n\n```2 <= connect <= 10```\n\n```2 <= size <= 52```\n\nEach column is identified by a character, A-Z a-z:  \n``` ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ```\n\n\nMoves come in the form:\n\n```\n['C_R','p_Y','s_S','I_R','Z_Y','d_S']\n```\n* Player R puts on C\n* Player Y puts on p\n* Player S puts on s\n* Player R puts on I\n* ...\n\nThe moves are in the order that they are played. \n\nThe first player who connect ``` connect ``` items in same color is the winner. \n\nNote that a player can win before all moves are done. You should return the first winner.\n\nIf no winner is found, return \"Draw\".\n\nA board with size 7, where yellow has connected 4:\n\nAll inputs are valid, no illegal moves are made.\n\n![alt text](https:\/\/i.imgur.com\/xnJEsIx.png)\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c:i for i,c in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef whoIsWinner(moves, con, sz):\n","entry_point":"whoIsWinner","test":"def check(candidate):\n    assert candidate(['A_R', 'B_Y', 'A_R'],2,2) == 'R'\n    assert candidate(['B_R', 'A_Y', 'A_R', 'D_Y', 'B_R', 'D_Y', 'B_R', 'D_Y', 'C_R', 'D_Y'],4,4) == 'Y'\n    assert candidate(['A_R', 'C_Y', 'C_R', 'B_Y', 'A_R', 'C_Y', 'B_R', 'B_Y', 'D_R', 'A_Y', 'D_R', 'A_Y'],2,4) == 'Y'\n    assert candidate(['H_R', 'A_Y', 'A_R', 'C_Y', 'H_R', 'E_Y', 'G_R', 'C_Y', 'D_R', 'F_Y', 'E_R', 'D_Y', 'D_R', 'D_Y', 'C_R', 'C_Y', 'D_R', 'A_Y', 'G_R', 'E_Y', 'C_R', 'H_Y', 'A_R', 'G_Y', 'B_R', 'G_Y', 'A_R', 'G_Y', 'H_R', 'G_Y', 'E_R', 'F_Y', 'A_R', 'E_Y', 'H_R', 'D_Y', 'H_R', 'H_Y', 'A_R', 'E_Y', 'C_R', 'B_Y', 'C_R', 'E_Y', 'G_R', 'G_Y'],2,8) == 'R'\n    assert candidate(['F_R', 'B_Y', 'E_R', 'F_Y', 'A_R', 'E_Y', 'C_R', 'E_Y', 'C_R', 'B_Y', 'A_R', 'F_Y', 'C_R', 'E_Y', 'D_R', 'A_Y', 'D_R', 'E_Y', 'C_R', 'A_Y', 'A_R', 'D_Y', 'D_R', 'E_Y'],4,6) == 'R'\n    assert candidate(['A_R', 'E_Y', 'E_R', 'D_Y', 'A_R', 'A_Y', 'D_R', 'B_Y', 'E_R', 'E_Y', 'D_R', 'E_Y'],4,5) == 'Draw'\n    assert candidate(['E_R', 'E_Y', 'E_R', 'A_Y', 'B_R', 'C_Y', 'B_R', 'F_Y', 'F_R', 'C_Y', 'B_R', 'D_Y', 'D_R', 'A_Y', 'C_R', 'E_Y', 'B_R', 'D_Y', 'D_R', 'A_Y', 'A_R', 'D_Y', 'D_R'],3,6) == 'R'\n    assert candidate(['G_R', 'E_Y', 'A_R', 'G_Y', 'C_R', 'H_Y', 'E_R', 'G_Y', 'E_R', 'A_Y', 'C_R', 'E_Y', 'A_R', 'D_Y', 'B_R', 'F_Y', 'C_R', 'C_Y', 'F_R', 'A_Y', 'G_R', 'D_Y', 'C_R', 'E_Y', 'B_R', 'B_Y', 'B_R', 'C_Y', 'G_R', 'B_Y', 'D_R', 'F_Y', 'A_R', 'G_Y', 'D_R', 'H_Y', 'G_R', 'H_Y', 'B_R', 'G_Y'],4,8) == 'Y'\n    assert candidate(['B_R', 'A_Y', 'B_R'],3,2) == 'Draw'\n    assert candidate(['C_R', 'F_Y', 'c_R', 'E_Y', 'h_R', 'E_Y', 'P_R', 'E_Y', 'H_R', 'S_Y', 'b_R', 'B_Y', 'X_R', 'U_Y', 'M_R', 'N_Y', 'W_R', 'E_Y', 'R_R', 'T_Y', 'L_R', 'A_Y', 'N_R', 'h_Y', 'd_R', 'X_Y', 'D_R', 'g_Y', 'd_R', 'X_Y', 'b_R', 'I_Y', 'Y_R', 'J_Y', 'P_R', 'g_Y', 'Y_R', 'B_Y', 'a_R', 'S_Y', 'C_R', 'a_Y', 'i_R', 'a_Y', 'N_R', 'J_Y', 'g_R', 'b_Y', 'X_R', 'R_Y', 'I_R', 'W_Y', 'G_R', 'Y_Y', 'I_R', 'N_Y', 'R_R', 'a_Y', 'a_R', 'J_Y', 'E_R', 'X_Y', 'Y_R', 'J_Y', 'e_R', 'T_Y', 'h_R', 'W_Y', 'b_R', 'X_Y', 'g_R', 'O_Y', 'b_R', 'U_Y', 'G_R', 'h_Y', 'H_R', 'h_Y', 'K_R', 'L_Y', 'T_R', 'L_Y', 'c_R', 'L_Y', 'O_R', 'H_Y', 'K_R', 'P_Y', 'D_R', 'S_Y', 'A_R', 'T_Y', 'G_R', 'K_Y', 'J_R', 'G_Y', 'h_R', 'F_Y', 'W_R', 'K_Y', 'C_R', 'G_Y', 'I_R', 'W_Y', 'h_R', 'f_Y', 'b_R', 'h_Y', 'U_R', 'a_Y', 'e_R', 'M_Y', 'D_R', 'F_Y', 'N_R', 'Q_Y', 'Z_R', 'c_Y', 'J_R', 'S_Y', 'J_R', 'M_Y', 'F_R', 'b_Y', 'L_R', 'I_Y', 'L_R', 'J_Y', 'U_R', 'S_Y', 'H_R', 'C_Y', 'i_R', 'U_Y', 'D_R', 'J_Y', 'c_R', 'h_Y', 'R_R', 'H_Y', 'O_R', 'i_Y', 'B_R', 'i_Y', 'G_R', 'Y_Y', 'M_R', 'd_Y', 'F_R', 'T_Y', 'P_R', 'b_Y', 'U_R', 'I_Y', 'J_R', 'E_Y', 'd_R', 'V_Y', 'E_R', 'f_Y', 'b_R', 'L_Y', 'b_R', 'g_Y', 'F_R', 'V_Y', 'b_R', 'J_Y', 'L_R', 'S_Y', 'U_R', 'W_Y', 'f_R', 'B_Y', 'e_R', 'M_Y', 'T_R', 'D_Y', 'F_R', 'L_Y', 'V_R', 'L_Y', 'f_R', 'C_Y', 'L_R', 'A_Y', 'D_R', 'S_Y', 'g_R', 'A_Y', 'h_R', 'c_Y', 'V_R', 'M_Y', 'S_R', 'T_Y', 'c_R', 'Z_Y', 'c_R', 'c_Y', 'V_R', 'P_Y', 'e_R', 'P_Y', 'I_R', 'e_Y', 'M_R', 'B_Y', 'S_R', 'g_Y', 'H_R', 'c_Y', 'N_R', 'I_Y', 'T_R', 'O_Y', 'f_R', 'T_Y', 'F_R', 'M_Y', 'H_R', 'a_Y', 'f_R', 'd_Y', 'a_R', 'H_Y', 'c_R', 'a_Y', 'a_R', 'S_Y', 'C_R', 'a_Y', 'c_R', 'Z_Y', 'K_R', 'b_Y', 'B_R', 'h_Y', 'E_R', 'X_Y', 'R_R', 'Q_Y', 'A_R', 'V_Y', 'H_R', 'V_Y', 'D_R', 'N_Y', 'D_R', 'K_Y', 'K_R', 'e_Y', 'X_R', 'H_Y', 'Y_R', 'g_Y', 'X_R', 'G_Y', 'V_R', 'M_Y', 'a_R', 'O_Y', 'K_R', 'a_Y', 'R_R', 'M_Y', 'g_R', 'Q_Y', 'S_R', 'b_Y', 'f_R', 'h_Y', 'U_R', 'P_Y', 'J_R', 'W_Y', 'd_R', 'J_Y', 'X_R', 'V_Y', 'Q_R', 'W_Y', 'I_R', 'W_Y', 'D_R', 'J_Y', 'X_R', 'Y_Y', 'C_R', 'f_Y', 'a_R', 'W_Y', 'C_R', 'L_Y', 'C_R', 'F_Y', 'a_R', 'E_Y', 'a_R', 'W_Y', 'R_R', 'V_Y', 'b_R', 'C_Y', 'c_R', 'h_Y', 'A_R', 'K_Y', 'Z_R', 'd_Y', 'U_R', 'K_Y', 'Q_R', 'U_Y', 'S_R', 'J_Y', 'F_R', 'E_Y', 'G_R', 'P_Y', 'W_R', 'H_Y', 'S_R', 'P_Y', 'E_R', 'M_Y', 'S_R', 'h_Y', 'L_R', 'L_Y', 'e_R', 'Q_Y', 'L_R', 'e_Y', 'c_R', 'E_Y', 'i_R', 'h_Y', 'X_R', 'Q_Y', 'I_R', 'c_Y', 'L_R', 'P_Y', 'H_R', 'a_Y', 'N_R', 'S_Y', 'a_R', 'h_Y', 'D_R', 'e_Y', 'h_R', 'S_Y', 'S_R', 'O_Y', 'i_R', 'U_Y', 'K_R', 'V_Y', 'O_R', 'L_Y', 'h_R', 'c_Y', 'f_R', 'V_Y', 'H_R', 'N_Y', 'B_R', 'R_Y', 'T_R', 'H_Y', 'J_R', 'I_Y', 'P_R', 'J_Y', 'T_R', 'E_Y', 'h_R', 'H_Y', 'h_R', 'a_Y', 'Z_R', 'O_Y', 'K_R', 'U_Y', 'U_R', 'O_Y', 'b_R', 'L_Y', 'J_R', 'U_Y', 'h_R', 'b_Y', 'd_R', 'C_Y', 'U_R', 'H_Y', 'X_R', 'c_Y', 'Y_R', 'Z_Y', 'g_R', 'K_Y', 'P_R', 'F_Y', 'R_R', 'C_Y', 'D_R', 'P_Y', 'g_R', 'O_Y', 'd_R', 'J_Y', 'e_R', 'Y_Y', 'M_R', 'G_Y', 'f_R', 'g_Y', 'J_R', 'U_Y', 'E_R', 'L_Y', 'B_R', 'f_Y', 'i_R', 'M_Y', 'U_R', 'd_Y', 'M_R', 'X_Y', 'I_R', 'P_Y', 'D_R', 'h_Y', 'V_R', 'V_Y', 'M_R', 'J_Y', 'h_R', 'X_Y', 'd_R', 'a_Y', 'X_R', 'e_Y', 'g_R', 'O_Y', 'a_R', 'b_Y', 'X_R', 'g_Y', 'g_R', 'N_Y', 'K_R', 'M_Y', 'O_R', 'd_Y', 'A_R', 'B_Y', 'G_R', 'I_Y', 'D_R', 'K_Y', 'H_R', 'i_Y', 'V_R', 'e_Y', 'L_R', 'H_Y', 'h_R', 'W_Y', 'E_R', 'G_Y', 'i_R', 'F_Y', 'Q_R', 'Y_Y', 'U_R', 'D_Y', 'Y_R', 'Z_Y', 'K_R', 'H_Y', 'R_R', 'X_Y', 'V_R', 'X_Y', 'W_R', 'Z_Y', 'C_R', 'O_Y', 'I_R', 'i_Y', 'S_R', 'G_Y', 'Z_R', 'G_Y', 'h_R', 'L_Y', 'X_R', 'c_Y', 'b_R', 'h_Y', 'A_R', 'Z_Y', 'i_R', 'I_Y', 'A_R', 'T_Y', 'h_R', 'I_Y', 'E_R', 'S_Y', 'U_R', 'S_Y', 'S_R', 'S_Y', 'h_R', 'h_Y', 'a_R', 'd_Y', 'V_R', 'L_Y', 'b_R', 'e_Y', 'Y_R', 'T_Y', 'J_R', 'U_Y', 'C_R', 'G_Y', 'A_R', 'g_Y', 'h_R', 'J_Y', 'f_R', 'K_Y', 'D_R', 'E_Y', 'U_R', 'M_Y', 'M_R', 'V_Y', 'f_R', 'i_Y', 'K_R', 'Z_Y', 'h_R', 'U_Y', 'e_R', 'i_Y', 'R_R', 'c_Y', 'E_R', 'J_Y', 'I_R', 'b_Y', 'B_R', 'S_Y', 'U_R', 'F_Y', 'B_R', 'b_Y', 'B_R', 'a_Y', 'g_R', 'D_Y', 'Y_R', 'E_Y', 'N_R', 'B_Y', 'M_R', 'i_Y', 'D_R', 'Q_Y', 'a_R', 'U_Y', 'N_R', 'h_Y', 'A_R', 'O_Y', 'R_R', 'Y_Y', 'i_R', 'g_Y', 'f_R', 'V_Y', 'L_R', 'c_Y', 'A_R', 'S_Y', 'B_R', 'I_Y', 'Y_R', 'V_Y', 'O_R', 'K_Y', 'd_R', 'T_Y', 'I_R', 'c_Y', 'R_R', 'V_Y', 'i_R', 'J_Y', 'V_R', 'd_Y', 'Z_R', 'E_Y', 'h_R', 'I_Y', 'L_R', 'L_Y', 'S_R', 'W_Y', 'B_R', 'T_Y', 'Q_R', 'W_Y', 'a_R', 'Y_Y', 'c_R', 'E_Y', 'H_R', 'B_Y', 'h_R', 'E_Y', 'Q_R', 'D_Y', 'A_R', 'S_Y', 'N_R', 'U_Y', 'O_R', 'B_Y', 'F_R', 'N_Y', 'd_R', 'L_Y', 'B_R', 'e_Y', 'C_R', 'Q_Y', 'B_R', 'Y_Y', 'K_R', 'g_Y', 'Z_R', 'O_Y', 'R_R', 'C_Y', 'a_R', 'Z_Y', 'b_R', 'E_Y', 'D_R', 'F_Y', 'S_R', 'D_Y', 'O_R', 'J_Y', 'N_R', 'N_Y', 'd_R', 'M_Y', 'Q_R', 'J_Y', 'a_R', 'C_Y', 'f_R', 'B_Y', 'V_R', 'Q_Y', 'e_R', 'J_Y', 'G_R', 'f_Y', 'b_R', 'Q_Y', 'D_R', 'D_Y', 'E_R', 'O_Y', 'X_R', 'X_Y', 'Z_R', 'H_Y', 'O_R', 'Y_Y', 'g_R', 'W_Y', 'Q_R', 'g_Y', 'g_R', 'B_Y', 'A_R', 'O_Y', 'P_R', 'I_Y', 'K_R', 'Z_Y', 'O_R', 'S_Y', 'B_R', 'e_Y', 'A_R', 'H_Y', 'A_R', 'Z_Y', 'P_R', 'h_Y'],8,35) == 'R'\n    assert candidate(['O_R', 'J_Y', 'R_R', 'c_Y', 'F_R', 'e_Y', 'D_R', 'F_Y', 'q_R', 'a_Y', 'q_R', 'O_Y', 'V_R', 'P_Y', 'l_R', 'j_Y', 'g_R', 'q_Y', 'Q_R', 'E_Y', 'n_R', 'R_Y', 'E_R', 'I_Y', 'p_R', 'i_Y', 'Z_R', 'M_Y', 'Q_R', 'H_Y', 'W_R', 'M_Y', 'd_R', 'p_Y', 'c_R', 'Z_Y', 'F_R', 'S_Y', 'Q_R', 'f_Y', 'F_R', 'R_Y', 'T_R', 'I_Y', 'S_R', 'V_Y', 'R_R', 'c_Y', 'D_R', 'p_Y', 'R_R', 'm_Y', 'c_R', 'i_Y', 'X_R', 'S_Y', 'a_R', 'l_Y', 'd_R', 'p_Y', 'b_R', 'Y_Y', 'S_R', 'T_Y', 'e_R', 'm_Y', 'e_R', 'A_Y', 'N_R', 'A_Y', 'I_R', 'V_Y', 'k_R', 'W_Y', 'q_R', 'Z_Y', 'L_R', 'c_Y', 'U_R', 'd_Y', 'P_R', 'e_Y', 'q_R', 'Q_Y', 'e_R', 'm_Y', 'G_R', 'N_Y', 'h_R', 'h_Y', 'c_R', 'A_Y', 'b_R', 'P_Y', 'V_R', 'm_Y', 'X_R', 'k_Y', 'P_R', 'a_Y', 'J_R', 'e_Y', 'h_R', 'Q_Y', 'd_R', 'd_Y', 'X_R', 'q_Y', 'B_R', 'C_Y', 'g_R', 'o_Y', 'L_R', 'T_Y', 'g_R', 'R_Y', 'j_R', 'Y_Y', 'B_R', 'V_Y', 'F_R', 'V_Y', 'L_R', 'F_Y', 'Q_R', 'n_Y', 'C_R', 'i_Y', 'p_R', 'T_Y', 'e_R', 'p_Y', 'F_R', 'L_Y', 'n_R', 'b_Y', 'b_R', 'Z_Y', 'o_R', 'G_Y', 'P_R', 'B_Y', 'b_R', 'g_Y', 'H_R', 'b_Y', 'a_R', 'd_Y', 'e_R', 'M_Y', 'q_R', 'd_Y', 'i_R', 'L_Y', 'C_R', 'd_Y', 'M_R', 'j_Y', 'c_R', 'A_Y', 'a_R', 'j_Y', 'O_R', 'M_Y', 'L_R', 'i_Y', 'L_R', 'J_Y', 'G_R', 'g_Y', 'H_R', 'J_Y', 'R_R', 'J_Y', 'm_R', 'E_Y', 'e_R', 'I_Y', 'K_R', 'i_Y', 'a_R', 'q_Y', 'j_R', 'M_Y', 'a_R', 'g_Y', 'G_R', 'c_Y', 'R_R', 'Z_Y', 'I_R', 'Y_Y', 'n_R', 'c_Y', 'e_R', 'E_Y', 'X_R', 'U_Y', 'N_R', 'Q_Y', 'F_R', 'U_Y', 'S_R', 'C_Y', 'b_R', 'c_Y', 'E_R', 'N_Y', 'g_R', 'k_Y', 'B_R', 'S_Y', 'n_R', 'M_Y', 'V_R', 'a_Y', 'D_R', 'T_Y', 'b_R', 'i_Y', 'p_R', 'I_Y', 'm_R', 'c_Y', 'G_R', 'q_Y', 'V_R', 'j_Y', 'p_R', 'p_Y', 'i_R', 'N_Y', 'G_R', 'l_Y', 'N_R', 'c_Y', 'Q_R', 'O_Y', 'n_R', 'K_Y', 'K_R', 'X_Y', 'G_R', 'B_Y', 'c_R', 'M_Y', 'B_R', 'o_Y', 'A_R', 'q_Y', 'O_R', 'F_Y', 'C_R', 'I_Y', 'B_R', 'Z_Y', 'W_R', 'j_Y', 'i_R', 'l_Y', 'n_R', 'E_Y', 'W_R', 'X_Y', 'Z_R', 'j_Y', 'N_R', 'f_Y', 'm_R', 'E_Y', 'n_R', 'L_Y', 'C_R', 'M_Y', 'q_R', 'e_Y', 'N_R', 'j_Y', 'o_R', 'o_Y', 'D_R', 'O_Y', 'S_R', 'H_Y', 'C_R', 'R_Y', 'Q_R', 'J_Y', 'X_R', 'L_Y', 'D_R', 'D_Y', 'c_R', 'I_Y', 'O_R', 'n_Y', 'H_R', 'a_Y', 'c_R', 'g_Y', 'H_R', 'R_Y', 'i_R', 'b_Y', 'e_R', 'm_Y', 'g_R', 'G_Y', 'm_R', 'q_Y', 'm_R', 'p_Y', 'W_R', 'g_Y', 'G_R', 'Q_Y', 'Y_R', 'K_Y', 'f_R', 'o_Y', 'A_R', 'a_Y', 'p_R', 'E_Y', 'B_R', 'b_Y', 'l_R', 'c_Y', 'T_R', 'V_Y', 'X_R', 'j_Y', 'Z_R', 'e_Y', 'Q_R', 'A_Y', 'm_R', 'P_Y', 'l_R', 'i_Y', 'U_R', 'R_Y', 'O_R', 'R_Y', 'R_R', 'Z_Y', 'A_R', 'g_Y', 'X_R', 'E_Y', 'p_R', 'l_Y', 'D_R', 'b_Y', 'e_R', 'a_Y', 'O_R', 'Q_Y', 'M_R', 'L_Y', 'D_R', 'f_Y', 'n_R', 'm_Y', 'q_R', 'U_Y', 'g_R', 'A_Y', 'J_R', 'j_Y', 'C_R', 'b_Y', 'o_R', 'e_Y', 'I_R', 'C_Y', 'J_R', 'd_Y', 'V_R', 'Z_Y', 'G_R', 'B_Y', 'i_R', 'b_Y', 'E_R', 'E_Y', 'c_R', 'd_Y', 'f_R', 'F_Y', 'C_R', 'Q_Y', 'U_R', 'X_Y', 'l_R', 'R_Y', 'e_R', 'Q_Y', 'Q_R', 'B_Y', 'C_R', 'g_Y', 'I_R', 'K_Y', 'h_R', 'R_Y', 'L_R', 'S_Y', 'K_R', 'Z_Y', 'W_R', 'S_Y', 'L_R', 'B_Y', 'C_R', 'm_Y', 'H_R', 'S_Y', 'V_R', 'O_Y', 'd_R', 'R_Y', 'k_R', 'K_Y', 'L_R', 'k_Y', 'm_R', 'L_Y', 'C_R', 'J_Y', 'c_R', 'F_Y', 'R_R', 'g_Y', 'U_R', 'n_Y', 'X_R', 'F_Y', 'M_R', 'j_Y', 'f_R', 'F_Y', 'b_R', 'l_Y', 'M_R', 'X_Y', 'B_R', 'j_Y', 'j_R', 'e_Y', 'L_R', 'm_Y', 'K_R', 'V_Y', 'n_R', 'A_Y', 'N_R', 'M_Y', 'Y_R', 'U_Y', 'h_R', 'T_Y', 'X_R', 'e_Y', 'E_R', 'i_Y', 'p_R', 'C_Y', 'A_R', 'J_Y', 'W_R', 'n_Y', 'c_R', 'U_Y', 'a_R', 'g_Y', 'O_R', 'n_Y', 'I_R', 'l_Y', 'L_R', 'o_Y', 'e_R', 'd_Y', 'L_R', 'p_Y', 'A_R', 'l_Y', 'I_R', 'Z_Y', 'D_R', 'P_Y', 'C_R', 'M_Y', 'Q_R', 'j_Y', 'D_R', 'I_Y', 'M_R', 'N_Y', 'p_R', 'c_Y', 'E_R', 'I_Y', 'e_R', 'D_Y', 'S_R', 'i_Y', 'b_R', 'U_Y', 'M_R', 'O_Y', 'Q_R', 'E_Y', 'I_R', 'O_Y', 'H_R', 'T_Y', 'p_R', 'P_Y', 'l_R', 'n_Y', 'I_R', 'c_Y', 'Y_R', 'M_Y', 'E_R', 'K_Y', 'h_R', 'n_Y', 'l_R', 'q_Y', 'a_R', 'm_Y', 'I_R', 'A_Y', 'U_R', 'C_Y', 'B_R', 'F_Y', 'l_R', 'D_Y', 'n_R', 'q_Y', 'Z_R', 'Y_Y', 'h_R', 'N_Y', 'A_R', 'F_Y', 'N_R', 'q_Y', 'R_R', 'e_Y', 'P_R', 'N_Y', 'd_R', 'j_Y', 'C_R', 'J_Y', 'R_R', 'L_Y', 'p_R', 'J_Y', 'B_R', 'i_Y', 'B_R', 'l_Y', 'D_R', 'V_Y', 'f_R', 'b_Y', 'M_R', 'o_Y', 'B_R', 'U_Y', 'g_R', 'l_Y', 'Y_R', 'l_Y', 'I_R', 'V_Y', 'b_R', 'o_Y', 'Q_R', 'G_Y', 'b_R', 'J_Y', 'o_R', 'B_Y', 'q_R', 'R_Y', 'B_R', 'B_Y', 'T_R', 'Y_Y', 'e_R', 'e_Y', 'Q_R', 'K_Y', 'e_R', 'N_Y', 'R_R', 'a_Y', 'D_R', 'X_Y', 'N_R', 'n_Y', 'Q_R', 'U_Y', 'd_R', 'g_Y', 'R_R', 'j_Y', 'W_R', 'G_Y', 'h_R', 'C_Y', 'a_R', 'i_Y', 'I_R', 'G_Y', 'P_R', 'E_Y', 'e_R', 'm_Y', 'a_R', 'p_Y', 'l_R', 'X_Y', 'O_R', 'N_Y', 'G_R', 'M_Y', 'E_R', 'd_Y', 'X_R', 'Z_Y', 'H_R', 'i_Y', 'D_R', 'C_Y', 'S_R', 'Q_Y', 'Q_R', 'H_Y', 'o_R', 'B_Y', 'H_R', 'N_Y', 'L_R', 'A_Y', 'd_R', 'k_Y', 'U_R', 'U_Y', 'H_R', 'B_Y', 'Q_R', 'j_Y', 'S_R', 'S_Y', 'N_R', 'L_Y', 'h_R', 'K_Y', 'o_R', 'e_Y', 'e_R', 'V_Y', 'G_R', 'i_Y', 'n_R', 'L_Y', 'D_R', 'L_Y', 'M_R', 'E_Y', 'd_R', 'K_Y', 'd_R', 'W_Y', 'E_R', 'p_Y', 'q_R', 'R_Y', 'o_R', 'Z_Y', 'N_R', 'p_Y', 'U_R', 'h_Y', 'g_R', 'h_Y', 'H_R', 'd_Y', 'a_R', 'n_Y', 'M_R', 'X_Y', 'H_R', 'f_Y', 'F_R', 'H_Y', 'Z_R', 'Z_Y', 'n_R', 'R_Y', 'F_R', 'c_Y', 'k_R', 'Z_Y', 'c_R', 'a_Y', 'A_R', 'a_Y', 'T_R', 'q_Y', 'q_R', 'Y_Y', 'N_R', 'J_Y', 'H_R', 'd_Y', 'B_R', 'H_Y', 'R_R', 'k_Y', 'g_R', 'h_Y', 'a_R', 'X_Y', 'C_R', 'Y_Y', 'X_R', 'T_Y', 'C_R', 'i_Y', 'Q_R', 'h_Y', 'j_R', 'o_Y', 'D_R', 'c_Y', 'M_R', 'U_Y', 'o_R', 'p_Y', 'b_R', 'i_Y', 'T_R', 'F_Y', 'c_R', 'U_Y', 'O_R', 'j_Y', 'n_R', 'N_Y', 'V_R', 'A_Y', 'c_R', 'J_Y', 'U_R', 'L_Y', 'S_R', 'H_Y', 'U_R', 'S_Y', 'R_R', 'K_Y', 'T_R', 'T_Y', 'X_R', 'l_Y', 'A_R', 'P_Y', 'D_R', 'i_Y', 'I_R', 'l_Y', 'M_R', 'i_Y', 'P_R', 'Y_Y', 'T_R', 'M_Y', 'L_R', 'H_Y', 'M_R', 'B_Y', 'V_R', 'a_Y', 'H_R', 'k_Y', 'A_R', 'i_Y', 'W_R', 'Q_Y', 'm_R', 'b_Y', 'n_R', 'T_Y', 'p_R', 'H_Y', 'V_R', 'B_Y', 'P_R', 'J_Y', 'W_R', 'p_Y', 'K_R', 'M_Y', 'I_R', 'Z_Y', 'V_R', 'c_Y', 'L_R', 'm_Y', 'i_R', 'I_Y', 'f_R', 'c_Y', 'T_R', 'F_Y', 'K_R', 'R_Y', 'X_R', 'N_Y', 'l_R', 'I_Y', 'M_R', 'Y_Y', 'G_R', 'J_Y', 'h_R', 'F_Y', 'o_R', 'R_Y', 'B_R', 'L_Y', 'H_R', 'o_Y', 'Y_R', 'W_Y', 'f_R', 'T_Y', 'H_R', 'I_Y', 'Q_R', 'a_Y', 'E_R', 'm_Y', 'i_R', 'N_Y', 'k_R', 'O_Y', 'Y_R', 'd_Y', 'U_R', 'K_Y', 'O_R', 'h_Y', 'm_R', 'I_Y', 'n_R', 'k_Y', 'J_R', 'K_Y', 'p_R', 'N_Y', 'T_R', 'k_Y', 'M_R', 'F_Y', 'e_R', 'o_Y', 'X_R', 'R_Y', 'N_R', 'W_Y', 'f_R', 'Q_Y', 'g_R', 'd_Y', 'E_R', 'h_Y', 'V_R', 'k_Y', 'i_R', 'i_Y', 'a_R', 'P_Y', 'k_R', 'f_Y', 'Y_R', 'C_Y', 'e_R', 'p_Y', 'k_R', 'h_Y', 'h_R', 'A_Y', 'O_R', 'M_Y', 'h_R', 'A_Y', 'g_R', 'X_Y', 'C_R', 'd_Y', 'R_R', 'Q_Y', 'B_R', 'T_Y', 'S_R', 'M_Y', 'a_R', 'S_Y', 'p_R', 'a_Y', 'W_R', 'd_Y', 'j_R', 'q_Y', 'j_R', 'W_Y', 'U_R', 'D_Y', 'g_R', 'H_Y', 'g_R', 'I_Y', 'b_R', 'a_Y', 'p_R', 'N_Y', 'A_R', 'N_Y', 'g_R', 'I_Y', 'q_R', 'f_Y', 'f_R', 'V_Y', 'm_R', 'O_Y', 'a_R', 'e_Y', 'Q_R', 'n_Y', 'b_R', 'E_Y', 'j_R', 'n_Y', 'a_R', 'E_Y', 'T_R', 'g_Y', 'p_R', 'Q_Y', 'S_R', 'C_Y', 'g_R', 'd_Y', 'q_R', 'q_Y', 'o_R', 'q_Y', 'q_R', 'p_Y', 'J_R', 'k_Y', 'D_R', 'Q_Y', 'a_R', 'L_Y', 'b_R', 'i_Y', 'O_R', 'E_Y', 'Q_R', 'Z_Y', 'l_R', 'I_Y', 'R_R', 'U_Y', 'h_R', 'k_Y', 'N_R', 'f_Y', 'I_R', 'M_Y', 'R_R', 'C_Y', 'j_R', 'S_Y', 'P_R', 'I_Y', 'P_R', 'F_Y', 'q_R', 'J_Y', 'S_R', 'W_Y', 'l_R', 'g_Y', 'd_R', 'J_Y', 'J_R', 'T_Y', 'U_R', 'D_Y', 'e_R', 'a_Y', 'O_R', 'A_Y', 'i_R', 'k_Y', 'J_R', 'X_Y', 'B_R', 'H_Y', 'g_R', 'E_Y', 'd_R', 'h_Y', 'I_R', 'e_Y', 'k_R', 'U_Y', 'K_R', 'p_Y', 'G_R', 'k_Y', 'H_R', 'V_Y', 'I_R', 'g_Y', 'j_R', 'S_Y', 'H_R', 'g_Y', 'S_R', 'N_Y', 'g_R', 'p_Y', 'K_R', 'h_Y', 'i_R', 'e_Y', 'X_R', 'F_Y', 'b_R', 'A_Y', 'c_R', 'G_Y', 'O_R', 'B_Y', 'C_R', 'B_Y', 'E_R', 'P_Y', 'S_R', 'E_Y', 'E_R', 'e_Y', 'U_R', 'T_Y', 'p_R', 'T_Y', 'd_R', 'Y_Y', 'E_R', 'H_Y', 'O_R', 'P_Y', 'W_R', 'k_Y', 'W_R', 'S_Y', 'A_R', 'Q_Y', 'q_R', 'K_Y', 'g_R', 'F_Y', 'h_R', 'h_Y', 'P_R', 'N_Y', 'W_R', 'S_Y', 'Q_R', 'o_Y', 'O_R', 'g_Y', 'm_R', 'a_Y', 'C_R', 'H_Y', 'P_R', 'W_Y', 'I_R', 'd_Y', 'M_R', 'K_Y', 'F_R', 'R_Y', 'g_R', 'D_Y', 'H_R', 'l_Y', 'h_R', 'A_Y', 'W_R', 'P_Y', 'I_R', 'C_Y', 'o_R', 'j_Y', 'J_R', 'A_Y', 'R_R', 'Q_Y', 'q_R', 'a_Y', 'o_R', 'P_Y', 'D_R', 'Y_Y', 'i_R', 'g_Y', 'R_R', 'q_Y', 'Z_R', 'K_Y', 'Q_R', 'B_Y', 'Z_R', 'E_Y', 'I_R', 'H_Y', 'S_R', 'q_Y', 'o_R', 'P_Y', 'a_R', 'a_Y', 'O_R', 'E_Y', 'R_R', 'L_Y', 'Z_R', 'K_Y', 'J_R', 'G_Y', 'W_R', 'T_Y', 'E_R', 'B_Y', 'N_R', 'U_Y', 'R_R', 'd_Y', 'g_R', 'A_Y', 'P_R', 'o_Y', 'Q_R', 'H_Y', 'W_R', 'F_Y', 'p_R', 'R_Y', 'I_R', 'C_Y', 'R_R', 'g_Y', 'K_R', 'E_Y', 'R_R', 'd_Y', 'S_R', 'V_Y', 'R_R', 'Y_Y', 'S_R', 'f_Y', 'L_R', 'A_Y', 'X_R', 'Y_Y', 'L_R', 'b_Y', 'c_R', 'Q_Y', 'B_R', 'I_Y', 'b_R', 'L_Y', 'k_R', 'l_Y', 'l_R', 'g_Y', 'N_R', 'f_Y', 'P_R', 'j_Y', 'q_R', 'B_Y', 'a_R', 'K_Y', 'g_R', 'H_Y', 'H_R', 'B_Y', 'A_R', 'W_Y', 'W_R', 'G_Y', 'H_R', 'X_Y', 'H_R', 'a_Y', 'R_R', 'X_Y', 'L_R', 'e_Y', 'V_R', 'J_Y', 'p_R', 'l_Y', 'm_R', 'E_Y', 'N_R', 'G_Y', 'M_R', 'n_Y', 'X_R', 'A_Y', 'O_R', 'd_Y', 'c_R', 'p_Y', 'I_R', 'G_Y', 'S_R', 'R_Y'],3,43) == 'Y'\n    assert candidate(['C_R', 'p_Y', 'a_B', 'Q_T', 's_S', 'I_R', 'Z_Y', 'a_B', 'c_T', 'd_S', 'O_R', 'C_Y', 'M_B', 'Q_T', 'O_S', 'I_R', 'U_Y', 'J_B', 'K_T', 'V_S', 'i_R', 'o_Y', 'r_B', 'H_T', 'I_S', 'C_R', 'n_Y', 'W_B', 'G_T', 'j_S', 'p_R', 'm_Y', 'Y_B', 'b_T', 'I_S', 'B_R', 'O_Y', 'n_B', 'w_T', 'w_S', 'c_R', 'l_Y', 'Z_B', 'c_T', 'E_S', 'k_R', 'w_Y', 'R_B', 'c_T', 'p_S', 'C_R', 'D_Y', 'C_B', 'c_T', 'D_S', 'J_R', 'H_Y', 'P_B', 'g_T', 'H_S', 'F_R', 'q_Y', 'f_B', 'p_T', 'n_S', 'Q_R', 'w_Y', 'v_B', 'u_T', 'H_S', 'b_R', 'F_Y', 'a_B', 'Q_T', 'N_S', 'S_R', 't_Y', 'Z_B', 'p_T', 'b_S', 'w_R', 'H_Y', 'e_B', 'S_T', 'h_S', 'h_R', 'Z_Y', 'f_B', 'k_T', 'v_S', 'v_R', 'a_Y', 'm_B', 'G_T', 't_S', 't_R', 'J_Y', 'c_B', 'C_T', 'N_S', 'w_R', 't_Y', 't_B', 'g_T', 'f_S', 'P_R', 'J_Y', 's_B', 'B_T', 'j_S', 't_R', 'N_Y', 'B_B', 'Z_T', 'd_S', 'l_R', 'c_Y', 'Z_B', 'm_T', 'I_S', 'j_R', 'I_Y', 'a_B', 'C_T', 'J_S', 'a_R', 'L_Y', 'i_B', 's_T', 'I_S', 'A_R', 'Q_Y', 'w_B', 'k_T', 'e_S', 'D_R', 's_Y', 't_B', 'c_T', 'V_S', 'K_R', 'K_Y', 'M_B', 'q_T', 'G_S', 'Z_R', 't_Y', 'U_B', 'r_T', 'u_S', 'D_R', 'W_Y', 'M_B', 'N_T', 'i_S', 'I_R', 's_Y', 'a_B', 'I_T', 'p_S', 'A_R', 's_Y', 'g_B', 'I_T', 'Q_S', 'q_R', 'a_Y', 'D_B', 'W_T', 'a_S', 'K_R', 'Z_Y', 'l_B', 'A_T', 't_S', 'a_R', 'F_Y', 'r_B', 'w_T', 'B_S', 'f_R', 'p_Y', 'T_B', 'm_T', 'I_S', 'L_R', 'E_Y', 'q_B', 'U_T', 'G_S', 'F_R', 'i_Y', 'f_B', 'U_T', 'X_S', 'B_R', 'N_Y', 'D_B', 'v_T', 'c_S', 'H_R', 'H_Y', 'w_B', 'b_T', 'E_S', 'G_R', 'H_Y', 'Y_B', 'N_T', 'S_S', 'D_R', 'i_Y', 'Q_B', 'I_T', 'o_S', 'D_R', 'K_Y', 'd_B', 'o_T', 'l_S', 'O_R', 'R_Y', 'n_B', 'C_T', 'O_S', 'E_R', 'D_Y', 'K_B', 'c_T', 'C_S', 'o_R', 'X_Y', 'S_B', 'M_T', 'g_S', 'F_R', 'T_Y', 'p_B', 'D_T', 'e_S', 'Z_R', 'Q_Y', 'l_B', 'j_T', 'F_S', 'k_R', 'h_Y', 'S_B', 'C_T', 'f_S', 'd_R', 'F_Y', 'O_B', 'H_T', 'e_S', 'q_R', 'O_Y', 'i_B', 'G_T', 'I_S', 'c_R', 'M_Y', 'A_B', 'L_T', 'd_S', 'b_R', 'D_Y', 'S_B', 'b_T', 'Y_S', 's_R', 'Y_Y', 'r_B', 'J_T', 'p_S', 'q_R', 'b_Y', 'w_B', 'Z_T', 'D_S', 'F_R', 'U_Y', 'P_B', 'G_T', 'P_S', 'm_R', 'd_Y', 'H_B', 'O_T', 'F_S', 'O_R', 'e_Y', 'b_B', 'D_T', 'd_S', 'U_R', 'S_Y', 'P_B', 'm_T', 'M_S', 'a_R', 'f_Y', 'B_B', 'd_T', 'm_S', 'a_R', 'a_Y', 'V_B', 'i_T', 'u_S', 'H_R', 'B_Y', 'M_B', 'V_T', 'd_S', 'j_R', 'r_Y', 'Q_B', 'g_T', 'V_S', 'G_R', 'e_Y', 'D_B', 'Z_T', 'e_S', 'b_R', 'q_Y', 'A_B', 'S_T', 'K_S', 'e_R', 'h_Y', 'P_B', 'n_T', 'L_S', 'N_R', 'M_Y', 'I_B', 'O_T', 'N_S', 'p_R', 'n_Y', 'd_B', 'f_T', 'a_S', 'D_R', 'N_Y', 'J_B', 'O_T', 'c_S', 'd_R', 'i_Y', 'P_B', 's_T', 'b_S', 'u_R', 'U_Y', 'i_B', 'V_T', 'm_S', 'm_R', 'b_Y', 'N_B', 'A_T', 'C_S', 'Q_R', 'q_Y', 'n_B', 'K_T', 'B_S', 'c_R', 'Q_Y', 'n_B', 'n_T', 'P_S', 'v_R', 'Y_Y', 'W_B', 'r_T', 'q_S', 'O_R', 'C_Y', 'F_B', 'w_T', 'd_S', 'B_R', 'I_Y', 'u_B', 'U_T', 'P_S', 'A_R', 'd_Y', 'j_B', 'd_T', 'L_S', 'Z_R', 'j_Y', 'l_B', 'a_T', 'Q_S', 'w_R', 'R_Y', 'U_B', 'P_T', 'e_S', 'J_R', 'R_Y', 'n_B', 'w_T', 'a_S', 'v_R', 'U_Y', 'J_B', 'Q_T', 'I_S', 'q_R', 'f_Y', 'u_B', 'U_T', 'o_S', 'n_R', 'J_Y', 'f_B', 'Q_T', 'S_S', 'a_R', 'p_Y', 'h_B', 'R_T', 'F_S', 'N_R', 'j_Y', 'o_B', 'g_T', 'J_S', 'Q_R', 'G_Y', 'k_B', 'n_T', 'F_S', 'r_R', 'u_Y', 'f_B', 'O_T', 'w_S', 'J_R', 'Z_Y', 'T_B', 'Y_T', 'v_S', 'p_R', 'N_Y', 'D_B', 'h_T', 'e_S', 'g_R', 'A_Y', 'o_B', 'K_T', 'n_S', 'F_R', 'W_Y', 'o_B', 'o_T', 'r_S', 'd_R', 'G_Y', 'A_B', 'B_T', 'i_S', 'I_R', 'u_Y', 'S_B', 'l_T', 'V_S', 'b_R', 'L_Y', 'F_B', 'S_T', 'h_S', 'J_R', 'Z_Y', 's_B', 'd_T', 'a_S', 'Y_R', 'L_Y', 'E_B', 'v_T', 'N_S', 'Y_R', 'm_Y', 'd_B', 'j_T', 'C_S', 'O_R', 'b_Y', 'G_B', 'G_T', 'a_S', 'Y_R', 'N_Y', 'V_B', 'r_T', 'e_S', 'W_R', 'r_Y', 'O_B', 'G_T', 'p_S', 't_R', 'm_Y', 'N_B', 'j_T', 'o_S', 'N_R', 'a_Y', 'g_B', 'd_T', 'M_S', 'T_R', 'T_Y', 'B_B', 'T_T', 'J_S', 'm_R', 'Y_Y', 'N_B', 'A_T', 'f_S', 'u_R', 'a_Y', 'c_B', 'G_T', 'G_S', 'a_R', 'I_Y', 'b_B', 'W_T', 'T_S', 'w_R', 'n_Y', 'M_B', 'A_T', 'u_S', 'T_R', 'j_Y', 'W_B', 'd_T', 'I_S', 'u_R', 'Q_Y', 'A_B', 'C_T', 'v_S', 'e_R', 'i_Y', 'V_B', 'A_T', 's_S', 'n_R', 'f_Y', 'G_B', 'n_T', 'M_S', 'm_R', 'r_Y', 'W_B', 'K_T', 'E_S', 'd_R', 'N_Y', 'v_B', 'k_T', 'M_S', 'n_R', 'v_Y', 'b_B', 'L_T', 'k_S', 'l_R', 'G_Y', 'F_B', 'Y_T', 'k_S', 'e_R', 'A_Y', 'g_B', 'u_T', 'Q_S', 'F_R', 'W_Y', 'P_B', 'O_T', 'X_S', 'P_R', 'X_Y', 'n_B', 'b_T', 'O_S', 'G_R', 'D_Y', 'q_B', 'X_T', 'w_S', 'b_R', 'N_Y', 'u_B', 'U_T', 'q_S', 'l_R', 'U_Y', 'V_B', 'R_T', 'm_S', 'T_R', 'I_Y', 'C_B', 'q_T', 'E_S', 'f_R', 'l_Y', 'Z_B', 'l_T', 'h_S', 'h_R', 'V_Y', 'P_B', 'U_T', 'G_S', 'w_R', 'Q_Y', 'n_B', 'Z_T', 'A_S', 'E_R', 'A_Y', 'w_B', 'u_T', 'b_S', 'l_R', 'V_Y', 'I_B', 'j_T', 'Z_S', 'l_R', 'e_Y', 'L_B', 'k_T', 'q_S', 'l_R', 'A_Y', 'X_B', 'n_T', 'w_S', 'Q_R', 'I_Y', 'Q_B', 'S_T', 'L_S', 'm_R', 'H_Y', 'r_B', 'E_T', 'U_S', 'g_R', 'W_Y', 'D_B', 'V_T', 'l_S', 'e_R', 'M_Y', 'n_B', 'F_T', 'A_S', 'X_R', 's_Y', 'L_B', 'P_T', 'c_S', 'e_R', 'W_Y', 'e_B', 'l_T', 'Q_S', 'H_R', 'Q_Y', 'd_B', 'D_T', 'N_S', 'A_R', 'N_Y', 'b_B', 's_T', 'N_S', 'G_R', 'j_Y', 'O_B', 'q_T', 'd_S', 'p_R', 'm_Y', 'f_B', 'p_T', 'F_S', 'U_R', 'L_Y', 'F_B', 'j_T', 'K_S', 'J_R', 'I_Y', 'X_B', 'b_T', 'r_S', 'u_R', 'E_Y', 'l_B', 'E_T', 'U_S', 'a_R', 'S_Y', 'w_B', 'Z_T', 'Y_S', 'j_R', 'w_Y', 'M_B', 'k_T', 'F_S', 'W_R', 'Q_Y', 'b_B', 'g_T', 'g_S', 'T_R', 'i_Y', 'H_B', 'J_T', 'K_S', 'n_R', 'H_Y', 'T_B', 'E_T', 'U_S', 'N_R', 'h_Y', 'o_B', 'l_T', 'K_S', 'o_R', 'u_Y', 'm_B', 'V_T', 'n_S', 'u_R', 'j_Y', 'W_B', 'D_T', 'P_S', 'X_R', 'f_Y', 'Q_B', 't_T', 'q_S', 'V_R', 'o_Y', 'O_B', 'Y_T', 'A_S', 'c_R', 'W_Y', 'D_B', 'l_T', 'G_S', 'w_R', 'V_Y', 'G_B', 'D_T', 'p_S', 'R_R', 'J_Y', 'e_B', 'D_T', 'h_S', 'I_R', 'q_Y', 'K_B', 'Y_T', 'l_S', 'X_R', 'I_Y', 'I_B', 'R_T', 'F_S', 'U_R', 'L_Y', 'X_B', 'd_T', 'I_S', 'X_R', 'V_Y', 'Z_B', 'h_T', 'J_S', 'Z_R', 't_Y', 'K_B', 'c_T', 'd_S', 'Q_R', 'o_Y', 'g_B', 'i_T', 'm_S', 'd_R', 'T_Y', 'u_B', 'Y_T', 'H_S', 'p_R', 'c_Y', 'A_B', 'W_T', 'M_S', 'r_R', 'w_Y', 'D_B', 'j_T', 'w_S', 'b_R', 's_Y', 'K_B', 'c_T', 'T_S', 'Z_R', 'm_Y', 'U_B', 'O_T', 'F_S', 'u_R', 'J_Y', 'j_B', 'o_T', 'D_S', 'F_R', 'w_Y', 's_B', 'B_T', 'X_S', 'A_R', 'j_Y', 'j_B', 'q_T', 'B_S', 'A_R', 'T_Y', 'T_B', 'P_T', 'M_S', 'H_R', 'I_Y', 'd_B', 'a_T', 'U_S', 'H_R', 'N_Y', 'd_B', 'X_T', 'l_S', 'c_R', 'Y_Y', 'X_B', 'r_T', 'D_S', 'L_R', 'N_Y', 'B_B', 'f_T', 'W_S', 'a_R', 't_Y', 'Q_B', 'b_T', 'q_S', 'L_R', 'M_Y', 'd_B', 'a_T', 'L_S', 'e_R', 'N_Y', 'X_B', 'o_T', 'f_S', 'Y_R', 's_Y', 'j_B', 'Q_T', 'K_S', 'A_R', 'B_Y', 'J_B', 'X_T', 'k_S', 'Y_R', 'L_Y', 'O_B', 'o_T', 'm_S', 'f_R', 'N_Y', 'C_B', 'r_T', 'M_S', 'I_R', 'c_Y', 'A_B', 'H_T', 'P_S', 'E_R', 'L_Y', 'i_B', 'E_T', 'Y_S', 's_R', 'j_Y', 'e_B', 'D_T', 'F_S', 'M_R', 'A_Y', 'R_B', 'e_T', 'K_S', 'Q_R', 'V_Y', 'v_B', 'R_T', 'S_S', 'b_R', 'S_Y', 'C_B', 'o_T', 'a_S', 'a_R', 's_Y', 'l_B', 'O_T', 'g_S', 'O_R', 'G_Y', 'h_B', 'Q_T', 'W_S', 'f_R', 'I_Y', 'w_B', 'c_T', 'u_S', 'r_R', 'Q_Y', 'E_B', 'F_T', 'A_S', 'M_R', 'T_Y', 'Q_B', 'i_T', 'X_S', 'C_R', 'Q_Y', 'J_B', 'r_T', 'T_S', 't_R', 'G_Y', 't_B', 'p_T', 'h_S', 'f_R', 'i_Y', 'T_B', 'e_T', 'J_S', 'J_R', 'T_Y', 'd_B', 'h_T', 'Q_S', 'D_R', 'W_Y', 'r_B', 'Y_T', 'F_S', 't_R', 'W_Y', 'J_B', 'O_T', 'l_S', 'm_R', 'W_Y', 'b_B', 'T_T', 'b_S', 'L_R', 'a_Y', 'L_B', 'u_T', 's_S', 'B_R', 'v_Y', 'M_B', 'I_T', 'u_S', 'S_R', 'U_Y', 'l_B', 'P_T', 'd_S', 'g_R', 'M_Y', 'F_B', 'a_T', 'U_S', 'n_R', 'd_Y', 'w_B', 'B_T', 'j_S', 'w_R', 'D_Y', 'f_B', 'm_T', 'Z_S', 'J_R', 'H_Y', 'i_B', 'g_T', 'v_S', 'W_R', 'h_Y', 'P_B', 'u_T', 'q_S', 'N_R', 't_Y', 'V_B', 'Q_T', 'K_S', 'F_R', 'e_Y', 'I_B', 'v_T', 'r_S', 'I_R', 'K_Y', 'p_B', 'V_T', 'd_S', 'A_R', 'c_Y', 'c_B', 'B_T', 'E_S', 'j_R', 'E_Y', 'D_B', 'k_T', 'c_S', 'I_R', 'b_Y', 'v_B', 'u_T', 'j_S', 'a_R', 'V_Y', 'p_B', 'W_T', 'r_S', 'p_R', 'u_Y', 'R_B', 'n_T', 'P_S', 'q_R', 'b_Y', 'E_B', 'c_T', 'H_S', 'Y_R', 'w_Y', 'h_B', 'v_T', 'P_S', 'e_R', 'q_Y', 'i_B', 'K_T', 'F_S', 'Q_R', 'a_Y', 'O_B', 't_T', 'W_S', 'H_R', 'N_Y', 'c_B', 'u_T', 'O_S', 't_R', 'P_Y', 'r_B', 'k_T', 'g_S', 'w_R', 'g_Y', 'i_B', 'B_T', 'w_S', 'F_R', 'l_Y', 'u_B', 'i_T', 'G_S', 'g_R', 'b_Y', 'N_B', 'S_T', 'M_S', 'n_R', 'H_Y', 'w_B', 'E_T', 'G_S', 'k_R', 'm_Y', 'h_B', 'Y_T', 'v_S', 'b_R', 'g_Y', 'P_B', 'p_T', 'Y_S', 'Y_R', 'c_Y', 'Q_B', 'm_T', 'u_S', 'I_R', 's_Y', 'D_B', 'a_T', 'i_S', 'E_R', 'S_Y', 'P_B', 'l_T', 'Q_S', 'U_R', 'r_Y', 'A_B', 'F_T', 'E_S', 'r_R', 'h_Y', 'm_B', 'O_T', 'w_S', 'W_R', 'R_Y', 'R_B', 'O_T', 'C_S', 'v_R', 's_Y', 'K_B', 'P_T', 'I_S', 'b_R', 'L_Y', 'U_B', 'e_T', 'Q_S', 'E_R', 'd_Y', 'a_B', 'e_T', 'm_S', 'w_R', 'b_Y', 'j_B', 'd_T', 'O_S', 'G_R', 'Q_Y', 'j_B', 'a_T', 'c_S', 'S_R', 'D_Y', 'k_B', 't_T', 't_S', 'j_R', 'T_Y', 'O_B', 'v_T', 'N_S', 'w_R', 'v_Y', 'D_B', 'i_T', 'q_S', 'O_R', 'B_Y', 'N_B', 'T_T', 'l_S', 'K_R', 'o_Y', 'n_B', 'C_T', 'R_S', 'n_R', 'K_Y', 'C_B', 'h_T', 'p_S', 'f_R', 'W_Y', 'E_B', 'D_T', 'H_S', 'p_R', 'R_Y', 'Z_B', 'B_T', 'S_S', 'd_R', 'q_Y', 'r_B', 'k_T', 'F_S', 'p_R', 'S_Y', 'W_B', 'C_T', 'K_S', 'h_R', 'L_Y', 'D_B', 's_T', 'N_S', 'W_R', 'o_Y', 'D_B', 'D_T', 'v_S', 'Z_R', 'Z_Y', 'j_B', 'r_T', 'W_S', 'Q_R', 'N_Y', 'O_B', 'd_T', 'm_S', 'X_R', 'Z_Y', 'Y_B', 'v_T', 'B_S', 'Z_R', 'd_Y', 'V_B', 'A_T', 'm_S', 'E_R', 'P_Y', 's_B', 'S_T', 'K_S', 'u_R', 'q_Y', 'Q_B', 'U_T', 'T_S', 'e_R', 'I_Y', 'p_B', 'I_T', 'd_S', 'H_R', 'a_Y', 'a_B', 'H_T', 'V_S', 'b_R', 'l_Y', 'K_B', 'V_T', 'Q_S', 'q_R', 'e_Y', 'v_B', 'r_T', 'Q_S', 'P_R', 'F_Y', 'A_B', 'k_T', 'R_S', 'l_R', 'g_Y', 'X_B', 't_T', 'B_S', 'i_R', 'R_Y', 'p_B', 'r_T', 'e_S', 'q_R', 'W_Y', 'O_B', 'A_T', 'U_S', 'c_R', 'D_Y', 'e_B', 'S_T', 'i_S', 'g_R', 'g_Y', 'n_B', 'k_T', 'h_S', 'U_R', 'U_Y', 'g_B', 'r_T', 'K_S', 'k_R', 'o_Y', 'M_B', 'Q_T', 'a_S', 'P_R', 's_Y', 'i_B', 'U_T', 'R_S', 'r_R', 'F_Y', 'V_B', 'D_T', 'g_S', 'N_R', 'e_Y', 'E_B', 'S_T', 'h_S', 'm_R', 'q_Y', 'R_B', 'V_T', 'Q_S', 'l_R', 'Q_Y', 'w_B', 'U_T', 'v_S', 'h_R', 'Z_Y', 'f_B', 'c_T', 'Y_S', 'p_R', 'E_Y', 'U_B', 'b_T', 'A_S', 'o_R', 'D_Y', 'i_B', 'V_T', 'Q_S', 'b_R', 't_Y', 'd_B', 'Q_T', 'f_S', 'o_R', 'W_Y', 'i_B', 'C_T', 'u_S', 'E_R', 'X_Y', 's_B', 'J_T', 'L_S', 'C_R', 'm_Y', 'B_B', 'p_T', 'm_S', 'k_R', 'h_Y', 'D_B', 'a_T', 'Y_S', 'F_R', 'I_Y', 'q_B', 'q_T', 'M_S', 'b_R', 'S_Y', 'h_B', 'h_T', 'a_S', 'D_R', 'j_Y', 'F_B', 'Y_T', 'W_S', 'J_R', 'U_Y', 'X_B', 'a_T', 'l_S', 'a_R', 's_Y', 'I_B', 'M_T', 'h_S', 'v_R', 'v_Y', 'R_B', 'M_T', 'i_S', 'Y_R', 'w_Y', 'l_B', 'J_T', 'g_S', 'f_R', 'b_Y', 'B_B', 'Z_T', 'n_S', 'q_R', 'K_Y', 'c_B', 't_T', 'R_S', 'C_R', 'k_Y', 'Q_B'],5,49) == 'Y'\n\n","canonical_solution":"from itertools import compress\nfrom string import ascii_uppercase, ascii_lowercase\nD = {c:i for i,c in enumerate(ascii_uppercase + ascii_lowercase)}\n\ndef whoIsWinner(moves, con, sz):\n    def gen(i, j):\n        for x in range(1, con):\n            yield ((i, j-x), (i-x, j), (i+x, j), (i-x, j-x), (i+x, j+x), (i+x, j-x), (i-x, j+x))\n    \n    def check(i, j, p):\n        memo, count = [True]*7, [0]*7\n        for L in gen(i, j):\n            for x,(k,l) in enumerate(L):\n                memo[x] = memo[x] and 0 <= k < sz and 0 <= l < sz and grid[k][l] == p\n                count[x] += memo[x]\n            if not any(memo):\n                return max(count[0], count[1]+count[2], count[3]+count[4], count[5]+count[6])+1 >= con\n        return True\n    \n    if sz >= con <= len(moves):\n        grid = [[None]*sz for _ in range(sz)]\n        for move in moves:\n            i, p = D[move[0]], move[-1]\n            j = next(j for j,x in enumerate(grid[i]) if x is None)\n            if check(i, j, p): return p\n            grid[i][j] = p\n    return \"Draw\""}
{"task_id":3104,"prompt":"\"\"\"\n=====Problem statement====\n\nSanta puts all the presents into the huge sack. In order to let his reindeers rest a bit, he only takes as many reindeers with him as he is required to do. The others may take a nap.\n\nTwo reindeers are always required for the sleigh and Santa himself. Additionally he needs 1 reindeer per 30 presents. As you know, Santa has 8 reindeers in total, so he can deliver up to 180 presents at once (2 reindeers for Santa and the sleigh + 6 reindeers with 30 presents each).\n\nComplete the function `reindeers()`, which takes a number of presents and returns the minimum numbers of required reindeers. If the number of presents is too high, throw an error.\n\nExamles:\n\n```python\nreindeer(0) # must return 2\nreindeer(1) # must return 3\nreindeer(30) # must return 3\nreindeer(200) # must throw an error\n```\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil\ndef reindeer(presents):\n","entry_point":"reindeer","test":"def check(candidate):\n    assert candidate(0) == 2\n    assert candidate(1) == 3\n    assert candidate(5) == 3\n    assert candidate(30) == 3\n    assert candidate(31) == 4\n    assert candidate(60) == 4\n    assert candidate(61) == 5\n    assert candidate(90) == 5\n    assert candidate(91) == 6\n    assert candidate(120) == 6\n    assert candidate(121) == 7\n    assert candidate(150) == 7\n    assert candidate(151) == 8\n    assert candidate(180) == 8\n\n","canonical_solution":"from math import ceil\ndef reindeer(presents):\n  if presents > 180: raise ValueError(\"Too many presents\")\n  return ceil(presents \/ 30.0) + 2"}
{"task_id":3106,"prompt":"\"\"\"\n=====Problem statement====\n\nYou have a set of four (4) balls labeled with different numbers: ball_1 (1), ball_2 (2), ball_3 (3) and ball(4) and we have 3 equal boxes for distribute them. The possible combinations of the balls, without having empty boxes, are:\n\n```\n (1)            (2)        (3)(4)     \n______        ______       _______ \n    \n```\n\n```\n (1)           (2)(4)        (3)\n______         ______      ______\n  \n```\n\n```\n(1)(4)           (2)         (3)\n______          ______      ______\n\n```\n\n```\n  (1)           (2)(3)       (4)\n_______         _______     ______\n\n```\n\n```\n(1)(3)            (2)        (4)\n_______         _______     ______\n```\n\n```\n(1)(2)            (3)        (4)\n_______         _______     ______\n```\nWe have a total of **6** combinations.\n\nThink how many combinations you will have with two boxes instead of three. You will obtain **7** combinations.\n\nObviously, the four balls in only box will give only one possible combination (the four balls in the unique box). Another particular case is the four balls in four boxes having again one possible combination(Each box having one ball).\n\nWhat will be the reasonable result for a set of n elements with no boxes?\n\nThink to create a function that may calculate the amount of these combinations of a set of ```n``` elements in ```k``` boxes.\n\nYou do no not have to check the inputs type that will be always valid integers.\n\nThe code should detect the cases when ```k > n```, returning \"It cannot be possible!\". \n\nFeatures of the random tests:\n```\n1 <= k <= n <= 800\n```\nRuby version will be published soon.\n\"\"\"\n\n# ====== Solution ======\n\n# Stirling numbers of second kind\n# http:\/\/mathworld.wolfram.com\/StirlingNumberoftheSecondKind.html\n# S(n,k)=1\/(k!)sum_(i=0)^k(-1)^i(k; i)(k-i)^n\nfrom math import factorial as fact\n\ndef combs_non_empty_boxes(n,k):\n","entry_point":"combs_non_empty_boxes","test":"def check(candidate):\n    assert candidate(4,3) == 6\n    assert candidate(4,2) == 7\n    assert candidate(4,4) == 1\n    assert candidate(4,1) == 1\n    assert candidate(4,0) == 0\n    assert candidate(4,5) == 'It cannot be possible!'\n    assert candidate(20,8) == 15170932662679\n\n","canonical_solution":"# Stirling numbers of second kind\n# http:\/\/mathworld.wolfram.com\/StirlingNumberoftheSecondKind.html\n# S(n,k)=1\/(k!)sum_(i=0)^k(-1)^i(k; i)(k-i)^n\nfrom math import factorial as fact\n\ndef combs_non_empty_boxes(n,k):\n    if k<0 or k>n: return 'It cannot be possible!'\n    return sum([1,-1][i%2]*(k-i)**n*fact(k)\/\/(fact(k-i)*fact(i)) for i in range(k+1))\/\/fact(k)"}
{"task_id":3117,"prompt":"\"\"\"\n=====Problem statement====\n\nThe vowel substrings in the word `codewarriors` are `o,e,a,io`. The longest of these has a length of 2. Given a lowercase string that has alphabetic characters only (both vowels and consonants) and no spaces, return the length of the longest vowel substring.\nVowels are any of `aeiou`. \n\n\n```if:csharp\nDocumentation:\nKata.Solve Method (String)\n\nReturns the length of the greatest continuous vowel substring in a string.\n\nSyntax\n\n\npublic\nstatic\nint Solve(\nstring str\n  \u00a0\u00a0)\n  \n\n\nParameters\n\nstr\n\nType: System.String\nThe string to be processed.\n\nReturn Value\n\nType: System.Int32\n  The length of the greatest continuous vowel substring in str, or 0 if str contains no vowels.\n\n\nExceptions\n\n\n\nException\nCondition\n\nArgumentNullException\nstr is null.\n\n\n\n\n```\n\n\nGood luck!\n\nIf you like substring Katas, please try:\n\n[Non-even substrings](https:\/\/www.codewars.com\/kata\/59da47fa27ee00a8b90000b4)\n\n[Vowel-consonant lexicon](https:\/\/www.codewars.com\/kata\/59cf8bed1a68b75ffb000026)\n\"\"\"\n\n# ====== Solution ======\n\ndef solve(s):\n","entry_point":"solve","test":"def check(candidate):\n    assert candidate('codewarriors') == 2\n    assert candidate('suoidea') == 3\n    assert candidate('ultrarevolutionariees') == 3\n    assert candidate('strengthlessnesses') == 1\n    assert candidate('cuboideonavicuare') == 2\n    assert candidate('chrononhotonthuooaos') == 5\n    assert candidate('iiihoovaeaaaoougjyaw') == 8\n\n","canonical_solution":"def solve(s):\n    return max(map(len, ''.join(c if c in 'aeiou' else ' ' for c in s).split()))"}
{"task_id":3118,"prompt":"\"\"\"\n=====Problem statement====\n\n###Lucky number\n\nWrite a function to find if a number is lucky or not. If the sum of all digits is 0 or multiple of 9 then the number is lucky.\n\n`1892376 => 1+8+9+2+3+7+6 = 36`. 36 is divisble by 9, hence number is lucky.\n\n\nFunction will return `true` for lucky numbers and `false` for others.\n\"\"\"\n\n# ====== Solution ======\n\ndef is_lucky(n):\n","entry_point":"is_lucky","test":"def check(candidate):\n    assert candidate(1892376) == True\n    assert candidate(189237) == False\n    assert candidate(18922314324324234423437) == False\n    assert candidate(189223141324324234423437) == True\n    assert candidate(1892231413243242344321432142343423437) == True\n    assert candidate(0) == True\n\n","canonical_solution":"def is_lucky(n):\n    return n % 9 == 0"}
{"task_id":3132,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function\n```python\nalternate_sort(l)\n```\nthat combines the elements of an array by sorting the elements ascending by their **absolute value** and outputs negative and non-negative integers alternatingly (starting with the negative value, if any).\n\nE.g.\n```python\nalternate_sort([5, -42, 2, -3, -4, 8, -9,]) == [-3, 2, -4, 5, -9, 8, -42]\nalternate_sort([5, -42, 2, -3, -4, 8, 9]) == [-3, 2, -4, 5, -42, 8, 9]\nalternate_sort([5, 2, -3, -4, 8, -9]) == [-3, 2, -4, 5, -9, 8]\nalternate_sort([5, 2, 9, 3, 8, 4]) == [2, 3, 4, 5, 8, 9]\n```\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import chain, zip_longest\n\ndef alternate_sort(l):\n","entry_point":"alternate_sort","test":"def check(candidate):\n    assert candidate([5, 2, -3, -9, -4, 8]) == [-3, 2, -4, 5, -9, 8]\n    assert candidate([5, -42, 2, -3, -4, 8, 9]) == [-3, 2, -4, 5, -42, 8, 9]\n    assert candidate([5, -42, 8, 2, -3, -4, 9]) == [-3, 2, -4, 5, -42, 8, 9]\n    assert candidate([5, -42, -8, 2, -3, -4, -9]) == [-3, 2, -4, 5, -8, -9, -42]\n    assert candidate([5, 2, 3, 4, 8, 9]) == [2, 3, 4, 5, 8, 9]\n    assert candidate([-5, -2, -3, -4, -8, -9]) == [-2, -3, -4, -5, -8, -9]\n    assert candidate([-5, -2, 3, 4, -8, 0, -9]) == [-2, 0, -5, 3, -8, 4, -9]\n    assert candidate([-5, -2, 3, 9, 4, -2, -8, 0, 9, -9]) == [-2, 0, -2, 3, -5, 4, -8, 9, -9, 9]\n\n","canonical_solution":"from itertools import chain, zip_longest\n\ndef alternate_sort(l):\n    l=sorted(l,key=abs)\n    p,n=[n for n in l if n>=0],[n for n in l if n<0]\n    return [n for n in chain(*zip_longest(n,p)) if n is not None]"}
{"task_id":3135,"prompt":"\"\"\"\n=====Problem statement====\n\nTwo moving objects A and B are moving accross the same orbit (those can be anything: two planets, two satellites, two spaceships,two flying saucers, or spiderman with batman if you prefer).\nIf the two objects start to move from the same point and the orbit is circular, write a function that gives the time the two objects will meet again, given the time the objects A and B need to go through a full orbit, Ta and Tb respectively, and the radius of the orbit r. \nAs there can't be negative time, the sign of Ta and Tb, is an indication of the direction in which the object moving: positive for clockwise and negative for anti-clockwise.\n\nThe function will return a string that gives the time, in two decimal points.\nTa and Tb will have the same unit of measurement so you should not expect it in the solution. \n\nHint: Use angular velocity \"w\" rather than the classical \"u\".\n\"\"\"\n\n# ====== Solution ======\n\ndef meeting_time(Ta, Tb, r):\n","entry_point":"meeting_time","test":"def check(candidate):\n    assert candidate(12,15,5) == '60.00'\n    assert candidate(12,-15,6) == '6.67'\n    assert candidate(-14,-5,5) == '7.78'\n    assert candidate(23,16,5) == '52.57'\n    assert candidate(0,0,7) == '0.00'\n    assert candidate(12,0,10) == '12.00'\n    assert candidate(0,15,17) == '15.00'\n    assert candidate(-24,0,10) == '24.00'\n    assert candidate(0,-18,14) == '18.00'\n    assert candidate(32,-14,14) == '9.74'\n\n","canonical_solution":"def meeting_time(Ta, Tb, r):\n    if Ta == 0:\n        return \"{:.2f}\".format(abs(Tb))\n    elif Tb == 0:\n        return \"{:.2f}\".format(abs(Ta))\n    else:\n        return \"{:.2f}\".format(abs(Ta * Tb \/ (Tb - Ta)))"}
{"task_id":3142,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that removes every lone 9 that is inbetween 7s.\n\n```python\nseven_ate9('79712312') => '7712312'\nseven_ate9('79797') => '777'\n```\n\nInput: String\nOutput: String\n\"\"\"\n\n# ====== Solution ======\n\ndef seven_ate9(str_):\n","entry_point":"seven_ate9","test":"def check(candidate):\n    assert candidate('165561786121789797') == '16556178612178977'\n    assert candidate('797') == '77'\n    assert candidate('7979797') == '7777'\n    assert candidate('16797') == '1677'\n    assert candidate('77') == '77'\n    assert candidate('7927') == '7927'\n    assert candidate('1779') == '1779'\n    assert candidate('a779') == 'a779'\n    assert candidate('17797a') == '1777a'\n    assert candidate('797 9 7') == '77 9 7'\n\n","canonical_solution":"def seven_ate9(str_):\n   while str_.find('797') != -1:\n       str_ = str_.replace('797','77')\n   return str_"}
{"task_id":3149,"prompt":"\"\"\"\n=====Problem statement====\n\nThe sports centre needs repair. Vandals have been kicking balls so hard into the roof that some of the tiles have started sticking up. The roof is represented by r.\n\nAs a quick fix, the committee have decided to place another old roof over the top, if they can find one that fits. This is your job.\n\nA 'new' roof (f) will fit if it currently has a hole in it at the location where the old roof has a tile sticking up.\n\nSticking up tiles are represented by either '\\\\' or '\/'. Holes in the 'new' roof are represented by spaces (' '). Any other character can not go over a sticking up tile.\n\nReturn true if the new roof fits, false if it does not.\n\"\"\"\n\n# ====== Solution ======\n\ndef roof_fix(new, old):\n","entry_point":"roof_fix","test":"def check(candidate):\n    assert candidate('  l   f l k djmi k','___\\_____\/\/_____\/_') == False\n    assert candidate('    ikm il  h  llmmc   a i','__\\_______________________') == True\n    assert candidate('   h c ','__\/____') == True\n    assert candidate('q h','_\/_') == True\n    assert candidate(' cg dg   em  lfh cdam','_______\/____\\_____\/_\/') == False\n\n","canonical_solution":"def roof_fix(new, old):\n    return all(patch == ' ' for patch, tile in zip(new, old) if tile in '\\\/')"}
{"task_id":3153,"prompt":"\"\"\"\n=====Problem statement====\n\nLet's imagine we have a popular online RPG. A player begins with a score of 0 in class E5. A1 is the highest level a player can achieve.\n\nNow let's say the players wants to rank up to class E4. To do so the player needs to achieve at least 100 points to enter the qualifying stage.\n\nWrite a script that will check to see if the player has achieved at least 100 points in his class. If so, he enters the qualifying stage. \n\nIn that case, we return, ```\"Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.\"```.\n\nOtherwise return, ```False\/false``` (according to the language n use).\n\nNOTE:  Remember, in C# you have to cast your output value to Object type!\n\"\"\"\n\n# ====== Solution ======\n\ndef playerRankUp(pts):\n","entry_point":"playerRankUp","test":"def check(candidate):\n    assert candidate(-1) == False\n    assert candidate(0) == False\n    assert candidate(45) == False\n    assert candidate(59) == False\n    assert candidate(64) == False\n    assert candidate(100) == 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n    assert candidate(105) == 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n    assert candidate(111) == 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n    assert candidate(118) == 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n    assert candidate(332532105) == 'Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.'\n\n","canonical_solution":"def playerRankUp(pts):\n    msg = \"Well done! You have advanced to the qualifying stage. Win 2 out of your next 3 games to rank up.\" \n    return msg if pts >=100 else False"}
{"task_id":3158,"prompt":"\"\"\"\n=====Problem statement====\n\nA very passive-aggressive co-worker of yours was just fired. While he was gathering his things, he quickly inserted a bug into your system which renamed everything to what looks like jibberish. He left two notes on his desk, one reads: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" while the other reads: \"Uif usjdl up uijt lbub jt tjnqmf kvtu sfqmbdf fwfsz mfuufs xjui uif mfuufs uibu dpnft cfgpsf ju\".\n\n\nRather than spending hours trying to find the bug itself, you decide to try and decode it. \n\n\nIf the input is not a string, your function must return \"Input is not a string\". Your function must be able to handle capital and lower case letters. You will not need to worry about punctuation.\n\"\"\"\n\n# ====== Solution ======\n\nlower = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef one_down(txt):\n","entry_point":"one_down","test":"def check(candidate):\n    assert candidate('Ifmmp') == 'Hello'\n    assert candidate('Uif usjdl up uijt lbub jt tjnqmf') == 'The trick to this kata is simple'\n    assert candidate(45) == 'Input is not a string'\n    assert candidate('XiBu BcPvU dSbAz UfYu') == 'WhAt AbOuT cRaZy TeXt'\n    assert candidate(['Hello there', 'World']) == 'Input is not a string'\n    assert candidate('BMM DBQT NBZCF') == 'ALL CAPS MAYBE'\n    assert candidate('qVAamFt BsF gVo') == 'pUZzlEs ArE fUn'\n    assert candidate('CodeWars RockZ') == 'BncdVzqr QnbjY'\n    assert candidate('') == ''\n    assert candidate('J ipqf zpv bsf ibwjoh b ojdf ebz') == 'I hope you are having a nice day'\n\n","canonical_solution":"lower = \"abcdefghijklmnopqrstuvwxyz\"\n\ndef one_down(txt):\n    if not isinstance(txt, str):\n        return \"Input is not a string\"\n    shifted = lower[-1] + lower[:-1]\n    table = str.maketrans(lower + lower.upper(), shifted + shifted.upper())\n    return txt.translate(table)"}
{"task_id":3159,"prompt":"\"\"\"\n=====Problem statement====\n\nAn array is defined to be `odd-heavy` if it contains at least one odd element and every element whose value is `odd` is greater than \nevery even-valued element. \n\neg.\n```\nArray [11,4,9,2,8] is odd-heavy \nbecause:- its odd elements [11,9] are greater than all the even elements [4,2,8]\n\nArray [11,4,9,2,3,10] is not odd-heavy\nbecause:- one of it's even element 10 from [4,2,10] is greater than two of its odd elements [9,3] from [ 11,9,3]\n\n```\nwrite a function called `isOddHeavy` or `is_odd_heavy` that accepts an integer array and returns `true` if the array is `odd-heavy` else return `false`.\n\"\"\"\n\n# ====== Solution ======\n\ndef is_odd_heavy(arr):\n","entry_point":"is_odd_heavy","test":"def check(candidate):\n    assert candidate([0, 2, 19, 4, 4]) == True\n    assert candidate([1, -2, -1, 2]) == False\n    assert candidate([-3, 2, 1, 3, -1, -2]) == False\n    assert candidate([3, 4, -2, -3, -2]) == False\n    assert candidate([-1, 1, -2, 2, -2, -2, -4, 4]) == False\n    assert candidate([-1, -2, 21]) == True\n    assert candidate([0, 0, 0, 0]) == False\n    assert candidate([0, -1, 1]) == False\n    assert candidate([0, 2, 3]) == True\n    assert candidate([0]) == False\n    assert candidate([]) == False\n    assert candidate([1]) == True\n    assert candidate([0, 1, 2, 3, 4, 0, -2, -1, -4, -3]) == False\n    assert candidate([1, -1, 3, -1]) == True\n    assert candidate([1, -1, 2, -2, 3, -3, 0]) == False\n    assert candidate([3]) == True\n    assert candidate([2, 4, 6]) == False\n    assert candidate([-2, -4, -6, -8, -11]) == False\n\n","canonical_solution":"def is_odd_heavy(arr):\n    maxEven, minOdd = ( f(filter(lambda n: n%2 == v, arr), default=float(\"-inf\")) for f,v in ((max, 0), (min,1)) )\n    return maxEven < minOdd"}
{"task_id":3165,"prompt":"\"\"\"\n=====Problem statement====\n\nIntroduction\n\nIt's been more than 20 minutes since the negligent waiter has taken your order for the house special prime tofu steak with a side of chili fries.\n\nOut of boredom, you start fiddling around with the condiments tray. To be efficient, you want to be familiar with the choice of sauces and spices before your order is finally served.\n\nYou also examine the toothpick holder and try to analyze its inner workings when - yikes - the holder's lid falls off and all 23 picks lay scattered on the table.\n\nBeing a good and hygiene oriented citizen, you decide not to just put them back in the holder. Instead of letting all the good wood go to waste, you start playing around with the picks.\n\nIn the first \"round\", you lay down one toothpick vertically. You've used a total of one toothpick.\n\nIn the second \"round\", at each end of the first toothpick, you add a perpendicular toothpick at its center point. You added two additional toothpicks for a total of three toothpicks.\n\nIn the next rounds, you continue to add perpendicular toothpicks to each free end of toothpicks already on the table.\n\nWith your 23 toothpicks, you can complete a total of six rounds:\n\n\nYou wonder if you'd be able to implement this sequence in your favorite programming language. Because your food still hasn't arrived, you decide to take out your laptop and start implementing...\n\nChallenge\nImplement a script that returns the amount of toothpicks needed to complete n amount of rounds of the toothpick sequence.\n\n```\n0 <= n <= 5000\n```\n\nHint\nYou can attempt this brute force or get some inspiration from the math department.\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"toothpick","test":"def check(candidate):\n    assert candidate(0) == 0\n    assert candidate(3) == 7\n    assert candidate(16) == 171\n    assert candidate(32) == 683\n    assert candidate(49) == 1215\n    assert candidate(89) == 3715\n    assert candidate(327) == 52239\n    assert candidate(363) == 60195\n    assert candidate(366) == 62063\n    assert candidate(512) == 174763\n    assert candidate(656) == 209095\n    assert candidate(1038) == 699451\n    assert candidate(1052) == 700379\n    assert candidate(1222) == 757295\n    assert candidate(1235) == 762019\n    assert candidate(1302) == 832559\n    assert candidate(1735) == 1398915\n    assert candidate(1757) == 1443119\n    assert candidate(1974) == 2038207\n    assert candidate(2048) == 2796203\n\n","canonical_solution":"from math import log2\n\ndef t(n):\n    if n == 0:\n        return 0\n    k = int(log2(n))\n    i = n - 2**k\n    if i == 0:\n        return (2**(2*k+1)+1) \/\/ 3\n    else:\n        return t(2**k) + 2*t(i) + t(i+1) - 1\n\ntoothpick = t"}
{"task_id":3173,"prompt":"\"\"\"\n=====Problem statement====\n\n### Unfinished Loop - Bug Fixing #1\n\nOh no, Timmy's created an infinite loop! Help Timmy find and fix the bug in his unfinished for loop!\n\"\"\"\n\n# ====== Solution ======\n\ndef create_array(n):\n","entry_point":"create_array","test":"def check(candidate):\n    assert candidate(1) == [1]\n    assert candidate(2) == [1, 2]\n    assert candidate(3) == [1, 2, 3]\n    assert candidate(4) == [1, 2, 3, 4]\n    assert candidate(5) == [1, 2, 3, 4, 5]\n    assert candidate(6) == [1, 2, 3, 4, 5, 6]\n    assert candidate(7) == [1, 2, 3, 4, 5, 6, 7]\n    assert candidate(8) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert candidate(9) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate(10) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n","canonical_solution":"def create_array(n):\n    res=[]\n    i=1\n    while i<=n:\n        res+=[i]\n        i+= 1\n    return res"}
{"task_id":3206,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that takes as its parameters *one or more numbers which are the diameters of circles.* \n\nThe function should return the *total area of all the circles*, rounded to the nearest integer in a string that says \"We have this much circle: xyz\". \n\nYou don't know how many circles you will be given, but you can assume it will be at least one.\n\nSo: \n```python\nsum_circles(2) == \"We have this much circle: 3\"\nsum_circles(2, 3, 4) == \"We have this much circle: 23\"\n```\n\nTranslations and comments (and upvotes!) welcome!\n\"\"\"\n\n# ====== Solution ======\n\nimport math\n\ndef sum_circles(*args):\n","entry_point":"sum_circles","test":"def check(candidate):\n    assert candidate(48,7,8,9,10) == 'We have this much circle: 2040'\n    assert candidate(1) == 'We have this much circle: 1'\n    assert candidate(1,1,1,2,3,4,5) == 'We have this much circle: 45'\n    assert candidate(894,5778,4839,476) == 'We have this much circle: 45417233'\n    assert candidate(4.5456,746.5,98.34,344.543) == 'We have this much circle: 538519'\n    assert candidate(1,1,1) == 'We have this much circle: 2'\n    assert candidate(13.58,14.9,56.99,107.321) == 'We have this much circle: 11916'\n    assert candidate(56894.04839,843975.4839,4.08437403489) == 'We have this much circle: 561977165367'\n    assert candidate(5,6,7,8,9,10,105083,48839,4853,28,483) == 'We have this much circle: 10564760498'\n\n","canonical_solution":"import math\n\ndef sum_circles(*args):\n    t = round(sum([math.pi * (d**2) \/ 4 for d in args]))\n    return 'We have this much circle: {}'.format(int(t))"}
{"task_id":3214,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function which accepts one arbitrary string as an argument, and return a string of length 26.\n\nThe objective is to set each of the 26 characters of the output string to either `'1'` or `'0'` based on the fact whether the Nth letter of the alphabet is present in the input (independent of its case).\n\nSo if an `'a'` or an `'A'` appears anywhere in the input string (any number of times), set the first character of the output string to `'1'`, otherwise to `'0'`. if `'b'` or `'B'` appears in the string, set the second character to `'1'`, and so on for the rest of the alphabet.\n\nFor instance:\n\n```\n\"a   **&  cZ\"  =>  \"10100000000000000000000001\"\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef change(st):\n","entry_point":"change","test":"def check(candidate):\n    assert candidate('a **&  bZ') == '11000000000000000000000001'\n    assert candidate('Abc e  $$  z') == '11101000000000000000000001'\n    assert candidate('!!a$%&RgTT') == '10000010000000000101000000'\n    assert candidate('') == '00000000000000000000000000'\n    assert candidate('abcdefghijklmnopqrstuvwxyz') == '11111111111111111111111111'\n    assert candidate('aaaaaaaaaaa') == '10000000000000000000000000'\n    assert candidate('&%&%\/$%$%$%$%GYtf67fg34678hgfdyd') == '00010111000000000001000010'\n\n","canonical_solution":"def change(st):\n    new = \"\"\n    st = st.lower()\n    for letter in \"abcdefghijklmnopqrstuvwxyz\":\n        if letter in st:\n            new += \"1\"\n        else:\n            new += \"0\"\n    return new\n"}
{"task_id":3220,"prompt":"\"\"\"\n=====Problem statement====\n\nThe sum of divisors of `6` is `12` and the sum of divisors of `28` is `56`. You will notice that `12\/6 = 2` and `56\/28 = 2`. We shall say that `(6,28)` is a pair with a ratio of `2`.  Similarly, `(30,140)` is also a pair but with a ratio of `2.4`. These ratios are simply decimal representations of fractions.\n\n`(6,28)` and `(30,140)` are the only pairs in which `every member of a pair is 0 <= n < 200`. The sum of the lowest members of each pair is `6 + 30 = 36`. \n\nYou will be given a `range(a,b)`, and your task is to group the numbers into pairs with the same ratios. You will return the sum of the lowest member of each pair in the range. If there are no pairs. return `nil` in Ruby, `0` in python. Upper limit is `2000`.\n\n```Haskell\nsolve(0,200) = 36\n```\n\nGood luck!\n\nif you like this Kata, please try:\n\n[Simple division](https:\/\/www.codewars.com\/kata\/59ec2d112332430ce9000005)\n\n[Sub-array division](https:\/\/www.codewars.com\/kata\/59eb64cba954273cd4000099)\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import defaultdict\nfrom fractions import Fraction\nfrom bisect import bisect_left as bisect\n\nharmonic = [0] + [Fraction(sum({y for x in range(1,int(n**.5)+1) for y in [x, n\/\/x] if not n%x}), n) for n in range(1,7001)]\n\nharmonicity = defaultdict(set)\nfor n,h in enumerate(harmonic): harmonicity[h].add(n)\n\nHARMO_GROUPS = {h: sorted(s) for h,s in harmonicity.items() if len(s) > 1}\nHARMO_RATIOS = {n: h for h,lst in HARMO_GROUPS.items() for n in lst}\nHARMO_NUM    = sorted(HARMO_RATIOS.keys())\n\ndef solve(a,b):\n","entry_point":"solve","test":"def check(candidate):\n    assert candidate(1,100) == 6\n    assert candidate(1,200) == 36\n    assert candidate(1,300) == 252\n    assert candidate(200,1000) == 1104\n    assert candidate(1,1000) == 2619\n    assert candidate(100,1000) == 2223\n    assert candidate(800,2000) == 2352\n\n","canonical_solution":"from collections import defaultdict\nfrom fractions import Fraction\nfrom bisect import bisect_left as bisect\n\nharmonic = [0] + [Fraction(sum({y for x in range(1,int(n**.5)+1) for y in [x, n\/\/x] if not n%x}), n) for n in range(1,7001)]\n\nharmonicity = defaultdict(set)\nfor n,h in enumerate(harmonic): harmonicity[h].add(n)\n\nHARMO_GROUPS = {h: sorted(s) for h,s in harmonicity.items() if len(s) > 1}\nHARMO_RATIOS = {n: h for h,lst in HARMO_GROUPS.items() for n in lst}\nHARMO_NUM    = sorted(HARMO_RATIOS.keys())\n\ndef solve(a,b):\n    seens, s = set(), 0\n    n1, n2 = bisect(HARMO_NUM, a), bisect(HARMO_NUM, b)\n    for n in HARMO_NUM[n1:n2]:\n        if n not in seens:\n            grp = [x for x in HARMO_GROUPS[HARMO_RATIOS[n]] if a <= x < b]\n            if len(grp) > 1:\n                seens |= set(grp)\n                s += grp[0]\n    return s"}
{"task_id":3221,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array of integers, find the one that appears an odd number of times.\n\nThere will always be only one integer that appears an odd number of times.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_it(seq):\n","entry_point":"find_it","test":"def check(candidate):\n    assert candidate([20, 1, -1, 2, -2, 3, 3, 5, 5, 1, 2, 4, 20, 4, -1, -2, 5]) == 5\n    assert candidate([1, 1, 2, -2, 5, 2, 4, 4, -1, -2, 5]) == -1\n    assert candidate([20, 1, 1, 2, 2, 3, 3, 5, 5, 4, 20, 4, 5]) == 5\n    assert candidate([10]) == 10\n    assert candidate([1, 1, 1, 1, 1, 1, 10, 1, 1, 1, 1]) == 10\n\n","canonical_solution":"def find_it(seq):\n    for i in seq:\n        if seq.count(i)%2!=0:\n            return i"}
{"task_id":3224,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven two numbers (m and n) :\n\n- convert all numbers from m to n to binary\n- sum them as if they were in base 10 \n- convert the result to binary\n- return as string\n\nEg: with the numbers 1 and 4\n\n\n   1 \/\/ 1 to binary is 1\n+ 10 \/\/ 2 to binary is 10\n+ 11 \/\/ 3 to binary is 11\n+100 \/\/ 4 to binary is 100\n----\n 122 \/\/ 122 in Base 10 to Binary is 1111010\n\n\n\nSo BinaryPyramid ( 1 , 4 ) should return \"1111010\" \n\nrange should be ascending in order\n\"\"\"\n\n# ====== Solution ======\n\ndef binary_pyramid(m,n):\n","entry_point":"binary_pyramid","test":"def check(candidate):\n    assert candidate(1,4) == '1111010'\n    assert candidate(1,6) == '101001101'\n    assert candidate(6,20) == '1110010110100011'\n    assert candidate(21,60) == '1100000100010001010100'\n    assert candidate(100,100) == '100001100100101000100'\n    assert candidate(1,1) == '1'\n    assert candidate(0,1) == '1'\n    assert candidate(0,0) == '0'\n    assert candidate(1,100) == '10011101010010110000101010'\n    assert candidate(100,1000) == '111111001111110110011011000101110101110'\n\n","canonical_solution":"def binary_pyramid(m,n):\n    return bin(sum(int(bin(i)[2:]) for i in range(m, n+1)))[2:]"}
{"task_id":3229,"prompt":"\"\"\"\n=====Problem statement====\n\nWilson primes satisfy the following condition.\nLet ```P``` represent a prime number. \n\nThen ```((P-1)! + 1) \/ (P * P)``` should give a whole number.\n\nYour task is to create a function that returns ```true``` if the given number is a Wilson prime.\n\"\"\"\n\n# ====== Solution ======\n\ndef am_i_wilson(n):\n","entry_point":"am_i_wilson","test":"def check(candidate):\n    assert candidate(0) == False\n    assert candidate(1) == False\n    assert candidate(5) == True\n    assert candidate(8) == False\n    assert candidate(9) == False\n    assert candidate(11) == False\n    assert candidate(13) == True\n    assert candidate(101) == False\n    assert candidate(563) == True\n    assert candidate(569) == False\n\n","canonical_solution":"def am_i_wilson(n):\n    return n in (5, 13, 563)"}
{"task_id":3237,"prompt":"\"\"\"\n=====Problem statement====\n\n```if-not:sql\nCreate a function (or write a script in Shell) that takes an integer as an argument and returns \"Even\" for even numbers or \"Odd\" for odd numbers.\n```\n\n```if:sql\n## SQL Notes:\nYou will be given a table, `numbers`, with one column `number`.\n\nReturn a table with a column `is_even` containing \"Even\" or \"Odd\" depending on `number` column values.\n\n### numbers table schema\n* number INT\n\n### output table schema\n* is_even STRING\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef even_or_odd(number):\n","entry_point":"even_or_odd","test":"def check(candidate):\n    assert candidate(2) == 'Even'\n    assert candidate(1) == 'Odd'\n    assert candidate(0) == 'Even'\n    assert candidate(1545452) == 'Even'\n    assert candidate(7) == 'Odd'\n    assert candidate(78) == 'Even'\n    assert candidate(17) == 'Odd'\n    assert candidate(74156741) == 'Odd'\n    assert candidate(100000) == 'Even'\n    assert candidate(-123) == 'Odd'\n    assert candidate(-456) == 'Even'\n\n","canonical_solution":"def even_or_odd(number):\n    return 'Odd' if number % 2 else 'Even'"}
{"task_id":3238,"prompt":"\"\"\"\n=====Problem statement====\n\nHey CodeWarrior,\n\nwe've got a lot to code today!\n\nI hope you know the basic string manipulation methods, because this kata will be all about them.\n\nHere we go...\n\n## Background\n\nWe've got a very long string, containing a bunch of User IDs. This string is a listing, which seperates each user ID with a comma and a whitespace (\"' \"). Sometimes there are more than only one whitespace. Keep this in mind! Futhermore, some user Ids are written only in lowercase, others are mixed lowercase and uppercase characters. Each user ID starts with the same 3 letter \"uid\", e.g. \"uid345edj\". But that's not all! Some stupid student edited the string and added some hashtags (#). User IDs containing hashtags are invalid, so these hashtags should be removed!\n\n## Task\n\n1.  Remove all hashtags\n2.  Remove the leading \"uid\" from each user ID\n3.  Return an array of strings --> split the string\n4.  Each user ID should be written in only lowercase characters\n5.  Remove leading and trailing whitespaces\n\n---\n\n## Note\n\nEven if this kata can be solved by using Regex or Linq, please try to find a solution by using only C#'s string class.\n\nSome references for C#:\n\n- [Microsoft MDSN: Trim](https:\/\/msdn.microsoft.com\/de-de\/library\/t97s7bs3%28v=vs.110%29.aspx)\n- [Microsoft MSDN: Split](https:\/\/msdn.microsoft.com\/de-de\/library\/tabh47cf%28v=vs.110%29.aspx)\n- [Microsoft MSDN: ToLower](https:\/\/msdn.microsoft.com\/en-us\/library\/system.string.tolower%28v=vs.110%29.aspx)\n- [Microsoft MSDN: Replace](https:\/\/msdn.microsoft.com\/de-de\/library\/fk49wtc1%28v=vs.110%29.aspx)\n- [Microsoft MSDN: Substring](https:\/\/msdn.microsoft.com\/de-de\/library\/aka44szs%28v=vs.110%29.aspx)\n\"\"\"\n\n# ====== Solution ======\n\ndef get_users_ids(string):\n","entry_point":"get_users_ids","test":"def check(candidate):\n    assert candidate('uid12345') == ['12345']\n    assert candidate('   uidabc  ') == ['abc']\n    assert candidate('#uidswagger') == ['swagger']\n    assert candidate('uidone, uidtwo') == ['one', 'two']\n    assert candidate('uidCAPSLOCK') == ['capslock']\n    assert candidate('uid##doublehashtag') == ['doublehashtag']\n    assert candidate('  uidin name whitespace') == ['in name whitespace']\n    assert candidate('uidMultipleuid') == ['multipleuid']\n    assert candidate('uid12 ab, uid#, uidMiXeDcHaRs') == ['12 ab', '', 'mixedchars']\n    assert candidate(' uidT#e#S#t# ') == ['test']\n\n","canonical_solution":"def get_users_ids(string):\n    return [w.replace(\"uid\", \"\", 1).strip() for w in string.lower().replace(\"#\", \"\").split(\",\")]"}
{"task_id":3240,"prompt":"\"\"\"\n=====Problem statement====\n\nNormally, we decompose a number into binary digits by assigning it with powers of 2, with a coefficient of `0` or `1` for each term:\n\n`25 = 1*16 + 1*8 + 0*4 + 0*2 + 1*1`\n\nThe choice of `0` and `1` is... not very binary. We shall perform the *true* binary expansion by expanding with powers of 2, but with a coefficient of `1` or `-1` instead:\n\n`25 = 1*16 + 1*8 + 1*4 - 1*2 - 1*1`\n\nNow *this* looks binary.\n\n---\n\nGiven any positive number `n`, expand it using the true binary expansion, and return the result as an array, from the most significant digit to the least significant digit.\n\n`true_binary(25) == [1,1,1,-1,-1]`\n\nIt should be trivial (the proofs are left as an exercise to the reader) to see that:\n\n- Every odd number has infinitely many true binary expansions\n- Every even number has no true binary expansions\n\nHence, `n` will always be an odd number, and you should return the *least* true binary expansion for any `n`.\n\nAlso, note that `n` can be very, very large, so your code should be very efficient.\n\"\"\"\n\n# ====== Solution ======\n\ndef true_binary(n):\n","entry_point":"true_binary","test":"def check(candidate):\n    assert candidate(25) == [1, 1, 1, -1, -1]\n    assert candidate(47) == [1, 1, -1, 1, 1, 1]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 1]\n    assert candidate(1234567) == [1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, 1, 1]\n\n","canonical_solution":"def true_binary(n):\n    return [(c == '1') * 2 - 1 for c in '1' + bin(n)[2:-1]]"}
{"task_id":3244,"prompt":"\"\"\"\n=====Problem statement====\n\nYou and your best friend Stripes have just landed your first high school jobs! You'll be delivering newspapers to your neighbourhood on weekends. For your services you'll be charging a set price depending on the quantity of the newspaper bundles.\n\nThe cost of deliveries is:\n\n- $3.85 for 40 newspapers\n- $1.93 for 20\n- $0.97 for 10 \n- $0.49 for 5 \n- $0.10 for 1 \n\nStripes is taking care of the footwork doing door-to-door drops and your job is to take care of the finances. What you'll be doing is providing the cheapest possible quotes for your services.\n\nWrite a function that's passed an integer representing the amount of newspapers and returns the cheapest price. The returned number must be rounded to two decimal places.\n\n![Paperboy](http:\/\/mametesters.org\/file_download.php?file_id=1016&type=bug)\n\"\"\"\n\n# ====== Solution ======\n\ndef cheapest_quote(n):\n","entry_point":"cheapest_quote","test":"def check(candidate):\n    assert candidate(1) == 0.1\n    assert candidate(5) == 0.49\n    assert candidate(10) == 0.97\n    assert candidate(20) == 1.93\n    assert candidate(40) == 3.85\n    assert candidate(41) == 3.95\n    assert candidate(80) == 7.7\n    assert candidate(26) == 2.52\n    assert candidate(0) == 0.0\n    assert candidate(499) == 48.06\n\n","canonical_solution":"def cheapest_quote(n):\n    prices = [(40, 3.85), (20, 1.93), (10, 0.97), (5, 0.49), (1, 0.10)]\n    result = 0\n    for q, c in prices:\n        result += n \/\/ q * c\n        n = n % q\n    return round(result, 2)\n        \n"}
{"task_id":3248,"prompt":"\"\"\"\n=====Problem statement====\n\nIn music, if you double (or halve) the pitch of any note you will get to the same note again.\n\n\"Concert A\" is fixed at 440 Hz, and every other note is defined based on that. 880 Hz is also an A, as is 1760 Hz, as is 220 Hz.\n\nThere are 12 notes in Western music: A, A#, B, C, C#, D, D#, E, F, F#, G, G#. You are given a preloaded dictionary with these 12 notes and one of the pitches that creates that note (starting at Concert A).\n\nNow, given a pitch (in Hz), return the corresponding note. (All inputs will be valid notes).\n\nFor reference, the notes dictionary looks like this:\n\n```python\nnotes_dictionary = {\n    440: \"A\",\n    466.16: \"A#\",\n    493.88: \"B\",\n    523.25: \"C\",\n    554.37: \"C#\", \n    587.33: \"D\", \n    622.25: \"D#\", \n    659.25: \"E\", \n    698.46: \"F\", \n    739.99: \"F#\", \n    783.99: \"G\", \n    830.61: \"G#\"\n}\n```\n\nMusicians: all pitches based on equal tempermanent, taken from [here](http:\/\/pages.mtu.edu\/~suits\/notefreqs.html).\n\"\"\"\n\n# ====== Solution ======\n\nnotes = {\n440: \"A\",\n466.16: \"A#\",\n493.88: \"B\",\n523.25: \"C\",\n554.37: \"C#\",\n587.33: \"D\",\n622.25: \"D#\",\n659.25: \"E\",\n698.46: \"F\",\n739.99: \"F#\",\n783.99: \"G\",\n830.61: \"G#\"\n}\n\ndef get_note(pitch):\n","entry_point":"get_note","test":"def check(candidate):\n    assert candidate(440) == 'A'\n    assert candidate(220) == 'A'\n    assert candidate(880) == 'A'\n    assert candidate(523.25) == 'C'\n    assert candidate(261.625) == 'C'\n    assert candidate(1046.5) == 'C'\n\n","canonical_solution":"notes = {\n440: \"A\",\n466.16: \"A#\",\n493.88: \"B\",\n523.25: \"C\",\n554.37: \"C#\",\n587.33: \"D\",\n622.25: \"D#\",\n659.25: \"E\",\n698.46: \"F\",\n739.99: \"F#\",\n783.99: \"G\",\n830.61: \"G#\"\n}\n\ndef get_note(pitch):\n\n    for note in notes:\n        if note >= pitch and note % pitch == 0:\n                return notes[note]\n        elif note < pitch and pitch % note == 0:\n                return notes[note]"}
{"task_id":3257,"prompt":"\"\"\"\n=====Problem statement====\n\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #19\n\nYou work for an ad agency and your boss, Bob, loves a catchy slogan. He's always jumbling together \"buzz\" words until he gets one he likes. You're looking to impress Boss Bob with a function that can do his job for him.\n\nCreate a function called sloganMaker() that accepts an array of string \"buzz\" words. The function returns an array of all possible UNIQUE string permutations of the buzz words (concatonated and separated by spaces).\n\nYour boss is not very bright, so anticipate him using the same \"buzz\" word more than once, by accident. The function should ignore these duplicate string inputs.\n\n```\nsloganMaker([\"super\", \"hot\", \"guacamole\"]);\n\/\/[ 'super hot guacamole',\n\/\/  'super guacamole hot',\n\/\/  'hot super guacamole',\n\/\/  'hot guacamole super',\n\/\/  'guacamole super hot',\n\/\/  'guacamole hot super' ]\n\nsloganMaker([\"cool\", \"pizza\", \"cool\"]); \/\/ => [ 'cool pizza', 'pizza cool' ]\n```\n\nNote:  \nThere should be NO duplicate strings in the output array\n\nThe input array MAY contain duplicate strings, which should STILL result in an output array with all unique strings\n\nAn empty string is valid input\n\n```if-not:python,crystal\nThe order of the permutations in the output array does not matter\n```\n```if:python,crystal\nThe order of the output array must match those rules:\n1. Generate the permutations in lexicographic order of the original array.\n2. keep only the first occurence of a permutation, when duplicates are found.\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef slogan_maker(array):\n","entry_point":"slogan_maker","test":"def check(candidate):\n    assert candidate(['super']) == ['super']\n    assert candidate(['super', 'hot']) == ['super hot', 'hot super']\n    assert candidate(['super', 'hot', 'guacamole']) == ['super hot guacamole', 'super guacamole hot', 'hot super guacamole', 'hot guacamole super', 'guacamole super hot', 'guacamole hot super']\n    assert candidate(['super', 'guacamole', 'super', 'super', 'hot', 'guacamole']) == ['super guacamole hot', 'super hot guacamole', 'guacamole super hot', 'guacamole hot super', 'hot super guacamole', 'hot guacamole super']\n    assert candidate(['testing', 'testing', 'testing']) == ['testing']\n\n","canonical_solution":"def slogan_maker(array):\n    print(array)\n    from itertools import permutations \n    array = remove_duplicate(array)\n    return [' '.join(element) for element in list(permutations(array, len(array)))]\n    \ndef remove_duplicate(old_list): \n    final_list = [] \n    for num in old_list: \n        if num not in final_list: \n            final_list.append(num) \n    return final_list "}
{"task_id":3266,"prompt":"\"\"\"\n=====Problem statement====\n\n# Fix the Bugs (Syntax) - My First Kata\n\n## Overview\n\nHello, this is my first Kata so forgive me if it is of poor quality.\n\nIn this Kata you should fix\/create a program that ```return```s the following values:\n\n - ```false\/False``` if either a or b (or both) are not numbers\n - ```a % b``` plus ```b % a``` if both arguments are numbers\n\nYou may assume the following:\n\n1. If ```a``` and ```b``` are both numbers, neither of ```a``` or ```b``` will be ```0```.\n\n## Language-Specific Instructions\n\n### Javascript and PHP\n\nIn this Kata you should try to fix all the syntax errors found in the code.\n\nOnce you think all the bugs are fixed run the code to see if it works.  A correct solution should return the values specified in the overview.\n\n**Extension: Once you have fixed all the syntax errors present in the code (basic requirement), you may attempt to optimise the code or try a different approach by coding it from scratch.**\n\"\"\"\n\n# ====== Solution ======\n\ndef my_first_kata(a,b):\n","entry_point":"my_first_kata","test":"def check(candidate):\n    assert candidate(3,5) == 5\n    assert candidate('hello',3) == False\n    assert candidate(67,'bye') == False\n    assert candidate(True,True) == False\n    assert candidate(314,107) == 207\n    assert candidate(1,32) == 1\n    assert candidate(-1,-1) == 0\n    assert candidate(19483,9) == 16\n    assert candidate('hello',{}) == False\n    assert candidate([],'pippi') == False\n\n","canonical_solution":"def my_first_kata(a,b):\n    #your code here\n    if type(a) == int and type(b) == int:\n        return a % b + b % a\n    else:\n        return False"}
{"task_id":3278,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a string that includes alphanumeric characters ('3a4B2d') return the expansion of that string: The numeric values represent the occurrence of each letter preceding that numeric value. There should be no numeric characters in the final string. Empty strings should return an empty string. \n \nThe first occurrence of a numeric value should be the number of times each character behind it is repeated, until the next numeric value appears.\n```python\nstring_expansion('3D2a5d2f') == 'DDDaadddddff'\n```\n```python\nstring_expansion('3abc') == 'aaabbbccc'       # correct\nstring_expansion('3abc') != 'aaabc'           # wrong\nstring_expansion('3abc') != 'abcabcabc'       # wrong\n```\nIf there are two consecutive numeric characters the first one is ignored.\n\n```python\nstring_expansion('3d332f2a') == 'dddffaa'\n```\nIf there are two consecutive alphabetic characters then the first character has no effect on the one after it.\n\n```python\nstring_expansion('abcde') == 'abcde'\n```\nYour code should be able to work for both lower and capital case letters.\n\n```python\nstring_expansion('') == ''\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef string_expansion(s):\n","entry_point":"string_expansion","test":"def check(candidate):\n    assert candidate('3D2a5d2f') == 'DDDaadddddff'\n    assert candidate('4D1a8d4j3k') == 'DDDDaddddddddjjjjkkk'\n    assert candidate('4D2a8d4j2f') == 'DDDDaaddddddddjjjjff'\n    assert candidate('3n6s7f3n') == 'nnnssssssfffffffnnn'\n    assert candidate('0d4n8d2b') == 'nnnnddddddddbb'\n    assert candidate('0c3b1n7m') == 'bbbnmmmmmmm'\n    assert candidate('7m3j4ik2a') == 'mmmmmmmjjjiiiikkkkaa'\n    assert candidate('3A5m3B3Y') == 'AAAmmmmmBBBYYY'\n    assert candidate('5M0L8P1') == 'MMMMMPPPPPPPP'\n    assert candidate('2B') == 'BB'\n    assert candidate('7M1n3K') == 'MMMMMMMnKKK'\n    assert candidate('A4g1b4d') == 'Aggggbdddd'\n    assert candidate('111111') == ''\n    assert candidate('4d324n2') == 'ddddnnnn'\n    assert candidate('5919nf3u') == 'nnnnnnnnnfffffffffuuu'\n    assert candidate('2n1k523n4i') == 'nnknnniiii'\n    assert candidate('6o23M32d') == 'ooooooMMMdd'\n    assert candidate('1B44n3r') == 'Bnnnnrrr'\n    assert candidate('M21d1r32') == 'Mdr'\n    assert candidate('23M31r2r2') == 'MMMrrr'\n    assert candidate('8494mM25K2A') == 'mmmmMMMMKKKKKAA'\n    assert candidate('4A46D6B3C') == 'AAAADDDDDDBBBBBBCCC'\n    assert candidate('23D42B3A') == 'DDDBBAAA'\n    assert candidate('143D36C1A') == 'DDDCCCCCCA'\n    assert candidate('asdf') == 'asdf'\n    assert candidate('23jbjl1eb') == 'jjjbbbjjjllleb'\n    assert candidate('43ibadsr3') == 'iiibbbaaadddsssrrr'\n    assert candidate('123p9cdbjs') == 'pppcccccccccdddddddddbbbbbbbbbjjjjjjjjjsssssssss'\n    assert candidate('2309ew7eh') == 'eeeeeeeeewwwwwwwwweeeeeeehhhhhhh'\n    assert candidate('312987rfebd') == 'rrrrrrrfffffffeeeeeeebbbbbbbddddddd'\n    assert candidate('126cgec') == 'ccccccggggggeeeeeecccccc'\n    assert candidate('1chwq3rfb') == 'chwqrrrfffbbb'\n    assert candidate('389fg21c') == 'fffffffffgggggggggc'\n    assert candidate('239vbsac') == 'vvvvvvvvvbbbbbbbbbsssssssssaaaaaaaaaccccccccc'\n    assert candidate('davhb327vuc') == 'davhbvvvvvvvuuuuuuuccccccc'\n    assert candidate('cvyb239bved2dv') == 'cvybbbbbbbbbbvvvvvvvvveeeeeeeeedddddddddddvv'\n    assert candidate('') == ''\n\n","canonical_solution":"def string_expansion(s):\n    m,n = '',1\n    for j in s:\n        if j.isdigit():\n            n = int(j)\n        else:\n            m += j*n\n    return m"}
{"task_id":3292,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a string, turn each letter into its ASCII character code and join them together to create a number - let's call this number `total1`:\n\n```\n'ABC' --> 'A' = 65, 'B' = 66, 'C' = 67 --> 656667\n```\n\nThen replace any incidence of the number `7` with the number `1`, and call this number 'total2':\n```\ntotal1 = 656667\n              ^\ntotal2 = 656661\n              ^\n```\n\nThen return the difference between the sum of the digits in `total1` and `total2`:\n\n```\n  (6 + 5 + 6 + 6 + 6 + 7)\n- (6 + 5 + 6 + 6 + 6 + 1)\n-------------------------\n                       6\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef calc(s):\n","entry_point":"calc","test":"def check(candidate):\n    assert candidate('abcdef') == 6\n    assert candidate('ifkhchlhfd') == 6\n    assert candidate('aaaaaddddr') == 30\n    assert candidate('jfmgklf8hglbe') == 6\n    assert candidate('jaam') == 12\n    assert candidate('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ') == 96\n\n","canonical_solution":"def calc(s):\n    total1 = ''.join(map(lambda c: str(ord(c)), s))\n    total2 = total1.replace('7', '1')\n    return sum(map(int, total1)) - sum(map(int, total2))"}
{"task_id":3294,"prompt":"\"\"\"\n=====Problem statement====\n\nSometimes, I want to quickly be able to convert miles per imperial gallon into kilometers per liter.\n\nCreate an application that will display the number of kilometers per liter (output) based on the number of miles per imperial gallon (input).\n\nMake sure to round off the result to two decimal points. If the answer ends with a 0, it should be rounded off without the 0. So instead of 5.50, we should get 5.5.\n\nSome useful associations relevant to this kata:\n1 Imperial Gallon = 4.54609188 litres\n1 Mile = 1.609344 kilometres\n\"\"\"\n\n# ====== Solution ======\n\ndef converter(mpg):\n","entry_point":"converter","test":"def check(candidate):\n    assert candidate(10) == 3.54\n    assert candidate(20) == 7.08\n    assert candidate(30) == 10.62\n    assert candidate(24) == 8.5\n    assert candidate(36) == 12.74\n\n","canonical_solution":"def converter(mpg):\n    '''Converts mpg to kpl. Rounds to two decimal places.'''\n    kpl = round(mpg * 1.609344\/4.54609188, 2)\n    return kpl"}
{"task_id":3299,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n\nJohn won the championship of a TV show. He can get some bonuses.\n\nHe needs to play a game to determine the amount of his bonus.\n\nHere are some cards in a row. A number is written on each card.\n\nIn each turn, John can take a card, but only from the beginning or the end of the row. Then multiply the number on the card by an coefficient 2^(i)(i means the ith turn). The product is John's bonus of current turn.\n\nAfter all the cards are taken away, the game is over. John's final bonus is the sum of all rounds of bonuses.\n\nObviously, the order in which John takes the cards will affect the amount of John's final bonus.\n\nYour task is to help John calculate the maximum amount of bonuses he can get.\n\n# Input\n\n- `cards`: An integer array. Each element represents the number on the card.\n  - `1 <= cards.length <= 30`\n  - `1 <= cards[i] <= 100`\n\n\n- All inputs are valid.\n\n# Output\n\nAn integer. the maximum amount of bonuses John can get.\n\n# Eaxmple\n\nFor `cards=[1,2,5]`, the output should be `50`.\n\n```\nAll possible orders are:\n1->2->5   bonus:1x2+2*4+5*8=50\n1->5->2   bonus:1x2+5*4+2*8=38\n5->1->2   bonus:5*2+1*4+2*8=30\n5->2->1   bonus:5*2+2*4+1*8=26\nThe maximum amount of bonus is 50.\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef calc(a):\n","entry_point":"calc","test":"def check(candidate):\n    assert candidate([1, 2, 5]) == 50\n    assert candidate([1]) == 2\n    assert candidate([1, 1]) == 6\n    assert candidate([1, 2, 1]) == 22\n    assert candidate([4, 10, 2, 3, 1, 3, 1, 6, 9]) == 6722\n\n","canonical_solution":"def calc(a):\n    res = [0] * (len(a) + 1)\n    for k in range(len(a)):\n        res = [2 * max(a[i] + res[i+1], a[i+k] + res[i]) for i in range(len(a) - k)]\n    return res[0]"}
{"task_id":3303,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a mixed array of number and string representations of integers, add up the string integers and subtract this from the total of the non-string integers. \n\nReturn as a number.\n\"\"\"\n\n# ====== Solution ======\n\ndef div_con(lst):\n","entry_point":"div_con","test":"def check(candidate):\n    assert candidate([9, 3, '7', '3']) == 2\n    assert candidate(['5', '0', 9, 3, 2, 1, '9', 6, 7]) == 14\n    assert candidate(['3', 6, 6, 0, '5', 8, 5, '6', 2, '0']) == 13\n    assert candidate(['1', '5', '8', 8, 9, 9, 2, '3']) == 11\n    assert candidate([8, 0, 0, 8, 5, 7, 2, 3, 7, 8, 6, 7]) == 61\n\n","canonical_solution":"def div_con(lst):\n    return sum(n if isinstance(n, int) else -int(n) for n in lst)"}
{"task_id":3311,"prompt":"\"\"\"\n=====Problem statement====\n\nReverse and invert all integer values in a given list. \n\nPython:\n\n    reverse_invert([1,12,'a',3.4,87,99.9,-42,50,5.6]) = [-1,-21,-78,24,-5]\n    \nIgnore all other types than integer.\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import copysign as sign\n\ndef reverse_invert(lst):\n","entry_point":"reverse_invert","test":"def check(candidate):\n    assert candidate([1, 2, 3, 4, 5]) == [-1, -2, -3, -4, -5]\n    assert candidate([-10]) == [1]\n    assert candidate([-9, -18, 99]) == [9, 81, -99]\n    assert candidate([1, 12, 'a', 3.4, 87, 99.9, -42, 50, 5.6]) == [-1, -21, -78, 24, -5]\n    assert candidate([]) == []\n\n","canonical_solution":"from math import copysign as sign\n\ndef reverse_invert(lst):\n    return [-int(sign(int(str(abs(x))[::-1]),x)) for x in lst if isinstance(x,int)]  "}
{"task_id":3337,"prompt":"\"\"\"\n=====Problem statement====\n\nIt's March and you just can't seem to get your mind off brackets. However, it is not due to basketball. You need to extract statements within strings that are contained within brackets.\n\nYou have to write a function that returns a list of statements that are contained within brackets given a string. If the value entered in the function is not a string, well, you know where that variable should be sitting.\n\nGood luck!\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\nREGEX = re.compile(r'\\[(.*?)\\]')\n\n\ndef bracket_buster(strng):\n","entry_point":"bracket_buster","test":"def check(candidate):\n    assert candidate([1, 2, 3]) == 'Take a seat on the bench.'\n    assert candidate({'3': 4}) == 'Take a seat on the bench.'\n    assert candidate(False) == 'Take a seat on the bench.'\n    assert candidate(23.45) == 'Take a seat on the bench.'\n    assert candidate('arc.tic.[circle]?[?]') == ['circle', '?']\n    assert candidate('Big [L][e][B][r][o][n]!][[') == ['L', 'e', 'B', 'r', 'o', 'n']\n    assert candidate('[][]]]][[[[[[][]') == ['', '', '[[[[[', '']\n    assert candidate('logger?]?system...12.12.133333 at [12-32-1432-16]') == ['12-32-1432-16']\n\n","canonical_solution":"import re\n\nREGEX = re.compile(r'\\[(.*?)\\]')\n\n\ndef bracket_buster(strng):\n    try:\n        return REGEX.findall(strng)\n    except TypeError:\n        return 'Take a seat on the bench.'\n"}
{"task_id":3338,"prompt":"\"\"\"\n=====Problem statement====\n\nTranform of input array of zeros and ones to array in which counts number of continuous ones:\n\n[1, 1, 1, 0, 1] -> [3,1]\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import groupby\n\n\ndef ones_counter(nums):\n","entry_point":"ones_counter","test":"def check(candidate):\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0]) == []\n    assert candidate([1, 1, 1, 1, 1]) == [5]\n    assert candidate([1, 1, 1, 0, 0, 1, 0, 1, 1, 0]) == [3, 1, 2]\n    assert candidate([0, 0, 0, 1, 0, 0, 1, 1]) == [1, 2]\n    assert candidate([1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1]) == [1, 2, 4, 1]\n\n","canonical_solution":"from itertools import groupby\n\n\ndef ones_counter(nums):\n    return [sum(g) for k, g in groupby(nums) if k]\n"}
{"task_id":3339,"prompt":"\"\"\"\n=====Problem statement====\n\nNo Story\n\nNo Description\n\nOnly by Thinking and Testing\n\nLook at the results of the testcases, and guess the code!\n\n---\n\n## Series:\n\n01. [A and B?](http:\/\/www.codewars.com\/kata\/56d904db9963e9cf5000037d)\n02. [Incomplete string](http:\/\/www.codewars.com\/kata\/56d9292cc11bcc3629000533)\n03. [True or False](http:\/\/www.codewars.com\/kata\/56d931ecc443d475d5000003)\n04. [Something capitalized](http:\/\/www.codewars.com\/kata\/56d93f249c844788bc000002)\n05. [Uniq or not Uniq](http:\/\/www.codewars.com\/kata\/56d949281b5fdc7666000004)\n06. [Spatiotemporal index](http:\/\/www.codewars.com\/kata\/56d98b555492513acf00077d)\n07. [Math of Primary School](http:\/\/www.codewars.com\/kata\/56d9b46113f38864b8000c5a)\n08. [Math of Middle school](http:\/\/www.codewars.com\/kata\/56d9c274c550b4a5c2000d92)\n09. [From nothingness To nothingness](http:\/\/www.codewars.com\/kata\/56d9cfd3f3928b4edd000021)\n10. [Not perfect? Throw away!](http:\/\/www.codewars.com\/kata\/56dae2913cb6f5d428000f77)\n11. [Welcome to take the bus](http:\/\/www.codewars.com\/kata\/56db19703cb6f5ec3e001393)\n12. [A happy day will come](http:\/\/www.codewars.com\/kata\/56dc41173e5dd65179001167)\n13. [Sum of 15(Hetu Luosliu)](http:\/\/www.codewars.com\/kata\/56dc5a773e5dd6dcf7001356)\n14. [Nebula or Vortex](http:\/\/www.codewars.com\/kata\/56dd3dd94c9055a413000b22)\n15. [Sport Star](http:\/\/www.codewars.com\/kata\/56dd927e4c9055f8470013a5)\n16. [Falsetto Rap Concert](http:\/\/www.codewars.com\/kata\/56de38c1c54a9248dd0006e4)\n17. [Wind whispers](http:\/\/www.codewars.com\/kata\/56de4d58301c1156170008ff)\n18. [Mobile phone simulator](http:\/\/www.codewars.com\/kata\/56de82fb9905a1c3e6000b52)\n19. [Join but not join](http:\/\/www.codewars.com\/kata\/56dfce76b832927775000027)\n20. [I hate big and small](http:\/\/www.codewars.com\/kata\/56dfd5dfd28ffd52c6000bb7)\n21. [I want to become diabetic ;-)](http:\/\/www.codewars.com\/kata\/56e0e065ef93568edb000731)\n22. [How many blocks?](http:\/\/www.codewars.com\/kata\/56e0f1dc09eb083b07000028)\n23. [Operator hidden in a string](http:\/\/www.codewars.com\/kata\/56e1161fef93568228000aad)\n24. [Substring Magic](http:\/\/www.codewars.com\/kata\/56e127d4ef93568228000be2)\n25. [Report about something](http:\/\/www.codewars.com\/kata\/56eccc08b9d9274c300019b9)\n26. [Retention and discard I](http:\/\/www.codewars.com\/kata\/56ee0448588cbb60740013b9)\n27. [Retention and discard II](http:\/\/www.codewars.com\/kata\/56eee006ff32e1b5b0000c32)\n28. [How many \"word\"?](http:\/\/www.codewars.com\/kata\/56eff1e64794404a720002d2)\n29. [Hail and Waterfall](http:\/\/www.codewars.com\/kata\/56f167455b913928a8000c49)\n30. [Love Forever](http:\/\/www.codewars.com\/kata\/56f214580cd8bc66a5001a0f)\n31. [Digital swimming pool](http:\/\/www.codewars.com\/kata\/56f25b17e40b7014170002bd)\n32. [Archery contest](http:\/\/www.codewars.com\/kata\/56f4202199b3861b880013e0)\n33. [The repair of parchment](http:\/\/www.codewars.com\/kata\/56f606236b88de2103000267)\n34. [Who are you?](http:\/\/www.codewars.com\/kata\/56f6b4369400f51c8e000d64)\n35. [Safe position](http:\/\/www.codewars.com\/kata\/56f7eb14f749ba513b0009c3)\n\n---\n \n## Special recommendation\n\nAnother series, innovative and interesting, medium difficulty. People who like challenges, can try these kata:\n    \n* [Play Tetris : Shape anastomosis](http:\/\/www.codewars.com\/kata\/56c85eebfd8fc02551000281)\n* [Play FlappyBird : Advance Bravely](http:\/\/www.codewars.com\/kata\/56cd5d09aa4ac772e3000323)\n\"\"\"\n\n# ====== Solution ======\n\ndef mystery(n):\n","entry_point":"mystery","test":"def check(candidate):\n    assert candidate(-1) == []\n    assert candidate(0) == []\n    assert candidate(1) == [1]\n    assert candidate(2) == [1]\n    assert candidate(3) == [1, 3]\n    assert candidate(4) == [1]\n    assert candidate(5) == [1, 5]\n    assert candidate(6) == [1, 3]\n    assert candidate(7) == [1, 7]\n    assert candidate(8) == [1]\n    assert candidate(9) == [1, 3, 9]\n    assert candidate(10) == [1, 5]\n\n","canonical_solution":"def mystery(n):\n    return [i for i in range(1, n + 1, 2) if n % i == 0]"}
{"task_id":3340,"prompt":"\"\"\"\n=====Problem statement====\n\nThe [Sharkovsky's Theorem](https:\/\/en.wikipedia.org\/wiki\/Sharkovskii%27s_theorem) involves the following ordering of the natural numbers:\n```math\n3\u227a5\u227a7\u227a9\u227a ...\\\\\n\u227a2\u00b73\u227a2\u00b75\u227a2\u00b77\u227a2\u00b79\u227a...\\\\\n\u227a2^n\u00b73\u227a2^n\u00b75\u227a2^n\u00b77\u227a2^n\u00b79\u227a...\\\\\n\u227a2^{(n+1)}\u00b73\u227a2^{(n+1)}\u00b75\u227a2^{(n+1)}\u00b77\u227a2^{(n+1)}\u00b79\u227a...\\\\\n\u227a2^n\u227a2^{(n-1)}\u227a...\\\\\n\u227a4\u227a2\u227a1\\\\\n```\n \nYour task is to complete the function which returns `true` if `$a\u227ab$` according to this ordering, and `false` otherwise.\n \nYou may assume both `$a$` and `$b$` are non-zero positive integers.\n\"\"\"\n\n# ====== Solution ======\n\ndef sharkovsky(a, b): return f(a)<f(b)\n","entry_point":"sharkovsky","test":"def check(candidate):\n    assert candidate(18,12) == True\n    assert candidate(3,9) == True\n    assert candidate(10,16) == True\n    assert candidate(1,22) == False\n    assert candidate(32,1024) == False\n    assert candidate(17,17) == False\n\n","canonical_solution":"def sharkovsky(a, b): return f(a)<f(b)\n\ndef f(n,p=0):\n    while n%2==0:\n        n>>=1\n        p+=1\n    return n==1, p*(-1)**(n==1), n"}
{"task_id":3345,"prompt":"\"\"\"\n=====Problem statement====\n\nThere is an array of strings. All strings contains similar _letters_ except one. Try to find it!\n\n```python\nfind_uniq([ 'Aa', 'aaa', 'aaaaa', 'BbBb', 'Aaaa', 'AaAaAa', 'a' ]) # => 'BbBb'\nfind_uniq([ 'abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba' ]) # => 'foo'\n```\n\nStrings may contain spaces. Spaces is not significant, only non-spaces symbols matters. E.g. string that contains only spaces is like empty string.\n\nIt\u2019s guaranteed that array contains more than 3 strings.\n\nThis is the second kata in series:\n\n1. [Find the unique number](https:\/\/www.codewars.com\/kata\/585d7d5adb20cf33cb000235)\n2. Find the unique string (this kata)\n3. [Find The Unique](https:\/\/www.codewars.com\/kata\/5862e0db4f7ab47bed0000e5)\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import defaultdict\n\ndef find_uniq(a):\n","entry_point":"find_uniq","test":"def check(candidate):\n    assert candidate(['Aa', 'aaa', 'aaaaa', 'BbBb', 'Aaaa', 'AaAaAa', 'a']) == 'BbBb'\n    assert candidate(['abc', 'acb', 'bac', 'foo', 'bca', 'cab', 'cba']) == 'foo'\n    assert candidate(['silvia', 'vasili', 'victor']) == 'victor'\n    assert candidate(['Tom Marvolo Riddle', 'I am Lord Voldemort', 'Harry Potter']) == 'Harry Potter'\n    assert candidate(['', '', '', 'a', '', '']) == 'a'\n    assert candidate(['    ', '  ', ' ', 'a', ' ', '']) == 'a'\n    assert candidate(['foobar', 'barfo', 'fobara', '   ', 'fobra', 'oooofrab']) == '   '\n\n","canonical_solution":"from collections import defaultdict\n\ndef find_uniq(a):\n    d = {}\n    c = defaultdict(int)\n    for e in a:\n        t = frozenset(e.strip().lower())\n        d[t] = e\n        c[t] += 1\n    \n    return d[next(filter(lambda k: c[k] == 1, c))]"}
{"task_id":3352,"prompt":"\"\"\"\n=====Problem statement====\n\nFind the number with the most digits.\n\nIf two numbers in the argument array have the same number of digits, return the first one in the array.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_longest(xs):\n","entry_point":"find_longest","test":"def check(candidate):\n    assert candidate([1, 10, 100]) == 100\n    assert candidate([9000, 8, 800]) == 9000\n    assert candidate([8, 900, 500]) == 900\n    assert candidate([3, 40000, 100]) == 40000\n    assert candidate([1, 200, 100000]) == 100000\n\n","canonical_solution":"def find_longest(xs):\n    return max(xs, key=lambda x: len(str(x)))"}
{"task_id":3360,"prompt":"\"\"\"\n=====Problem statement====\n\n## Description\n\nPeter enjoys taking risks, and this time he has decided to take it up a notch!\n\nPeter asks his local barman to pour him **n** shots, after which Peter then puts laxatives in **x** of them. He then turns around and lets the barman shuffle the shots. Peter approaches the shots and drinks **a** of them one at a time. Just one shot is enough to give Peter a runny tummy. What is the probability that Peter doesn't need to run to the loo?\n\n## Task\n\nYou are given:\n\n**n** - The total number of shots.\n\n**x** - The number of laxative laden shots.\n\n**a** - The number of shots that peter drinks.\n\n\nreturn the probability that Peter won't have the trots after drinking. **n** will always be greater than **x**, and **a** will always be less than **n**.\n\n**You must return the probability rounded to two decimal places i.e. 0.05 or 0.81**\n\"\"\"\n\n# ====== Solution ======\n\nfrom functools import reduce\ndef get_chance(n, x, a):\n","entry_point":"get_chance","test":"def check(candidate):\n    assert candidate(2,1,1) == 0.5\n    assert candidate(4,1,3) == 0.25\n    assert candidate(100,10,10) == 0.33\n    assert candidate(1000,150,20) == 0.04\n    assert candidate(25,5,5) == 0.29\n    assert candidate(9,3,2) == 0.42\n    assert candidate(4000,200,30) == 0.21\n    assert candidate(10000,100,100) == 0.36\n    assert candidate(1000000,5000,200) == 0.37\n    assert candidate(1000000,5000,20000) == 0.0\n\n","canonical_solution":"from functools import reduce\ndef get_chance(n, x, a):\n    return round(reduce(lambda m, b: m * (1 - x \/ (n - b)), range(a), 1), 2)"}
{"task_id":3362,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array of integers as strings and numbers, return the sum of the array values as if all were numbers.\n\nReturn your answer as a number.\n\"\"\"\n\n# ====== Solution ======\n\ndef sum_mix(arr):\n","entry_point":"sum_mix","test":"def check(candidate):\n    assert candidate([9, 3, '7', '3']) == 22\n    assert candidate(['5', '0', 9, 3, 2, 1, '9', 6, 7]) == 42\n    assert candidate(['3', 6, 6, 0, '5', 8, 5, '6', 2, '0']) == 41\n    assert candidate(['1', '5', '8', 8, 9, 9, 2, '3']) == 45\n    assert candidate([8, 0, 0, 8, 5, 7, 2, 3, 7, 8, 6, 7]) == 61\n\n","canonical_solution":"def sum_mix(arr):\n    return sum(map(int, arr))"}
{"task_id":3363,"prompt":"\"\"\"\n=====Problem statement====\n\nThis program tests the life of an\nevaporator containing a gas. \n\nWe know the content of the evaporator (content in ml),\nthe percentage of foam or gas lost every day (evap_per_day)\nand the threshold (threshold) in percentage beyond which\nthe evaporator is no longer useful.\nAll numbers are strictly positive.\n\nThe program reports the nth day (as an integer)\non which the evaporator will be out of use.\n\n**Note** : Content is in fact not necessary in the body of the function \"evaporator\", you can use it or not use it, as you wish. Some people might prefer to reason with content, some other with percentages only. It's up to you but you must keep it as a parameter because the tests have it as an argument.\n\"\"\"\n\n# ====== Solution ======\n\ndef evaporator(content, evap_per_day, threshold):\n","entry_point":"evaporator","test":"def check(candidate):\n    assert candidate(10,10,10) == 22\n    assert candidate(10,10,5) == 29\n    assert candidate(100,5,5) == 59\n    assert candidate(50,12,1) == 37\n    assert candidate(47.5,8,8) == 31\n    assert candidate(100,1,1) == 459\n    assert candidate(10,1,1) == 459\n    assert candidate(100,1,5) == 299\n\n","canonical_solution":"def evaporator(content, evap_per_day, threshold):\n    n = 0\n    current = 100\n    percent = 1 - evap_per_day \/ 100.0\n    while current > threshold:\n        current *= percent\n        n += 1\n    return n"}
{"task_id":3366,"prompt":"\"\"\"\n=====Problem statement====\n\nLexicographic permutations are ordered combinations of a set of items ordered in a specific way.\n\nFor instance, the first 8 permutations of the digits 0123, in lexicographic order, are:\n\n```\n1st 0123\n2nd 0132\n3rd 0213\n4th 0231\n5th 0312\n6th 0321\n7th 1023\n8th 1032\n```\n\nYour task is to write a function ```L( n, d )``` that will return a `string` representing the `nth` permutation of the `d` digit, starting with 0 (i.e. d=10 means all digits 0123456789).\n\nSo for `d = 4`, `L(7,4)` should return `'1023'`, and `L(4,4)` should return `'0231'`\n.\n\n\nSome things to bear in mind:\n\n\u2022 The function should return a `string`, otherwise permutations beginning with a 0 will have it removed. \n\n\u2022 Test cases will not exceed the highest possible valid values for `n`\n\n\u2022 The function should work for any `d` between `1` and `10`.\n\n\u2022 A value of 1 for `n` means the 1st permutation, so `n = 0` is not a valid input.\n\n\u2022 Oh, and no itertools ;)\n\"\"\"\n\n# ====== Solution ======\n\nimport math\ndef nth_perm(n,d):\n","entry_point":"nth_perm","test":"def check(candidate):\n    assert candidate(1,1) == '0'\n    assert candidate(12,5) == '02431'\n    assert candidate(1000,7) == '1325460'\n    assert candidate(1000,8) == '02436571'\n    assert candidate(1000000,10) == '2783915460'\n    assert candidate(874,7) == '1234560'\n    assert candidate(100,5) == '40231'\n    assert candidate(400,6) == '314250'\n    assert candidate(900,8) == '02354761'\n    assert candidate(3000000,10) == '8241697530'\n    assert candidate(1234567,10) == '3469702158'\n    assert candidate(654321,10) == '1827653409'\n    assert candidate(100000,9) == '247815360'\n    assert candidate(33333,8) == '64157203'\n\n","canonical_solution":"import math\ndef nth_perm(n,d):\n    digits = [str(i) for i in range(d)]\n    out = ''\n    for i in range(1, d):\n        cycles = math.ceil(n\/math.factorial(d-i))\n        out += digits.pop((cycles % (d-i+1)) - 1)\n    return out + digits.pop()"}
{"task_id":3374,"prompt":"\"\"\"\n=====Problem statement====\n\nYou certainly can tell which is the larger number between 2^(10) and 2^(15).\n\nBut what about, say, 2^(10) and 3^(10)? You know this one too.\n\nThings tend to get a bit more complicated with **both** different bases and exponents: which is larger between 3^(9) and 5^(6)?\n\nWell, by now you have surely guessed that you have to build a function to compare powers, returning -1 if the first member is larger, 0 if they are equal, 1 otherwise; powers to compare will be provided in the `[base, exponent]` format:\n```python\ncompare_powers([2,10],[2,15])==1\ncompare_powers([2,10],[3,10])==1\ncompare_powers([2,10],[2,10])==0\ncompare_powers([3,9],[5,6])==-1\ncompare_powers([7,7],[5,8])==-1\n```\n```if:nasm\nint compare_powers(const int n1[2], const int n2[2])\n```\nOnly positive integers will be tested, incluing bigger numbers - you are warned now, so be diligent try to implement an efficient solution not to drain too much on CW resources ;)!\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import log\n\ndef compare_powers(*numbers):\n","entry_point":"compare_powers","test":"def check(candidate):\n    assert candidate([2, 10],[2, 15]) == 1\n    assert candidate([1, 10],[3, 10]) == 1\n    assert candidate([2, 10],[2, 10]) == 0\n    assert candidate([3, 9],[1, 6]) == -1\n    assert candidate([1, 7],[1, 8]) == 0\n    assert candidate([2, 100],[2, 150]) == 1\n    assert candidate([2, 100],[3, 100]) == 1\n    assert candidate([2, 100],[2, 100]) == 0\n    assert candidate([34, 98],[51, 67]) == -1\n    assert candidate([1024, 97],[1024, 81]) == -1\n\n","canonical_solution":"from math import log\n\ndef compare_powers(*numbers):\n    a,b = map(lambda n: n[1]*log(n[0]), numbers)\n    return (a<b) - (a>b)"}
{"task_id":3383,"prompt":"\"\"\"\n=====Problem statement====\n\nIs the number even?\n\nIf the numbers is even return `true`. If it's odd, return `false`. \n\n\nOh yeah... the following symbols\/commands have been disabled!\n\n use of ```%```\n use of ```.even?``` in Ruby\n use of ```mod``` in Python\n\"\"\"\n\n# ====== Solution ======\n\ndef is_even(n):\n","entry_point":"is_even","test":"def check(candidate):\n    assert candidate(2) == True\n    assert candidate(3) == False\n    assert candidate(14) == True\n    assert candidate(15) == False\n    assert candidate(26) == True\n    assert candidate(27) == False\n\n","canonical_solution":"def is_even(n):\n    return not n & 1"}
{"task_id":3384,"prompt":"\"\"\"\n=====Problem statement====\n\nGeneral primality test are often computationally expensive, so in the biggest prime number race the idea is to study special sub-families of prime number and develop more effective tests for them. \n\n[Mersenne Primes](https:\/\/en.wikipedia.org\/wiki\/Mersenne_prime) are prime numbers of the form: Mn = 2^(n) - 1. So far, 49 of them was found between M2 (3) and M74,207,281 which contains 22,338,618 digits and is (by September 2015) the biggest known prime. It has been found by GIMPS (Great Internet Mersenne Prime Search), wich use the test srudied here. (plus heuristics mentionned below)\n\nLucas and Lehmer have developed a [simple test](https:\/\/en.wikipedia.org\/wiki\/Lucas%E2%80%93Lehmer_primality_test) for Mersenne primes: \n\n> for `p` (an odd prime), the Mersenne number Mp is prime if and only if `S(p \u2212 1) = 0 mod Mp`,\n\n>where `S(n + 1) = S(n) * S(n) \u2212 2` and `S(1) = 4`\n\nThe goal of this kata is to implement this test. Given an integer `>=2`, the program should calculate the sequence `S(n)` up to `p-1` and calculate the remainder modulo `Mp`, then return `True` or `False` as a result of the test. The case `n = 2` should return `True`.\n\nYou should take advantage of the fact that:\n\n```k = (k mod 2^n + floor(k\/2^n)) mod Mn```\n\nOr in other words, if we take the least significant `n` bits of `k`, and add the remaining bits of `k`, and then do this repeatedly until at most `n` bits remain, we can compute the remainder after dividing `k` by the Mersenne number `2^n\u22121` without using division.\n\nThis test can be improved using the fact that if `n` is not prime, `2^n-1` will not be prime. So in theory you can test for the primality of `n` beforehand. But in practice the test for the primality of `n` will rapidly outgrow in difficulty the Lucas-Lehmer test. So we can only use heuristics to rule out `n` with small factors but not complete factorization algorithm. You don't need to implement such heuristics here. \n\nThe rapid growth of `s^2` makes javascript reach its integer limit quickly (coherent result for `n = 13`, but not `17`). Whereas python seems to be only limited by the execution time limit and let us see that M11,213 is prime (contains 3376 digits).\n\"\"\"\n\n# ====== Solution ======\n\ndef lucas_lehmer(n):\n","entry_point":"lucas_lehmer","test":"def check(candidate):\n    assert candidate(2) == True\n    assert candidate(3) == True\n    assert candidate(4) == False\n    assert candidate(5) == True\n    assert candidate(7) == True\n    assert candidate(10) == False\n    assert candidate(33) == False\n    assert candidate(101) == False\n    assert candidate(11213) == True\n    assert candidate(11215) == False\n\n","canonical_solution":"def lucas_lehmer(n):\n    return n in [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279,\n                 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701,\n                 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433,\n                 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011,\n                 24036583, 25964951, 30402457, 32582657, 3715666]"}
{"task_id":3388,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that takes in a binary string and returns the equivalent decoded text (the text is ASCII encoded).\n\nEach 8 bits on the binary string represent 1 character on the ASCII table.\n\nThe input string will always be a valid binary string.\n\nCharacters can be in the range from \"00000000\" to \"11111111\" (inclusive)\n\nNote: In the case of an empty binary string your function should return an empty string.\n\"\"\"\n\n# ====== Solution ======\n\ndef binary_to_string(binary):\n","entry_point":"binary_to_string","test":"def check(candidate):\n    assert candidate('') == ''\n    assert candidate('0100100001100101011011000110110001101111') == 'Hello'\n    assert candidate('00110001001100000011000100110001') == '1011'\n    assert candidate('0101001101110000011000010111001001101011011100110010000001100110011011000110010101110111001011100010111000100000011001010110110101101111011101000110100101101111011011100111001100100000011100100110000101101110001000000110100001101001011001110110100000100001') == 'Sparks flew.. emotions ran high!'\n    assert candidate('0010000101000000001000110010010000100101010111100010011000101010001010000010100101010001010101110100010101110010011101000111100101010101010010010100111101001100011001000110011001100111011000100110001001101000011011100110110101001001010010110100001001001010010010110100100001001001010101010100111100101000001111110011111000111111001111000111111001111110011111100111111001111110001010010010100000101010001001100010010101011110001110010011100000110111001100010011001100101111001011010010111100101010001011010010101000101111') == '!@#$%^&*()QWErtyUIOLdfgbbhnmIKBJKHIUO(?>?<~~~~~)(*&%^98713\/-\/*-*\/'\n\n","canonical_solution":"def binary_to_string(binary):\n    return \"\".join( [ chr( int(binary[i: i+8], 2) ) for i in range(0, len(binary), 8) ] )"}
{"task_id":3402,"prompt":"\"\"\"\n=====Problem statement====\n\n**Debug** a function called calculate that takes 3 values. The first and third values are numbers. The second value is a character. If the character is \"+\" , \"-\", \"\\*\", or \"\/\", the function will return the result of the corresponding mathematical function on the two numbers. If the string is not one of the specified characters, the function should return null.\n\n```\ncalculate(2,\"+\", 4); \/\/Should return 6\ncalculate(6,\"-\", 1.5); \/\/Should return 4.5\ncalculate(-4,\"*\", 8); \/\/Should return -32\ncalculate(49,\"\/\", -7); \/\/Should return -7\ncalculate(8,\"m\", 2); \/\/Should return null\ncalculate(4,\"\/\",0) \/\/should return null\n```\n\nKind of a fork (not steal :)) of [Basic Calculator][1] kata by [TheDoctor][2]. \n\n[1]: http:\/\/www.codewars.com\/kata\/basic-calculator\/javascript\n[2]: http:\/\/www.codewars.com\/users\/528c45adbd9daa384300068d\n\"\"\"\n\n# ====== Solution ======\n\nfrom operator import add, sub, mul, truediv\nD = {'+':add, '-':sub, '*':mul, '\/':truediv}\n\ndef calculate(a, o, b):\n","entry_point":"calculate","test":"def check(candidate):\n    assert candidate(2,'+',4) == 6\n    assert candidate(6,'-',1.5) == 4.5\n    assert candidate(-4,'*',8) == -32\n    assert candidate(49,'\/',-7) == -7\n    assert candidate(8,'m',2) == None\n    assert candidate(4,'\/',0) == None\n    assert candidate(3.2,'+',8) == 11.2\n    assert candidate(3.2,'-',8) == -4.8\n    assert candidate(3.2,'\/',8) == 0.4\n    assert candidate(3.2,'*',8) == 25.6\n    assert candidate(-3,'+',0) == -3\n    assert candidate(-3,'-',0) == -3\n    assert candidate(-3,'\/',0) == None\n    assert candidate(-2,'\/',-2) == 1\n    assert candidate(-2,'codewars',-2) == None\n    assert candidate(-3,'*',0) == 0\n    assert candidate(0,'*',0) == 0\n    assert candidate(0,'**',0) == None\n    assert candidate(-3,'w',0) == None\n    assert candidate(0,'\/',0) == None\n\n","canonical_solution":"from operator import add, sub, mul, truediv\nD = {'+':add, '-':sub, '*':mul, '\/':truediv}\n\ndef calculate(a, o, b):\n    try: return D[o](a, b)\n    except: pass"}
{"task_id":3406,"prompt":"\"\"\"\n=====Problem statement====\n\nMutual Recursion allows us to take the fun of regular recursion (where a function calls itself until a terminating condition) and apply it to multiple functions calling each other! \n\nLet's use the Hofstadter Female and Male sequences to demonstrate this technique. You'll want to create two functions `F` and `M` such that the following equations are true: \n\n```\nF(0) = 1\nM(0) = 0\nF(n) = n - M(F(n - 1))\nM(n) = n - F(M(n - 1))\n```\n\nDon't worry about negative numbers, `n` will always be greater than or equal to zero.\n\n~~~if:php,csharp\nYou *do* have to worry about performance though, mutual recursion uses up a lot of stack space (and is highly inefficient) so you may have to find a way to make your solution consume less stack space (and time).  Good luck :)\n~~~\n\nHofstadter Wikipedia Reference http:\/\/en.wikipedia.org\/wiki\/Hofstadter_sequence#Hofstadter_Female_and_Male_sequences\n\"\"\"\n\n# ====== Solution ======\n\ndef f(n): return n - m(f(n-1)) if n else 1\n","entry_point":"f","test":"def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(5) == 3\n    assert candidate(10) == 6\n    assert candidate(15) == 9\n    assert candidate(25) == 16\n\n","canonical_solution":"def f(n): return n - m(f(n-1)) if n else 1\n\ndef m(n): return n - f(m(n-1)) if n else 0"}
{"task_id":3416,"prompt":"\"\"\"\n=====Problem statement====\n\nJohn is developing a system to report fuel usage but needs help with the coding.\n\nFirst, he needs you to write a function that, given the actual consumption (in l\/100 km) and remaining amount of petrol (in l), will give you how many kilometers you'll be able to drive.\n\nSecond, he needs you to write a function that, given a distance (in km), a consumption (in l\/100 km), and an amount of petrol (in l), will return one of the following: If you can't make the distance without refueling, it should return the message \"You will need to refuel\". If you can make the distance, the function will check every 100 km and produce an array with [1:kilometers already driven. 2: kilometers till end. 3: remaining amount of petrol] and return all the arrays inside another array ([[after 100km], [after 200km], [after 300km]...])\n\nPLEASE NOTE: any of the values with decimals that you return should be rounded to 2 decimals.\n\"\"\"\n\n# ====== Solution ======\n\ndef total_kilometers(cons, petrol):\n","entry_point":"total_kilometers","test":"def check(candidate):\n    assert candidate(10,60) == 600\n    assert candidate(8,0) == 0\n    assert candidate(6.4,54) == 843.75\n    assert candidate(9.3,87.3) == 938.71\n    assert candidate(11.7,63.4) == 541.88\n\n","canonical_solution":"def total_kilometers(cons, petrol):\n    return round(100*petrol\/cons, 2)\n\ndef check_distance(dist, cons, petrol):\n    return (\"You will need to refuel\" if dist > total_kilometers(cons, petrol) else\n            [ [n*100, dist-100*n, round(petrol-cons*n, 2)] for n in range(dist\/\/100+1)])"}
{"task_id":3427,"prompt":"\"\"\"\n=====Problem statement====\n\nThere is an array with some numbers. All numbers are equal except for one. Try to find it!\n\n```python\nfind_uniq([ 1, 1, 1, 2, 1, 1 ]) == 2\nfind_uniq([ 0, 0, 0.55, 0, 0 ]) == 0.55\n```\n\nIt\u2019s guaranteed that array contains at least 3 numbers.\n\nThe tests contain some very huge arrays, so think about performance.\n\nThis is the first kata in series:\n\n1. Find the unique number (this kata)\n2. [Find the unique string](https:\/\/www.codewars.com\/kata\/585d8c8a28bc7403ea0000c3)\n3. [Find The Unique](https:\/\/www.codewars.com\/kata\/5862e0db4f7ab47bed0000e5)\n\"\"\"\n\n# ====== Solution ======\n\ndef find_uniq(arr):\n","entry_point":"find_uniq","test":"def check(candidate):\n    assert candidate([1, 1, 1, 2, 1, 1]) == 2\n    assert candidate([0, 0, 0.55, 0, 0]) == 0.55\n    assert candidate([4, 4, 4, 3, 4, 4, 4, 4]) == 3\n    assert candidate([5, 5, 5, 5, 4, 5, 5, 5]) == 4\n    assert candidate([6, 6, 6, 6, 6, 5, 6, 6]) == 5\n    assert candidate([7, 7, 7, 7, 7, 7, 6, 7]) == 6\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 7]) == 7\n    assert candidate([3, 3, 3, 3, 3, 3, 3, 2]) == 2\n    assert candidate([2, 2, 2, 2, 2, 2, 2, 1]) == 1\n    assert candidate([0, 1, 1, 1, 1, 1, 1, 1]) == 0\n\n","canonical_solution":"def find_uniq(arr):\n    a, b = set(arr)\n    return a if arr.count(a) == 1 else b"}
{"task_id":3433,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array containing only zeros and ones, find the index of the zero that, if converted to one, will make the longest sequence of ones.\n\nFor instance, given the array:\n\n```\n[1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1]\n```\n\nreplacing the zero at index 10 (counting from 0) forms a sequence of 9 ones:\n\n```\n[1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1]\n                  '------------^------------'\n```\n\n\nYour task is to complete the function that determines where to replace a zero with a one to make the maximum length subsequence.\n\n\n**Notes:**\n- If there are multiple results, return the last one:\n\n `[1, 1, 0, 1, 1, 0, 1, 1] ==> 5`\n\n\n- The array will always contain only zeros and ones.\n\n\nCan you do this in one pass?\n\"\"\"\n\n# ====== Solution ======\n\ndef replace_zero(arr):\n","entry_point":"replace_zero","test":"def check(candidate):\n    assert candidate([1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1]) == 10\n    assert candidate([1, 1, 0, 1, 1, 0, 1, 1]) == 5\n    assert candidate([1, 1, 1, 0, 1, 1, 0, 1, 1, 1]) == 6\n    assert candidate([0, 1, 1, 1]) == 0\n    assert candidate([1, 1, 1, 0]) == 3\n    assert candidate([1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1]) == 10\n    assert candidate([0, 0, 0, 0, 0, 1]) == 4\n    assert candidate([0, 0, 0, 0, 1, 0]) == 5\n    assert candidate([1, 0, 0, 0, 0, 0]) == 1\n    assert candidate([0, 1, 0, 0, 0, 0]) == 2\n\n","canonical_solution":"def replace_zero(arr):\n    m, im, i, lst = 0, -1, -1, ''.join(map(str,arr)).split('0')\n    for a,b in zip(lst,lst[1:]):\n        i += len(a) + 1 \n        candidate = len(a)+len(b)+1\n        if m <= candidate:\n            im, m = i, candidate\n    return im"}
{"task_id":3436,"prompt":"\"\"\"\n=====Problem statement====\n\nDescription\n\nIn English we often use \"neutral vowel sounds\" such as \"umm\", \"err\", \"ahh\" as fillers in conversations to help them run smoothly.\n\nBob always finds himself saying \"err\". Infact he adds an \"err\" to every single word he says that ends in a consonant! Because Bob is odd, he likes to stick to this habit even when emailing. \n\nTask\n\nBob is begging you to write a function that adds \"err\" to the end of every word whose last letter is a consonant (not a vowel, y counts as a consonant). \n\nThe input is a string that can contain upper and lowercase characters, some punctuation but no numbers. The solution should be returned as a string.\n\nNOTE: If the word ends with an uppercase consonant, the following \"err\" will be uppercase --> \"ERR\".\n\neg:\n```\n\"Hello, I am Mr Bob\" --> \"Hello, I amerr Mrerr Boberr\"\n\n\"THIS IS CRAZY!\"  --> \"THISERR ISERR CRAZYERR!\"\n```\n\n\nGood luck!\n\"\"\"\n\n# ====== Solution ======\n\ndef err_bob(s):\n","entry_point":"err_bob","test":"def check(candidate):\n    assert candidate('r r r r r r r r') == 'rerr rerr rerr rerr rerr rerr rerr rerr'\n    assert candidate('THIS, is crazy!') == 'THISERR, iserr crazyerr!'\n    assert candidate('hI, hi. hI hi skY! sky? skY sky') == 'hI, hi. hI hi skYERR! skyerr? skYERR skyerr'\n    assert candidate('Hello, I am Mr Bob.') == 'Hello, I amerr Mrerr Boberr.'\n    assert candidate('This, is. another! test? case to check your beautiful code.') == 'Thiserr, iserr. anothererr! testerr? case to checkerr yourerr beautifulerr code.'\n    assert candidate('Hello from the other siiiiideeee') == 'Hello fromerr the othererr siiiiideeee'\n    assert candidate('Punctuation? is, important!  double space also') == 'Punctuationerr? iserr, importanterr!  double space also'\n\n","canonical_solution":"def err_bob(s):\n    res = \"\"\n    for i, c in enumerate(s):\n        res += c\n        if i == len(s)-1 or s[i+1] in \" .,:;!?\":\n            if c.islower() and c not in \"aeiou\":\n                res += \"err\"\n            if c.isupper() and c not in \"AEIOU\":\n                res += \"ERR\"\n    return res"}
{"task_id":3440,"prompt":"\"\"\"\n=====Problem statement====\n\n# Description\n\nGiven a number `n`, you should find a set of numbers for which the sum equals `n`. This set must consist exclusively of values that are a power of `2` (eg: `2^0 => 1, 2^1 => 2, 2^2 => 4, ...`).\n\nThe function `powers` takes a single parameter, the number `n`, and should return an array of unique numbers.\n\n## Criteria\n\nThe function will always receive a valid input: any positive integer between `1` and the max integer value for your language (eg: for JavaScript this would be `9007199254740991` otherwise known as `Number.MAX_SAFE_INTEGER`).\n\nThe function should return an array of numbers that are a **power of 2** (`2^x = y`).\n\nEach member of the returned array should be **unique**. (eg: the valid answer for `powers(2)` is `[2]`, not `[1, 1]`)\n\nMembers should be sorted in **ascending order** (small -> large). (eg: the valid answer for `powers(6)` is `[2, 4]`, not `[4, 2]`)\n\"\"\"\n\n# ====== Solution ======\n\ndef powers(n):\n","entry_point":"powers","test":"def check(candidate):\n    assert candidate(1) == [1]\n    assert candidate(2) == [2]\n    assert candidate(4) == [4]\n    assert candidate(32) == [32]\n    assert candidate(128) == [128]\n    assert candidate(512) == [512]\n    assert candidate(6) == [2, 4]\n    assert candidate(14) == [2, 4, 8]\n    assert candidate(688) == [16, 32, 128, 512]\n    assert candidate(8197) == [1, 4, 8192]\n    assert candidate(1966) == [2, 4, 8, 32, 128, 256, 512, 1024]\n    assert candidate(9007199254740991) == [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 140737488355328, 281474976710656, 562949953421312, 1125899906842624, 2251799813685248, 4503599627370496]\n\n","canonical_solution":"def powers(n):\n    return [1<<i for i, x in enumerate(reversed(bin(n))) if x == \"1\"]"}
{"task_id":3443,"prompt":"\"\"\"\n=====Problem statement====\n\nA system is transmitting messages in binary, however it is not a perfect transmission, and sometimes errors will occur which result in a single bit flipping from 0 to 1, or from 1 to 0.\n\nTo resolve this, A 2-dimensional Parity Bit Code is used: https:\/\/en.wikipedia.org\/wiki\/Multidimensional_parity-check_code\n\nIn this system, a message is arrayed out on a M x N grid. A 24-bit message could be put on a 4x6 grid like so:\n\n\n>1 0 1 0 0 1\n>1 0 0 1 0 0\n>0 1 1 1 0 1\n>1 0 0 0 0 1\n\nThen, Parity bits are computed for each row and for each column, equal to 1 if there is an odd number of 1s in the row of column, and 0 if it is an even number. The result for the above message looks like:\n\n\n>1 0 1 0 0 1 1\n>1 0 0 1 0 0 0\n>0 1 1 1 0 1 0\n>1 0 0 0 0 1 0\n>1 1 0 0 0 1\n\nSince the 1st row, and 1st, 2nd and 6th column each have an odd number of 1s in them, and the others all do not.\n\nThen the whole message is sent, including the parity bits. This is arranged as:\n\n> message + row_parities + column_parities\n> 101001100100011101100001 + 1000 + 110001\n> 1010011001000111011000011000110001\n\nIf an error occurs in transmission, the parity bit for a column and row will be incorrect, which can be used to identify and correct the error. If a row parity bit is incorrect, but all column bits are correct, then we can assume the row parity bit was the one flipped, and likewise if a column is wrong but all rows are correct.\n\n Your Task: \n\nCreate a function correct, which takes in integers M and N, and a string of bits where the first M\\*N represent the content of the message, the next M represent the parity bits for the rows, and the final N represent the parity bits for the columns. A single-bit error may or may not have appeared in the bit array.\n\nThe function should check to see if there is a single-bit error in the coded message, correct it if it exists, and return the corrected string of bits.\n\"\"\"\n\n# ====== Solution ======\n\ndef correct(m, n, bits):\n","entry_point":"correct","test":"def check(candidate):\n    assert candidate(1,1,'111') == '111'\n    assert candidate(1,1,'011') == '111'\n    assert candidate(1,1,'101') == '111'\n    assert candidate(1,1,'110') == '111'\n    assert candidate(2,3,'11111010001') == '11111010001'\n    assert candidate(2,3,'11011010001') == '11111010001'\n    assert candidate(2,3,'11111011001') == '11111010001'\n    assert candidate(2,3,'11111010011') == '11111010001'\n\n","canonical_solution":"def correct(m, n, bits):\n    l = m*n\n    row = next((i for i in range(m) if f\"{bits[i*n:(i+1)*n]}{bits[l+i]}\".count(\"1\") % 2), None)\n    col = next((i for i in range(n) if f\"{bits[i:l:n]}{bits[l+m+i]}\".count(\"1\") % 2), None)\n    if row is col is None:\n        return bits\n    err = (l + row) if col is None else (l + m + col) if row is None else (row * n + col)\n    return f\"{bits[:err]}{int(bits[err])^1}{bits[err+1:]}\"\n"}
{"task_id":3450,"prompt":"\"\"\"\n=====Problem statement====\n\nThis is a spin off of my first [kata](http:\/\/www.codewars.com\/kata\/56bc28ad5bdaeb48760009b0). You are given a list of character sequences as a comma separated string. Write a function which returns another string containing all the character sequences except the first and the last ones, separated by spaces. If the input string is empty, or the removal of the first and last items would cause the string to be empty, return a null value.\n\"\"\"\n\n# ====== Solution ======\n\ndef array(strng):\n","entry_point":"array","test":"def check(candidate):\n    assert candidate('') == None\n    assert candidate('1') == None\n    assert candidate('1, 3') == None\n    assert candidate('1,2,3') == '2'\n    assert candidate('1,2,3,4') == '2 3'\n\n","canonical_solution":"def array(strng):\n    return ' '.join(strng.split(',')[1:-1]) or None\n"}
{"task_id":3452,"prompt":"\"\"\"\n=====Problem statement====\n\nThe snail crawls up the column. During the day it crawls up some distance. During the night she sleeps, so she slides down for some distance (less than crawls up during the day).\n\nYour function takes three arguments:\n1. The height of the column (meters)\n2. The distance that the snail crawls during the day (meters)\n3. The distance that the snail slides down during the night (meters)\n\nCalculate number of day when the snail will reach the top of the column.\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil\n\n\ndef snail(column, day, night):\n","entry_point":"snail","test":"def check(candidate):\n    assert candidate(3,2,1) == 2\n    assert candidate(10,3,1) == 5\n    assert candidate(10,3,2) == 8\n    assert candidate(100,20,5) == 7\n    assert candidate(5,10,3) == 1\n\n","canonical_solution":"from math import ceil\n\n\ndef snail(column, day, night):\n    return max(ceil((column-night)\/(day-night)), 1)"}
{"task_id":3454,"prompt":"\"\"\"\n=====Problem statement====\n\nDescription overhauled by V\n\n---\n\nI've invited some kids for my son's birthday, during which I will give to each kid some amount of candies.\n\nEvery kid hates receiving less amount of candies than any other kids, and I don't want to have any candies left - giving it to my kid would be bad for his teeth.\n\nHowever, not every kid invited will come to my birthday party.\n\nWhat is the minimum amount of candies I have to buy, so that no matter how many kids come to the party in the end, I can still ensure that each kid can receive the same amount of candies, while leaving no candies left?\n\nIt's ensured that at least one kid will participate in the party.\n\"\"\"\n\n# ====== Solution ======\n\ndef candies_to_buy(n):\n","entry_point":"candies_to_buy","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 2\n    assert candidate(5) == 60\n    assert candidate(6) == 60\n    assert candidate(9) == 2520\n    assert candidate(10) == 2520\n    assert candidate(60) == 9690712164777231700912800\n    assert candidate(61) == 591133442051411133755680800\n    assert candidate(100) == 69720375229712477164533808935312303556800\n    assert candidate(101) == 7041757898200960193617914702466542659236800\n\n","canonical_solution":"def candies_to_buy(n):\n    xx = 1\n    for i in range(n):\n        x = xx\n        while xx % (i+1):\n            xx += x\n    return xx"}
{"task_id":3461,"prompt":"\"\"\"\n=====Problem statement====\n\n# Two samurai generals are discussing dinner plans after a battle, but they can't seem to agree.\n\nThe discussion gets heated and you are cannot risk favoring either of them as this might damage your political standing with either of the two clans the samurai generals belong to. Thus, the only thing left to do is find what the common ground of what they are saying is.\n\nCompare the proposals with the following function: \n```python\ndef common_ground(s1,s2)\n```\n\nThe parameters ```s1``` and ```s2``` are the strings representing what each of the generals said. You should output a string containing the words in ```s1``` that also occur in ```s2```.\n\nEach word in the resulting string shall occur once, and the order of the words need to follow the order of the first occurence of each word in ```s2```.\n\nIf they are saying nothing in common, kill both samurai and blame a ninja. (output \"death\")\n\"\"\"\n\n# ====== Solution ======\n\ndef common_ground(s1,s2):\n","entry_point":"common_ground","test":"def check(candidate):\n    assert candidate('eat chicken','eat chicken and rice') == 'eat chicken'\n    assert candidate('eat a burger and drink a coke','drink a coke') == 'drink a coke'\n    assert candidate('i like turtles','what are you talking about') == 'death'\n    assert candidate('aa bb','aa bb cc') == 'aa bb'\n    assert candidate('aa bb cc','bb cc') == 'bb cc'\n    assert candidate('aa bb cc','bb cc bb aa') == 'bb cc aa'\n    assert candidate('aa bb','cc dd') == 'death'\n    assert candidate('aa bb','') == 'death'\n    assert candidate('','cc dd') == 'death'\n    assert candidate('','') == 'death'\n\n","canonical_solution":"def common_ground(s1,s2):\n    lst = []\n    for w in s2.split():\n        if w in s1.split() and w not in lst:\n            lst.append(w)\n    return ' '.join(lst) if lst else \"death\""}
{"task_id":3466,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function that will return ```true``` if the input is in the following date time format ```01-09-2016 01:20``` and ```false``` if it is not.\n\nThis Kata has been inspired by the Regular Expressions chapter from the book Eloquent JavaScript.\n\"\"\"\n\n# ====== Solution ======\n\nfrom re import match\n\n\ndef date_checker(date):\n","entry_point":"date_checker","test":"def check(candidate):\n    assert candidate('01-09-2016 01:20') == True\n    assert candidate('01-09-2016 01;20') == False\n    assert candidate('01_09_2016 01:20') == False\n    assert candidate('14-10-1066 12:00') == True\n    assert candidate('Tenth of January') == False\n    assert candidate('20 Sep 1988') == False\n    assert candidate('19-12-2050 13:34') == True\n    assert candidate('Tue Sep 06 2016 01:46:38 GMT+0100') == False\n    assert candidate('01-09-2016 00:00') == True\n    assert candidate('01-09-2016 2:00') == False\n\n","canonical_solution":"from re import match\n\n\ndef date_checker(date):\n    return bool(match(r'\\d{2}-\\d{2}-\\d{4}\\s\\d{2}:\\d{2}', date))\n"}
{"task_id":3470,"prompt":"\"\"\"\n=====Problem statement====\n\nThe goal is to write a pair of functions the first of which will take a string of binary along with a specification of bits, which will return a numeric, signed complement in two's complement format. The second will do the reverse. It will take in an integer along with a number of bits, and return a binary string. \n\nhttps:\/\/en.wikipedia.org\/wiki\/Two's_complement\n\nThus, to_twos_complement should take the parameters binary = \"0000 0001\", bits = 8 should return 1. And, binary = \"11111111\", bits = 8 should return -1 . While, from_twos_complement should return \"00000000\" from the parameters n = 0, bits = 8 . And, \"11111111\" from n = -1, bits = 8. \n\nYou should account for some edge cases.\n\"\"\"\n\n# ====== Solution ======\n\ndef to_twos_complement(binary, bits):\n","entry_point":"to_twos_complement","test":"def check(candidate):\n    assert candidate('00000001',8) == 1\n    assert candidate('00000010',8) == 2\n    assert candidate('01111110',8) == 126\n    assert candidate('01111111',8) == 127\n    assert candidate('11111111',8) == -1\n    assert candidate('11111110',8) == -2\n    assert candidate('10000010',8) == -126\n    assert candidate('1000 0000',8) == -128\n    assert candidate('1010 1010 0010 0010 1110 1010 0010 1110',32) == -1440552402\n    assert candidate('1000 0000 1110 1111 0011 0100 1100 1010',32) == -2131807030\n    assert candidate('10110001000100000101100011111000',32) == -1324328712\n\n","canonical_solution":"def to_twos_complement(binary, bits):\n    return int(binary.replace(' ', ''), 2) - 2 ** bits * int(binary[0])\n\ndef from_twos_complement(n, bits):\n    return '{:0{}b}'.format(n & 2 ** bits - 1, bits)"}
{"task_id":3477,"prompt":"\"\"\"\n=====Problem statement====\n\nDefine a method that accepts 2 strings as parameters. The method returns the first string sorted by the second.\n\n```python\nsort_string(\"foos\", \"of\")       == \"oofs\"\nsort_string(\"string\", \"gnirts\") == \"gnirts\"\nsort_string(\"banana\", \"abn\")    == \"aaabnn\"\n```\n\nTo elaborate, the second string defines the ordering. It is possible that in the second string characters repeat, so you should remove repeating characters, leaving only the first occurrence.\n\nAny character in the first string that does not appear in the second string should be sorted to the end of the result in original order.\n\"\"\"\n\n# ====== Solution ======\n\ndef sort_string(s, ordering):\n","entry_point":"sort_string","test":"def check(candidate):\n    assert candidate('banana','abn') == 'aaabnn'\n    assert candidate('banana','xyz') == 'banana'\n    assert candidate('banana','an') == 'aaannb'\n    assert candidate('foos','of') == 'oofs'\n    assert candidate('string','gnirts') == 'gnirts'\n    assert candidate('banana','a') == 'aaabnn'\n    assert candidate('bungholio','aacbuoldiiaoh') == 'buoolihng'\n    assert candidate('fumyarhncujlj','nsejcwn') == 'njjcfumyarhul'\n\n","canonical_solution":"def sort_string(s, ordering):\n    answer = ''\n    for o in ordering:\n        answer += o * s.count(o)\n        s = s.replace(o,'')\n    return answer + s "}
{"task_id":3479,"prompt":"\"\"\"\n=====Problem statement====\n\nWe need a function (for commercial purposes) that may perform integer partitions with some constraints.\nThe function should select how many elements each partition should have.\nThe function should discard some \"forbidden\" values in each partition.\nSo, create ```part_const()```, that receives three arguments.\n```part_const((1), (2), (3))```\n```\n(1) - The integer to be partitioned\n\n(2) - The number of elements that each partition should have\n\n(3) - The \"forbidden\" element that cannot appear in any partition\n```\n```part_const()``` should output the amount of different integer partitions with the constraints required.\n\nLet's see some cases:\n```python\npart_const(10, 3, 2) ------> 4 \n\n\/\/\/ we may have a total of 8 partitions of three elements (of course, the sum of the elements of each partition should be equal 10) :\n[1, 1, 8], [1, 2, 7], [1, 3, 6], [1, 4, 5], [2, 2, 6], [2, 3, 5], [2, 4, 4], [3, 3, 4]\n\nbut 2 is the forbidden element, so we have to discard [1, 2, 7], [2, 2, 6], [2, 3, 5] and [2, 4, 4] \n\nSo the obtained partitions of three elements without having 2 in them are:\n[1, 1, 8], [1, 3, 6], [1, 4, 5] and [3, 3, 4] (4 partitions)\/\/\/\n```\n\n```part_const()``` should have a particular feature:\n\n if we introduce ```0``` as the forbidden element, we will obtain the total amount of partitions with the constrained number of elements.\n\nIn fact, \n```python\npart_const(10, 3, 0) ------> 8 # The same eight partitions that we saw above.\n```\n\nEnjoy it and happy coding!!\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"part_const","test":"def check(candidate):\n    assert candidate(10,3,2) == 4\n    assert candidate(10,3,0) == 8\n    assert candidate(10,4,1) == 2\n    assert candidate(10,5,3) == 4\n    assert candidate(15,5,3) == 15\n    assert candidate(15,5,4) == 19\n    assert candidate(15,3,3) == 13\n\n","canonical_solution":"def p(t,k,n,l=1):\n    if t<l: pass\n    elif k==1 and t!=n: yield [t]\n    else: yield from ([m]+s for m in range(l,t-l+1) for s in p(t-m,k-1,n,m) if m!=n)\n\ndef part_const(t,k,n): return sum(1 for _ in p(t,k,n))"}
{"task_id":3485,"prompt":"\"\"\"\n=====Problem statement====\n\nDon't Drink the Water\n\nGiven a two-dimensional array representation of a glass of mixed liquids, sort the array such that the liquids appear in the glass based on their density. (Lower density floats to the top) The width of the glass will not change from top to bottom.\n\n```\n======================\n|   Density Chart    |\n======================\n| Honey   | H | 1.36 |\n| Water   | W | 1.00 |\n| Alcohol | A | 0.87 |\n| Oil     | O | 0.80 |\n----------------------\n\n[                            [\n ['H', 'H', 'W', 'O'],        ['O','O','O','O']\n ['W', 'W', 'O', 'W'],  =>    ['W','W','W','W']\n ['H', 'H', 'O', 'O']         ['H','H','H','H']\n ]                           ]\n \n ```\n \n The glass representation may be larger or smaller. If a liquid doesn't fill a row, it floats to the top and to the left.\n\"\"\"\n\n# ====== Solution ======\n\nDENSITY = {'H': 1.36, 'W': 1, 'A': 0.87, 'O': 0.8}\n\n\ndef separate_liquids(glass):\n","entry_point":"separate_liquids","test":"def check(candidate):\n    assert candidate([['H', 'H', 'W', 'O'], ['W', 'W', 'O', 'W'], ['H', 'H', 'O', 'O']]) == [['O', 'O', 'O', 'O'], ['W', 'W', 'W', 'W'], ['H', 'H', 'H', 'H']]\n    assert candidate([['A', 'A', 'O', 'H'], ['A', 'H', 'W', 'O'], ['W', 'W', 'A', 'W'], ['H', 'H', 'O', 'O']]) == [['O', 'O', 'O', 'O'], ['A', 'A', 'A', 'A'], ['W', 'W', 'W', 'W'], ['H', 'H', 'H', 'H']]\n    assert candidate([['A', 'H', 'W', 'O']]) == [['O', 'A', 'W', 'H']]\n    assert candidate([['A'], ['H'], ['W'], ['O']]) == [['O'], ['A'], ['W'], ['H']]\n    assert candidate([]) == []\n\n","canonical_solution":"DENSITY = {'H': 1.36, 'W': 1, 'A': 0.87, 'O': 0.8}\n\n\ndef separate_liquids(glass):\n    if not glass:\n        return []\n    column = len(glass[0])\n    liquids = sorted((b for a in glass for b in a), key=lambda c: DENSITY[c])\n    return [liquids[d:d + column] for d in range(0, len(liquids), column)]\n"}
{"task_id":3488,"prompt":"\"\"\"\n=====Problem statement====\n\nSwitch\/Case - Bug Fixing #6\n\nOh no! Timmy's evalObject function doesn't work. He uses Switch\/Cases to evaluate the given properties of an object, can you fix timmy's function?\n\"\"\"\n\n# ====== Solution ======\n\ndef eval_object(v):\n","entry_point":"eval_object","test":"def check(candidate):\n    assert candidate({'a': 1, 'b': 1, 'operation': '+'}) == 2\n    assert candidate({'a': 1, 'b': 1, 'operation': '-'}) == 0\n    assert candidate({'a': 1, 'b': 1, 'operation': '\/'}) == 1\n    assert candidate({'a': 1, 'b': 1, 'operation': '*'}) == 1\n    assert candidate({'a': 1, 'b': 1, 'operation': '%'}) == 0\n    assert candidate({'a': 1, 'b': 1, 'operation': '**'}) == 1\n\n","canonical_solution":"def eval_object(v):\n    return {\"+\": v['a']+v['b'],\n            \"-\": v['a']-v['b'],\n            \"\/\": v['a']\/v['b'],\n            \"*\": v['a']*v['b'],\n            \"%\": v['a']%v['b'],\n           \"**\": v['a']**v['b'], }.get(v['operation'])"}
{"task_id":3499,"prompt":"\"\"\"\n=====Problem statement====\n\nConverting a normal (12-hour) time like \"8:30 am\" or \"8:30 pm\" to 24-hour time (like \"0830\" or \"2030\") sounds easy enough, right?  Well, let's see if you can do it!\n\nYou will have to define a function named \"to24hourtime\", and you will be given an hour (always in the range of 1 to 12, inclusive), a minute (always in the range of 0 to 59, inclusive), and a period (either \"am\" or \"pm\") as input.\n\nYour task is to return a four-digit string that encodes that time in 24-hour time.\n\"\"\"\n\n# ====== Solution ======\n\ndef to24hourtime(hour, minute, period):\n","entry_point":"to24hourtime","test":"def check(candidate):\n    assert candidate(12,0,'am') == '0000'\n    assert candidate(12,1,'am') == '0001'\n    assert candidate(12,2,'am') == '0002'\n    assert candidate(12,3,'am') == '0003'\n    assert candidate(12,4,'am') == '0004'\n    assert candidate(12,5,'am') == '0005'\n    assert candidate(12,6,'am') == '0006'\n    assert candidate(12,7,'am') == '0007'\n    assert candidate(12,8,'am') == '0008'\n    assert candidate(12,9,'am') == '0009'\n    assert candidate(12,10,'am') == '0010'\n    assert candidate(12,11,'am') == '0011'\n    assert candidate(12,12,'am') == '0012'\n    assert candidate(12,13,'am') == '0013'\n    assert candidate(12,14,'am') == '0014'\n    assert candidate(12,15,'am') == '0015'\n    assert candidate(12,16,'am') == '0016'\n    assert candidate(12,17,'am') == '0017'\n    assert candidate(12,18,'am') == '0018'\n    assert candidate(12,19,'am') == '0019'\n    assert candidate(12,20,'am') == '0020'\n    assert candidate(12,21,'am') == '0021'\n    assert candidate(12,22,'am') == '0022'\n    assert candidate(12,23,'am') == '0023'\n    assert candidate(12,24,'am') == '0024'\n    assert candidate(12,25,'am') == '0025'\n    assert candidate(12,26,'am') == '0026'\n    assert candidate(12,27,'am') == '0027'\n    assert candidate(12,28,'am') == '0028'\n    assert candidate(12,29,'am') == '0029'\n    assert candidate(12,30,'am') == '0030'\n    assert candidate(12,31,'am') == '0031'\n    assert candidate(12,32,'am') == '0032'\n    assert candidate(12,33,'am') == '0033'\n    assert candidate(12,34,'am') == '0034'\n    assert candidate(12,35,'am') == '0035'\n    assert candidate(12,36,'am') == '0036'\n    assert candidate(12,37,'am') == '0037'\n    assert candidate(12,38,'am') == '0038'\n    assert candidate(12,39,'am') == '0039'\n    assert candidate(12,40,'am') == '0040'\n    assert candidate(12,41,'am') == '0041'\n    assert candidate(12,42,'am') == '0042'\n    assert candidate(12,43,'am') == '0043'\n    assert candidate(12,44,'am') == '0044'\n    assert candidate(12,45,'am') == '0045'\n    assert candidate(12,46,'am') == '0046'\n    assert candidate(12,47,'am') == '0047'\n    assert candidate(12,48,'am') == '0048'\n    assert candidate(12,49,'am') == '0049'\n    assert candidate(12,50,'am') == '0050'\n    assert candidate(12,51,'am') == '0051'\n    assert candidate(12,52,'am') == '0052'\n    assert candidate(12,53,'am') == '0053'\n    assert candidate(12,54,'am') == '0054'\n    assert candidate(12,55,'am') == '0055'\n    assert candidate(12,56,'am') == '0056'\n    assert candidate(12,57,'am') == '0057'\n    assert candidate(12,58,'am') == '0058'\n    assert candidate(12,59,'am') == '0059'\n    assert candidate(1,0,'am') == '0100'\n    assert candidate(1,1,'am') == '0101'\n    assert candidate(1,2,'am') == '0102'\n    assert candidate(1,3,'am') == '0103'\n    assert candidate(1,4,'am') == '0104'\n    assert candidate(1,5,'am') == '0105'\n    assert candidate(1,6,'am') == '0106'\n    assert candidate(1,7,'am') == '0107'\n    assert candidate(1,8,'am') == '0108'\n    assert candidate(1,9,'am') == '0109'\n    assert candidate(1,10,'am') == '0110'\n    assert candidate(1,11,'am') == '0111'\n    assert candidate(1,12,'am') == '0112'\n    assert candidate(1,13,'am') == '0113'\n    assert candidate(1,14,'am') == '0114'\n    assert candidate(1,15,'am') == '0115'\n    assert candidate(1,16,'am') == '0116'\n    assert candidate(1,17,'am') == '0117'\n    assert candidate(1,18,'am') == '0118'\n    assert candidate(1,19,'am') == '0119'\n    assert candidate(1,20,'am') == '0120'\n    assert candidate(1,21,'am') == '0121'\n    assert candidate(1,22,'am') == '0122'\n    assert candidate(1,23,'am') == '0123'\n    assert candidate(1,24,'am') == '0124'\n    assert candidate(1,25,'am') == '0125'\n    assert candidate(1,26,'am') == '0126'\n    assert candidate(1,27,'am') == '0127'\n    assert candidate(1,28,'am') == '0128'\n    assert candidate(1,29,'am') == '0129'\n    assert candidate(1,30,'am') == '0130'\n    assert candidate(1,31,'am') == '0131'\n    assert candidate(1,32,'am') == '0132'\n    assert candidate(1,33,'am') == '0133'\n    assert candidate(1,34,'am') == '0134'\n    assert candidate(1,35,'am') == '0135'\n    assert candidate(1,36,'am') == '0136'\n    assert candidate(1,37,'am') == '0137'\n    assert candidate(1,38,'am') == '0138'\n    assert candidate(1,39,'am') == '0139'\n    assert candidate(1,40,'am') == '0140'\n    assert candidate(1,41,'am') == '0141'\n    assert candidate(1,42,'am') == '0142'\n    assert candidate(1,43,'am') == '0143'\n    assert candidate(1,44,'am') == '0144'\n    assert candidate(1,45,'am') == '0145'\n    assert candidate(1,46,'am') == '0146'\n    assert candidate(1,47,'am') == '0147'\n    assert candidate(1,48,'am') == '0148'\n    assert candidate(1,49,'am') == '0149'\n    assert candidate(1,50,'am') == '0150'\n    assert candidate(1,51,'am') == '0151'\n    assert candidate(1,52,'am') == '0152'\n    assert candidate(1,53,'am') == '0153'\n    assert candidate(1,54,'am') == '0154'\n    assert candidate(1,55,'am') == '0155'\n    assert candidate(1,56,'am') == '0156'\n    assert candidate(1,57,'am') == '0157'\n    assert candidate(1,58,'am') == '0158'\n    assert candidate(1,59,'am') == '0159'\n    assert candidate(2,0,'am') == '0200'\n    assert candidate(2,1,'am') == '0201'\n    assert candidate(2,2,'am') == '0202'\n    assert candidate(2,3,'am') == '0203'\n    assert candidate(2,4,'am') == '0204'\n    assert candidate(2,5,'am') == '0205'\n    assert candidate(2,6,'am') == '0206'\n    assert candidate(2,7,'am') == '0207'\n    assert candidate(2,8,'am') == '0208'\n    assert candidate(2,9,'am') == '0209'\n    assert candidate(2,10,'am') == '0210'\n    assert candidate(2,11,'am') == '0211'\n    assert candidate(2,12,'am') == '0212'\n    assert candidate(2,13,'am') == '0213'\n    assert candidate(2,14,'am') == '0214'\n    assert candidate(2,15,'am') == '0215'\n    assert candidate(2,16,'am') == '0216'\n    assert candidate(2,17,'am') == '0217'\n    assert candidate(2,18,'am') == '0218'\n    assert candidate(2,19,'am') == '0219'\n    assert candidate(2,20,'am') == '0220'\n    assert candidate(2,21,'am') == '0221'\n    assert candidate(2,22,'am') == '0222'\n    assert candidate(2,23,'am') == '0223'\n    assert candidate(2,24,'am') == '0224'\n    assert candidate(2,25,'am') == '0225'\n    assert candidate(2,26,'am') == '0226'\n    assert candidate(2,27,'am') == '0227'\n    assert candidate(2,28,'am') == '0228'\n    assert candidate(2,29,'am') == '0229'\n    assert candidate(2,30,'am') == '0230'\n    assert candidate(2,31,'am') == '0231'\n    assert candidate(2,32,'am') == '0232'\n    assert candidate(2,33,'am') == '0233'\n    assert candidate(2,34,'am') == '0234'\n    assert candidate(2,35,'am') == '0235'\n    assert candidate(2,36,'am') == '0236'\n    assert candidate(2,37,'am') == '0237'\n    assert candidate(2,38,'am') == '0238'\n    assert candidate(2,39,'am') == '0239'\n    assert candidate(2,40,'am') == '0240'\n    assert candidate(2,41,'am') == '0241'\n    assert candidate(2,42,'am') == '0242'\n    assert candidate(2,43,'am') == '0243'\n    assert candidate(2,44,'am') == '0244'\n    assert candidate(2,45,'am') == '0245'\n    assert candidate(2,46,'am') == '0246'\n    assert candidate(2,47,'am') == '0247'\n    assert candidate(2,48,'am') == '0248'\n    assert candidate(2,49,'am') == '0249'\n    assert candidate(2,50,'am') == '0250'\n    assert candidate(2,51,'am') == '0251'\n    assert candidate(2,52,'am') == '0252'\n    assert candidate(2,53,'am') == '0253'\n    assert candidate(2,54,'am') == '0254'\n    assert candidate(2,55,'am') == '0255'\n    assert candidate(2,56,'am') == '0256'\n    assert candidate(2,57,'am') == '0257'\n    assert candidate(2,58,'am') == '0258'\n    assert candidate(2,59,'am') == '0259'\n    assert candidate(3,0,'am') == '0300'\n    assert candidate(3,1,'am') == '0301'\n    assert candidate(3,2,'am') == '0302'\n    assert candidate(3,3,'am') == '0303'\n    assert candidate(3,4,'am') == '0304'\n    assert candidate(3,5,'am') == '0305'\n    assert candidate(3,6,'am') == '0306'\n    assert candidate(3,7,'am') == '0307'\n    assert candidate(3,8,'am') == '0308'\n    assert candidate(3,9,'am') == '0309'\n    assert candidate(3,10,'am') == '0310'\n    assert candidate(3,11,'am') == '0311'\n    assert candidate(3,12,'am') == '0312'\n    assert candidate(3,13,'am') == '0313'\n    assert candidate(3,14,'am') == '0314'\n    assert candidate(3,15,'am') == '0315'\n    assert candidate(3,16,'am') == '0316'\n    assert candidate(3,17,'am') == '0317'\n    assert candidate(3,18,'am') == '0318'\n    assert candidate(3,19,'am') == '0319'\n    assert candidate(3,20,'am') == '0320'\n    assert candidate(3,21,'am') == '0321'\n    assert candidate(3,22,'am') == '0322'\n    assert candidate(3,23,'am') == '0323'\n    assert candidate(3,24,'am') == '0324'\n    assert candidate(3,25,'am') == '0325'\n    assert candidate(3,26,'am') == '0326'\n    assert candidate(3,27,'am') == '0327'\n    assert candidate(3,28,'am') == '0328'\n    assert candidate(3,29,'am') == '0329'\n    assert candidate(3,30,'am') == '0330'\n    assert candidate(3,31,'am') == '0331'\n    assert candidate(3,32,'am') == '0332'\n    assert candidate(3,33,'am') == '0333'\n    assert candidate(3,34,'am') == '0334'\n    assert candidate(3,35,'am') == '0335'\n    assert candidate(3,36,'am') == '0336'\n    assert candidate(3,37,'am') == '0337'\n    assert candidate(3,38,'am') == '0338'\n    assert candidate(3,39,'am') == '0339'\n    assert candidate(3,40,'am') == '0340'\n    assert candidate(3,41,'am') == '0341'\n    assert candidate(3,42,'am') == '0342'\n    assert candidate(3,43,'am') == '0343'\n    assert candidate(3,44,'am') == '0344'\n    assert candidate(3,45,'am') == '0345'\n    assert candidate(3,46,'am') == '0346'\n    assert candidate(3,47,'am') == '0347'\n    assert candidate(3,48,'am') == '0348'\n    assert candidate(3,49,'am') == '0349'\n    assert candidate(3,50,'am') == '0350'\n    assert candidate(3,51,'am') == '0351'\n    assert candidate(3,52,'am') == '0352'\n    assert candidate(3,53,'am') == '0353'\n    assert candidate(3,54,'am') == '0354'\n    assert candidate(3,55,'am') == '0355'\n    assert candidate(3,56,'am') == '0356'\n    assert candidate(3,57,'am') == '0357'\n    assert candidate(3,58,'am') == '0358'\n    assert candidate(3,59,'am') == '0359'\n    assert candidate(4,0,'am') == '0400'\n    assert candidate(4,1,'am') == '0401'\n    assert candidate(4,2,'am') == '0402'\n    assert candidate(4,3,'am') == '0403'\n    assert candidate(4,4,'am') == '0404'\n    assert candidate(4,5,'am') == '0405'\n    assert candidate(4,6,'am') == '0406'\n    assert candidate(4,7,'am') == '0407'\n    assert candidate(4,8,'am') == '0408'\n    assert candidate(4,9,'am') == '0409'\n    assert candidate(4,10,'am') == '0410'\n    assert candidate(4,11,'am') == '0411'\n    assert candidate(4,12,'am') == '0412'\n    assert candidate(4,13,'am') == '0413'\n    assert candidate(4,14,'am') == '0414'\n    assert candidate(4,15,'am') == '0415'\n    assert candidate(4,16,'am') == '0416'\n    assert candidate(4,17,'am') == '0417'\n    assert candidate(4,18,'am') == '0418'\n    assert candidate(4,19,'am') == '0419'\n    assert candidate(4,20,'am') == '0420'\n    assert candidate(4,21,'am') == '0421'\n    assert candidate(4,22,'am') == '0422'\n    assert candidate(4,23,'am') == '0423'\n    assert candidate(4,24,'am') == '0424'\n    assert candidate(4,25,'am') == '0425'\n    assert candidate(4,26,'am') == '0426'\n    assert candidate(4,27,'am') == '0427'\n    assert candidate(4,28,'am') == '0428'\n    assert candidate(4,29,'am') == '0429'\n    assert candidate(4,30,'am') == '0430'\n    assert candidate(4,31,'am') == '0431'\n    assert candidate(4,32,'am') == '0432'\n    assert candidate(4,33,'am') == '0433'\n    assert candidate(4,34,'am') == '0434'\n    assert candidate(4,35,'am') == '0435'\n    assert candidate(4,36,'am') == '0436'\n    assert candidate(4,37,'am') == '0437'\n    assert candidate(4,38,'am') == '0438'\n    assert candidate(4,39,'am') == '0439'\n    assert candidate(4,40,'am') == '0440'\n    assert candidate(4,41,'am') == '0441'\n    assert candidate(4,42,'am') == '0442'\n    assert candidate(4,43,'am') == '0443'\n    assert candidate(4,44,'am') == '0444'\n    assert candidate(4,45,'am') == '0445'\n    assert candidate(4,46,'am') == '0446'\n    assert candidate(4,47,'am') == '0447'\n    assert candidate(4,48,'am') == '0448'\n    assert candidate(4,49,'am') == '0449'\n    assert candidate(4,50,'am') == '0450'\n    assert candidate(4,51,'am') == '0451'\n    assert candidate(4,52,'am') == '0452'\n    assert candidate(4,53,'am') == '0453'\n    assert candidate(4,54,'am') == '0454'\n    assert candidate(4,55,'am') == '0455'\n    assert candidate(4,56,'am') == '0456'\n    assert candidate(4,57,'am') == '0457'\n    assert candidate(4,58,'am') == '0458'\n    assert candidate(4,59,'am') == '0459'\n    assert candidate(5,0,'am') == '0500'\n    assert candidate(5,1,'am') == '0501'\n    assert candidate(5,2,'am') == '0502'\n    assert candidate(5,3,'am') == '0503'\n    assert candidate(5,4,'am') == '0504'\n    assert candidate(5,5,'am') == '0505'\n    assert candidate(5,6,'am') == '0506'\n    assert candidate(5,7,'am') == '0507'\n    assert candidate(5,8,'am') == '0508'\n    assert candidate(5,9,'am') == '0509'\n    assert candidate(5,10,'am') == '0510'\n    assert candidate(5,11,'am') == '0511'\n    assert candidate(5,12,'am') == '0512'\n    assert candidate(5,13,'am') == '0513'\n    assert candidate(5,14,'am') == '0514'\n    assert candidate(5,15,'am') == '0515'\n    assert candidate(5,16,'am') == '0516'\n    assert candidate(5,17,'am') == '0517'\n    assert candidate(5,18,'am') == '0518'\n    assert candidate(5,19,'am') == '0519'\n    assert candidate(5,20,'am') == '0520'\n    assert candidate(5,21,'am') == '0521'\n    assert candidate(5,22,'am') == '0522'\n    assert candidate(5,23,'am') == '0523'\n    assert candidate(5,24,'am') == '0524'\n    assert candidate(5,25,'am') == '0525'\n    assert candidate(5,26,'am') == '0526'\n    assert candidate(5,27,'am') == '0527'\n    assert candidate(5,28,'am') == '0528'\n    assert candidate(5,29,'am') == '0529'\n    assert candidate(5,30,'am') == '0530'\n    assert candidate(5,31,'am') == '0531'\n    assert candidate(5,32,'am') == '0532'\n    assert candidate(5,33,'am') == '0533'\n    assert candidate(5,34,'am') == '0534'\n    assert candidate(5,35,'am') == '0535'\n    assert candidate(5,36,'am') == '0536'\n    assert candidate(5,37,'am') == '0537'\n    assert candidate(5,38,'am') == '0538'\n    assert candidate(5,39,'am') == '0539'\n    assert candidate(5,40,'am') == '0540'\n    assert candidate(5,41,'am') == '0541'\n    assert candidate(5,42,'am') == '0542'\n    assert candidate(5,43,'am') == '0543'\n    assert candidate(5,44,'am') == '0544'\n    assert candidate(5,45,'am') == '0545'\n    assert candidate(5,46,'am') == '0546'\n    assert candidate(5,47,'am') == '0547'\n    assert candidate(5,48,'am') == '0548'\n    assert candidate(5,49,'am') == '0549'\n    assert candidate(5,50,'am') == '0550'\n    assert candidate(5,51,'am') == '0551'\n    assert candidate(5,52,'am') == '0552'\n    assert candidate(5,53,'am') == '0553'\n    assert candidate(5,54,'am') == '0554'\n    assert candidate(5,55,'am') == '0555'\n    assert candidate(5,56,'am') == '0556'\n    assert candidate(5,57,'am') == '0557'\n    assert candidate(5,58,'am') == '0558'\n    assert candidate(5,59,'am') == '0559'\n    assert candidate(6,0,'am') == '0600'\n    assert candidate(6,1,'am') == '0601'\n    assert candidate(6,2,'am') == '0602'\n    assert candidate(6,3,'am') == '0603'\n    assert candidate(6,4,'am') == '0604'\n    assert candidate(6,5,'am') == '0605'\n    assert candidate(6,6,'am') == '0606'\n    assert candidate(6,7,'am') == '0607'\n    assert candidate(6,8,'am') == '0608'\n    assert candidate(6,9,'am') == '0609'\n    assert candidate(6,10,'am') == '0610'\n    assert candidate(6,11,'am') == '0611'\n    assert candidate(6,12,'am') == '0612'\n    assert candidate(6,13,'am') == '0613'\n    assert candidate(6,14,'am') == '0614'\n    assert candidate(6,15,'am') == '0615'\n    assert candidate(6,16,'am') == '0616'\n    assert candidate(6,17,'am') == '0617'\n    assert candidate(6,18,'am') == '0618'\n    assert candidate(6,19,'am') == '0619'\n    assert candidate(6,20,'am') == '0620'\n    assert candidate(6,21,'am') == '0621'\n    assert candidate(6,22,'am') == '0622'\n    assert candidate(6,23,'am') == '0623'\n    assert candidate(6,24,'am') == '0624'\n    assert candidate(6,25,'am') == '0625'\n    assert candidate(6,26,'am') == '0626'\n    assert candidate(6,27,'am') == '0627'\n    assert candidate(6,28,'am') == '0628'\n    assert candidate(6,29,'am') == '0629'\n    assert candidate(6,30,'am') == '0630'\n    assert candidate(6,31,'am') == '0631'\n    assert candidate(6,32,'am') == '0632'\n    assert candidate(6,33,'am') == '0633'\n    assert candidate(6,34,'am') == '0634'\n    assert candidate(6,35,'am') == '0635'\n    assert candidate(6,36,'am') == '0636'\n    assert candidate(6,37,'am') == '0637'\n    assert candidate(6,38,'am') == '0638'\n    assert candidate(6,39,'am') == '0639'\n    assert candidate(6,40,'am') == '0640'\n    assert candidate(6,41,'am') == '0641'\n    assert candidate(6,42,'am') == '0642'\n    assert candidate(6,43,'am') == '0643'\n    assert candidate(6,44,'am') == '0644'\n    assert candidate(6,45,'am') == '0645'\n    assert candidate(6,46,'am') == '0646'\n    assert candidate(6,47,'am') == '0647'\n    assert candidate(6,48,'am') == '0648'\n    assert candidate(6,49,'am') == '0649'\n    assert candidate(6,50,'am') == '0650'\n    assert candidate(6,51,'am') == '0651'\n    assert candidate(6,52,'am') == '0652'\n    assert candidate(6,53,'am') == '0653'\n    assert candidate(6,54,'am') == '0654'\n    assert candidate(6,55,'am') == '0655'\n    assert candidate(6,56,'am') == '0656'\n    assert candidate(6,57,'am') == '0657'\n    assert candidate(6,58,'am') == '0658'\n    assert candidate(6,59,'am') == '0659'\n    assert candidate(7,0,'am') == '0700'\n    assert candidate(7,1,'am') == '0701'\n    assert candidate(7,2,'am') == '0702'\n    assert candidate(7,3,'am') == '0703'\n    assert candidate(7,4,'am') == '0704'\n    assert candidate(7,5,'am') == '0705'\n    assert candidate(7,6,'am') == '0706'\n    assert candidate(7,7,'am') == '0707'\n    assert candidate(7,8,'am') == '0708'\n    assert candidate(7,9,'am') == '0709'\n    assert candidate(7,10,'am') == '0710'\n    assert candidate(7,11,'am') == '0711'\n    assert candidate(7,12,'am') == '0712'\n    assert candidate(7,13,'am') == '0713'\n    assert candidate(7,14,'am') == '0714'\n    assert candidate(7,15,'am') == '0715'\n    assert candidate(7,16,'am') == '0716'\n    assert candidate(7,17,'am') == '0717'\n    assert candidate(7,18,'am') == '0718'\n    assert candidate(7,19,'am') == '0719'\n    assert candidate(7,20,'am') == '0720'\n    assert candidate(7,21,'am') == '0721'\n    assert candidate(7,22,'am') == '0722'\n    assert candidate(7,23,'am') == '0723'\n    assert candidate(7,24,'am') == '0724'\n    assert candidate(7,25,'am') == '0725'\n    assert candidate(7,26,'am') == '0726'\n    assert candidate(7,27,'am') == '0727'\n    assert candidate(7,28,'am') == '0728'\n    assert candidate(7,29,'am') == '0729'\n    assert candidate(7,30,'am') == '0730'\n    assert candidate(7,31,'am') == '0731'\n    assert candidate(7,32,'am') == '0732'\n    assert candidate(7,33,'am') == '0733'\n    assert candidate(7,34,'am') == '0734'\n    assert candidate(7,35,'am') == '0735'\n    assert candidate(7,36,'am') == '0736'\n    assert candidate(7,37,'am') == '0737'\n    assert candidate(7,38,'am') == '0738'\n    assert candidate(7,39,'am') == '0739'\n    assert candidate(7,40,'am') == '0740'\n    assert candidate(7,41,'am') == '0741'\n    assert candidate(7,42,'am') == '0742'\n    assert candidate(7,43,'am') == '0743'\n    assert candidate(7,44,'am') == '0744'\n    assert candidate(7,45,'am') == '0745'\n    assert candidate(7,46,'am') == '0746'\n    assert candidate(7,47,'am') == '0747'\n    assert candidate(7,48,'am') == '0748'\n    assert candidate(7,49,'am') == '0749'\n    assert candidate(7,50,'am') == '0750'\n    assert candidate(7,51,'am') == '0751'\n    assert candidate(7,52,'am') == '0752'\n    assert candidate(7,53,'am') == '0753'\n    assert candidate(7,54,'am') == '0754'\n    assert candidate(7,55,'am') == '0755'\n    assert candidate(7,56,'am') == '0756'\n    assert candidate(7,57,'am') == '0757'\n    assert candidate(7,58,'am') == '0758'\n    assert candidate(7,59,'am') == '0759'\n    assert candidate(8,0,'am') == '0800'\n    assert candidate(8,1,'am') == '0801'\n    assert candidate(8,2,'am') == '0802'\n    assert candidate(8,3,'am') == '0803'\n    assert candidate(8,4,'am') == '0804'\n    assert candidate(8,5,'am') == '0805'\n    assert candidate(8,6,'am') == '0806'\n    assert candidate(8,7,'am') == '0807'\n    assert candidate(8,8,'am') == '0808'\n    assert candidate(8,9,'am') == '0809'\n    assert candidate(8,10,'am') == '0810'\n    assert candidate(8,11,'am') == '0811'\n    assert candidate(8,12,'am') == '0812'\n    assert candidate(8,13,'am') == '0813'\n    assert candidate(8,14,'am') == '0814'\n    assert candidate(8,15,'am') == '0815'\n    assert candidate(8,16,'am') == '0816'\n    assert candidate(8,17,'am') == '0817'\n    assert candidate(8,18,'am') == '0818'\n    assert candidate(8,19,'am') == '0819'\n    assert candidate(8,20,'am') == '0820'\n    assert candidate(8,21,'am') == '0821'\n    assert candidate(8,22,'am') == '0822'\n    assert candidate(8,23,'am') == '0823'\n    assert candidate(8,24,'am') == '0824'\n    assert candidate(8,25,'am') == '0825'\n    assert candidate(8,26,'am') == '0826'\n    assert candidate(8,27,'am') == '0827'\n    assert candidate(8,28,'am') == '0828'\n    assert candidate(8,29,'am') == '0829'\n    assert candidate(8,30,'am') == '0830'\n    assert candidate(8,31,'am') == '0831'\n    assert candidate(8,32,'am') == '0832'\n    assert candidate(8,33,'am') == '0833'\n    assert candidate(8,34,'am') == '0834'\n    assert candidate(8,35,'am') == '0835'\n    assert candidate(8,36,'am') == '0836'\n    assert candidate(8,37,'am') == '0837'\n    assert candidate(8,38,'am') == '0838'\n    assert candidate(8,39,'am') == '0839'\n    assert candidate(8,40,'am') == '0840'\n    assert candidate(8,41,'am') == '0841'\n    assert candidate(8,42,'am') == '0842'\n    assert candidate(8,43,'am') == '0843'\n    assert candidate(8,44,'am') == '0844'\n    assert candidate(8,45,'am') == '0845'\n    assert candidate(8,46,'am') == '0846'\n    assert candidate(8,47,'am') == '0847'\n    assert candidate(8,48,'am') == '0848'\n    assert candidate(8,49,'am') == '0849'\n    assert candidate(8,50,'am') == '0850'\n    assert candidate(8,51,'am') == '0851'\n    assert candidate(8,52,'am') == '0852'\n    assert candidate(8,53,'am') == '0853'\n    assert candidate(8,54,'am') == '0854'\n    assert candidate(8,55,'am') == '0855'\n    assert candidate(8,56,'am') == '0856'\n    assert candidate(8,57,'am') == '0857'\n    assert candidate(8,58,'am') == '0858'\n    assert candidate(8,59,'am') == '0859'\n    assert candidate(9,0,'am') == '0900'\n    assert candidate(9,1,'am') == '0901'\n    assert candidate(9,2,'am') == '0902'\n    assert candidate(9,3,'am') == '0903'\n    assert candidate(9,4,'am') == '0904'\n    assert candidate(9,5,'am') == '0905'\n    assert candidate(9,6,'am') == '0906'\n    assert candidate(9,7,'am') == '0907'\n    assert candidate(9,8,'am') == '0908'\n    assert candidate(9,9,'am') == '0909'\n    assert candidate(9,10,'am') == '0910'\n    assert candidate(9,11,'am') == '0911'\n    assert candidate(9,12,'am') == '0912'\n    assert candidate(9,13,'am') == '0913'\n    assert candidate(9,14,'am') == '0914'\n    assert candidate(9,15,'am') == '0915'\n    assert candidate(9,16,'am') == '0916'\n    assert candidate(9,17,'am') == '0917'\n    assert candidate(9,18,'am') == '0918'\n    assert candidate(9,19,'am') == '0919'\n    assert candidate(9,20,'am') == '0920'\n    assert candidate(9,21,'am') == '0921'\n    assert candidate(9,22,'am') == '0922'\n    assert candidate(9,23,'am') == '0923'\n    assert candidate(9,24,'am') == '0924'\n    assert candidate(9,25,'am') == '0925'\n    assert candidate(9,26,'am') == '0926'\n    assert candidate(9,27,'am') == '0927'\n    assert candidate(9,28,'am') == '0928'\n    assert candidate(9,29,'am') == '0929'\n    assert candidate(9,30,'am') == '0930'\n    assert candidate(9,31,'am') == '0931'\n    assert candidate(9,32,'am') == '0932'\n    assert candidate(9,33,'am') == '0933'\n    assert candidate(9,34,'am') == '0934'\n    assert candidate(9,35,'am') == '0935'\n    assert candidate(9,36,'am') == '0936'\n    assert candidate(9,37,'am') == '0937'\n    assert candidate(9,38,'am') == '0938'\n    assert candidate(9,39,'am') == '0939'\n    assert candidate(9,40,'am') == '0940'\n    assert candidate(9,41,'am') == '0941'\n    assert candidate(9,42,'am') == '0942'\n    assert candidate(9,43,'am') == '0943'\n    assert candidate(9,44,'am') == '0944'\n    assert candidate(9,45,'am') == '0945'\n    assert candidate(9,46,'am') == '0946'\n    assert candidate(9,47,'am') == '0947'\n    assert candidate(9,48,'am') == '0948'\n    assert candidate(9,49,'am') == '0949'\n    assert candidate(9,50,'am') == '0950'\n    assert candidate(9,51,'am') == '0951'\n    assert candidate(9,52,'am') == '0952'\n    assert candidate(9,53,'am') == '0953'\n    assert candidate(9,54,'am') == '0954'\n    assert candidate(9,55,'am') == '0955'\n    assert candidate(9,56,'am') == '0956'\n    assert candidate(9,57,'am') == '0957'\n    assert candidate(9,58,'am') == '0958'\n    assert candidate(9,59,'am') == '0959'\n    assert candidate(10,0,'am') == '1000'\n    assert candidate(10,1,'am') == '1001'\n    assert candidate(10,2,'am') == '1002'\n    assert candidate(10,3,'am') == '1003'\n    assert candidate(10,4,'am') == '1004'\n    assert candidate(10,5,'am') == '1005'\n    assert candidate(10,6,'am') == '1006'\n    assert candidate(10,7,'am') == '1007'\n    assert candidate(10,8,'am') == '1008'\n    assert candidate(10,9,'am') == '1009'\n    assert candidate(10,10,'am') == '1010'\n    assert candidate(10,11,'am') == '1011'\n    assert candidate(10,12,'am') == '1012'\n    assert candidate(10,13,'am') == '1013'\n    assert candidate(10,14,'am') == '1014'\n    assert candidate(10,15,'am') == '1015'\n    assert candidate(10,16,'am') == '1016'\n    assert candidate(10,17,'am') == '1017'\n    assert candidate(10,18,'am') == '1018'\n    assert candidate(10,19,'am') == '1019'\n    assert candidate(10,20,'am') == '1020'\n    assert candidate(10,21,'am') == '1021'\n    assert candidate(10,22,'am') == '1022'\n    assert candidate(10,23,'am') == '1023'\n    assert candidate(10,24,'am') == '1024'\n    assert candidate(10,25,'am') == '1025'\n    assert candidate(10,26,'am') == '1026'\n    assert candidate(10,27,'am') == '1027'\n    assert candidate(10,28,'am') == '1028'\n    assert candidate(10,29,'am') == '1029'\n    assert candidate(10,30,'am') == '1030'\n    assert candidate(10,31,'am') == '1031'\n    assert candidate(10,32,'am') == '1032'\n    assert candidate(10,33,'am') == '1033'\n    assert candidate(10,34,'am') == '1034'\n    assert candidate(10,35,'am') == '1035'\n    assert candidate(10,36,'am') == '1036'\n    assert candidate(10,37,'am') == '1037'\n    assert candidate(10,38,'am') == '1038'\n    assert candidate(10,39,'am') == '1039'\n    assert candidate(10,40,'am') == '1040'\n    assert candidate(10,41,'am') == '1041'\n    assert candidate(10,42,'am') == '1042'\n    assert candidate(10,43,'am') == '1043'\n    assert candidate(10,44,'am') == '1044'\n    assert candidate(10,45,'am') == '1045'\n    assert candidate(10,46,'am') == '1046'\n    assert candidate(10,47,'am') == '1047'\n    assert candidate(10,48,'am') == '1048'\n    assert candidate(10,49,'am') == '1049'\n    assert candidate(10,50,'am') == '1050'\n    assert candidate(10,51,'am') == '1051'\n    assert candidate(10,52,'am') == '1052'\n    assert candidate(10,53,'am') == '1053'\n    assert candidate(10,54,'am') == '1054'\n    assert candidate(10,55,'am') == '1055'\n    assert candidate(10,56,'am') == '1056'\n    assert candidate(10,57,'am') == '1057'\n    assert candidate(10,58,'am') == '1058'\n    assert candidate(10,59,'am') == '1059'\n    assert candidate(11,0,'am') == '1100'\n    assert candidate(11,1,'am') == '1101'\n    assert candidate(11,2,'am') == '1102'\n    assert candidate(11,3,'am') == '1103'\n    assert candidate(11,4,'am') == '1104'\n    assert candidate(11,5,'am') == '1105'\n    assert candidate(11,6,'am') == '1106'\n    assert candidate(11,7,'am') == '1107'\n    assert candidate(11,8,'am') == '1108'\n    assert candidate(11,9,'am') == '1109'\n    assert candidate(11,10,'am') == '1110'\n    assert candidate(11,11,'am') == '1111'\n    assert candidate(11,12,'am') == '1112'\n    assert candidate(11,13,'am') == '1113'\n    assert candidate(11,14,'am') == '1114'\n    assert candidate(11,15,'am') == '1115'\n    assert candidate(11,16,'am') == '1116'\n    assert candidate(11,17,'am') == '1117'\n    assert candidate(11,18,'am') == '1118'\n    assert candidate(11,19,'am') == '1119'\n    assert candidate(11,20,'am') == '1120'\n    assert candidate(11,21,'am') == '1121'\n    assert candidate(11,22,'am') == '1122'\n    assert candidate(11,23,'am') == '1123'\n    assert candidate(11,24,'am') == '1124'\n    assert candidate(11,25,'am') == '1125'\n    assert candidate(11,26,'am') == '1126'\n    assert candidate(11,27,'am') == '1127'\n    assert candidate(11,28,'am') == '1128'\n    assert candidate(11,29,'am') == '1129'\n    assert candidate(11,30,'am') == '1130'\n    assert candidate(11,31,'am') == '1131'\n    assert candidate(11,32,'am') == '1132'\n    assert candidate(11,33,'am') == '1133'\n    assert candidate(11,34,'am') == '1134'\n    assert candidate(11,35,'am') == '1135'\n    assert candidate(11,36,'am') == '1136'\n    assert candidate(11,37,'am') == '1137'\n    assert candidate(11,38,'am') == '1138'\n    assert candidate(11,39,'am') == '1139'\n    assert candidate(11,40,'am') == '1140'\n    assert candidate(11,41,'am') == '1141'\n    assert candidate(11,42,'am') == '1142'\n    assert candidate(11,43,'am') == '1143'\n    assert candidate(11,44,'am') == '1144'\n    assert candidate(11,45,'am') == '1145'\n    assert candidate(11,46,'am') == '1146'\n    assert candidate(11,47,'am') == '1147'\n    assert candidate(11,48,'am') == '1148'\n    assert candidate(11,49,'am') == '1149'\n    assert candidate(11,50,'am') == '1150'\n    assert candidate(11,51,'am') == '1151'\n    assert candidate(11,52,'am') == '1152'\n    assert candidate(11,53,'am') == '1153'\n    assert candidate(11,54,'am') == '1154'\n    assert candidate(11,55,'am') == '1155'\n    assert candidate(11,56,'am') == '1156'\n    assert candidate(11,57,'am') == '1157'\n    assert candidate(11,58,'am') == '1158'\n    assert candidate(11,59,'am') == '1159'\n    assert candidate(12,0,'pm') == '1200'\n    assert candidate(12,1,'pm') == '1201'\n    assert candidate(12,2,'pm') == '1202'\n    assert candidate(12,3,'pm') == '1203'\n    assert candidate(12,4,'pm') == '1204'\n    assert candidate(12,5,'pm') == '1205'\n    assert candidate(12,6,'pm') == '1206'\n    assert candidate(12,7,'pm') == '1207'\n    assert candidate(12,8,'pm') == '1208'\n    assert candidate(12,9,'pm') == '1209'\n    assert candidate(12,10,'pm') == '1210'\n    assert candidate(12,11,'pm') == '1211'\n    assert candidate(12,12,'pm') == '1212'\n    assert candidate(12,13,'pm') == '1213'\n    assert candidate(12,14,'pm') == '1214'\n    assert candidate(12,15,'pm') == '1215'\n    assert candidate(12,16,'pm') == '1216'\n    assert candidate(12,17,'pm') == '1217'\n    assert candidate(12,18,'pm') == '1218'\n    assert candidate(12,19,'pm') == '1219'\n    assert candidate(12,20,'pm') == '1220'\n    assert candidate(12,21,'pm') == '1221'\n    assert candidate(12,22,'pm') == '1222'\n    assert candidate(12,23,'pm') == '1223'\n    assert candidate(12,24,'pm') == '1224'\n    assert candidate(12,25,'pm') == '1225'\n    assert candidate(12,26,'pm') == '1226'\n    assert candidate(12,27,'pm') == '1227'\n    assert candidate(12,28,'pm') == '1228'\n    assert candidate(12,29,'pm') == '1229'\n    assert candidate(12,30,'pm') == '1230'\n    assert candidate(12,31,'pm') == '1231'\n    assert candidate(12,32,'pm') == '1232'\n    assert candidate(12,33,'pm') == '1233'\n    assert candidate(12,34,'pm') == '1234'\n    assert candidate(12,35,'pm') == '1235'\n    assert candidate(12,36,'pm') == '1236'\n    assert candidate(12,37,'pm') == '1237'\n    assert candidate(12,38,'pm') == '1238'\n    assert candidate(12,39,'pm') == '1239'\n    assert candidate(12,40,'pm') == '1240'\n    assert candidate(12,41,'pm') == '1241'\n    assert candidate(12,42,'pm') == '1242'\n    assert candidate(12,43,'pm') == '1243'\n    assert candidate(12,44,'pm') == '1244'\n    assert candidate(12,45,'pm') == '1245'\n    assert candidate(12,46,'pm') == '1246'\n    assert candidate(12,47,'pm') == '1247'\n    assert candidate(12,48,'pm') == '1248'\n    assert candidate(12,49,'pm') == '1249'\n    assert candidate(12,50,'pm') == '1250'\n    assert candidate(12,51,'pm') == '1251'\n    assert candidate(12,52,'pm') == '1252'\n    assert candidate(12,53,'pm') == '1253'\n    assert candidate(12,54,'pm') == '1254'\n    assert candidate(12,55,'pm') == '1255'\n    assert candidate(12,56,'pm') == '1256'\n    assert candidate(12,57,'pm') == '1257'\n    assert candidate(12,58,'pm') == '1258'\n    assert candidate(12,59,'pm') == '1259'\n    assert candidate(1,0,'pm') == '1300'\n    assert candidate(1,1,'pm') == '1301'\n    assert candidate(1,2,'pm') == '1302'\n    assert candidate(1,3,'pm') == '1303'\n    assert candidate(1,4,'pm') == '1304'\n    assert candidate(1,5,'pm') == '1305'\n    assert candidate(1,6,'pm') == '1306'\n    assert candidate(1,7,'pm') == '1307'\n    assert candidate(1,8,'pm') == '1308'\n    assert candidate(1,9,'pm') == '1309'\n    assert candidate(1,10,'pm') == '1310'\n    assert candidate(1,11,'pm') == '1311'\n    assert candidate(1,12,'pm') == '1312'\n    assert candidate(1,13,'pm') == '1313'\n    assert candidate(1,14,'pm') == '1314'\n    assert candidate(1,15,'pm') == '1315'\n    assert candidate(1,16,'pm') == '1316'\n    assert candidate(1,17,'pm') == '1317'\n    assert candidate(1,18,'pm') == '1318'\n    assert candidate(1,19,'pm') == '1319'\n    assert candidate(1,20,'pm') == '1320'\n    assert candidate(1,21,'pm') == '1321'\n    assert candidate(1,22,'pm') == '1322'\n    assert candidate(1,23,'pm') == '1323'\n    assert candidate(1,24,'pm') == '1324'\n    assert candidate(1,25,'pm') == '1325'\n    assert candidate(1,26,'pm') == '1326'\n    assert candidate(1,27,'pm') == '1327'\n    assert candidate(1,28,'pm') == '1328'\n    assert candidate(1,29,'pm') == '1329'\n    assert candidate(1,30,'pm') == '1330'\n    assert candidate(1,31,'pm') == '1331'\n    assert candidate(1,32,'pm') == '1332'\n    assert candidate(1,33,'pm') == '1333'\n    assert candidate(1,34,'pm') == '1334'\n    assert candidate(1,35,'pm') == '1335'\n    assert candidate(1,36,'pm') == '1336'\n    assert candidate(1,37,'pm') == '1337'\n    assert candidate(1,38,'pm') == '1338'\n    assert candidate(1,39,'pm') == '1339'\n    assert candidate(1,40,'pm') == '1340'\n    assert candidate(1,41,'pm') == '1341'\n    assert candidate(1,42,'pm') == '1342'\n    assert candidate(1,43,'pm') == '1343'\n    assert candidate(1,44,'pm') == '1344'\n    assert candidate(1,45,'pm') == '1345'\n    assert candidate(1,46,'pm') == '1346'\n    assert candidate(1,47,'pm') == '1347'\n    assert candidate(1,48,'pm') == '1348'\n    assert candidate(1,49,'pm') == '1349'\n    assert candidate(1,50,'pm') == '1350'\n    assert candidate(1,51,'pm') == '1351'\n    assert candidate(1,52,'pm') == '1352'\n    assert candidate(1,53,'pm') == '1353'\n    assert candidate(1,54,'pm') == '1354'\n    assert candidate(1,55,'pm') == '1355'\n    assert candidate(1,56,'pm') == '1356'\n    assert candidate(1,57,'pm') == '1357'\n    assert candidate(1,58,'pm') == '1358'\n    assert candidate(1,59,'pm') == '1359'\n    assert candidate(2,0,'pm') == '1400'\n    assert candidate(2,1,'pm') == '1401'\n    assert candidate(2,2,'pm') == '1402'\n    assert candidate(2,3,'pm') == '1403'\n    assert candidate(2,4,'pm') == '1404'\n    assert candidate(2,5,'pm') == '1405'\n    assert candidate(2,6,'pm') == '1406'\n    assert candidate(2,7,'pm') == '1407'\n    assert candidate(2,8,'pm') == '1408'\n    assert candidate(2,9,'pm') == '1409'\n    assert candidate(2,10,'pm') == '1410'\n    assert candidate(2,11,'pm') == '1411'\n    assert candidate(2,12,'pm') == '1412'\n    assert candidate(2,13,'pm') == '1413'\n    assert candidate(2,14,'pm') == '1414'\n    assert candidate(2,15,'pm') == '1415'\n    assert candidate(2,16,'pm') == '1416'\n    assert candidate(2,17,'pm') == '1417'\n    assert candidate(2,18,'pm') == '1418'\n    assert candidate(2,19,'pm') == '1419'\n    assert candidate(2,20,'pm') == '1420'\n    assert candidate(2,21,'pm') == '1421'\n    assert candidate(2,22,'pm') == '1422'\n    assert candidate(2,23,'pm') == '1423'\n    assert candidate(2,24,'pm') == '1424'\n    assert candidate(2,25,'pm') == '1425'\n    assert candidate(2,26,'pm') == '1426'\n    assert candidate(2,27,'pm') == '1427'\n    assert candidate(2,28,'pm') == '1428'\n    assert candidate(2,29,'pm') == '1429'\n    assert candidate(2,30,'pm') == '1430'\n    assert candidate(2,31,'pm') == '1431'\n    assert candidate(2,32,'pm') == '1432'\n    assert candidate(2,33,'pm') == '1433'\n    assert candidate(2,34,'pm') == '1434'\n    assert candidate(2,35,'pm') == '1435'\n    assert candidate(2,36,'pm') == '1436'\n    assert candidate(2,37,'pm') == '1437'\n    assert candidate(2,38,'pm') == '1438'\n    assert candidate(2,39,'pm') == '1439'\n    assert candidate(2,40,'pm') == '1440'\n    assert candidate(2,41,'pm') == '1441'\n    assert candidate(2,42,'pm') == '1442'\n    assert candidate(2,43,'pm') == '1443'\n    assert candidate(2,44,'pm') == '1444'\n    assert candidate(2,45,'pm') == '1445'\n    assert candidate(2,46,'pm') == '1446'\n    assert candidate(2,47,'pm') == '1447'\n    assert candidate(2,48,'pm') == '1448'\n    assert candidate(2,49,'pm') == '1449'\n    assert candidate(2,50,'pm') == '1450'\n    assert candidate(2,51,'pm') == '1451'\n    assert candidate(2,52,'pm') == '1452'\n    assert candidate(2,53,'pm') == '1453'\n    assert candidate(2,54,'pm') == '1454'\n    assert candidate(2,55,'pm') == '1455'\n    assert candidate(2,56,'pm') == '1456'\n    assert candidate(2,57,'pm') == '1457'\n    assert candidate(2,58,'pm') == '1458'\n    assert candidate(2,59,'pm') == '1459'\n    assert candidate(3,0,'pm') == '1500'\n    assert candidate(3,1,'pm') == '1501'\n    assert candidate(3,2,'pm') == '1502'\n    assert candidate(3,3,'pm') == '1503'\n    assert candidate(3,4,'pm') == '1504'\n    assert candidate(3,5,'pm') == '1505'\n    assert candidate(3,6,'pm') == '1506'\n    assert candidate(3,7,'pm') == '1507'\n    assert candidate(3,8,'pm') == '1508'\n    assert candidate(3,9,'pm') == '1509'\n    assert candidate(3,10,'pm') == '1510'\n    assert candidate(3,11,'pm') == '1511'\n    assert candidate(3,12,'pm') == '1512'\n    assert candidate(3,13,'pm') == '1513'\n    assert candidate(3,14,'pm') == '1514'\n    assert candidate(3,15,'pm') == '1515'\n    assert candidate(3,16,'pm') == '1516'\n    assert candidate(3,17,'pm') == '1517'\n    assert candidate(3,18,'pm') == '1518'\n    assert candidate(3,19,'pm') == '1519'\n    assert candidate(3,20,'pm') == '1520'\n    assert candidate(3,21,'pm') == '1521'\n    assert candidate(3,22,'pm') == '1522'\n    assert candidate(3,23,'pm') == '1523'\n    assert candidate(3,24,'pm') == '1524'\n    assert candidate(3,25,'pm') == '1525'\n    assert candidate(3,26,'pm') == '1526'\n    assert candidate(3,27,'pm') == '1527'\n    assert candidate(3,28,'pm') == '1528'\n    assert candidate(3,29,'pm') == '1529'\n    assert candidate(3,30,'pm') == '1530'\n    assert candidate(3,31,'pm') == '1531'\n    assert candidate(3,32,'pm') == '1532'\n    assert candidate(3,33,'pm') == '1533'\n    assert candidate(3,34,'pm') == '1534'\n    assert candidate(3,35,'pm') == '1535'\n    assert candidate(3,36,'pm') == '1536'\n    assert candidate(3,37,'pm') == '1537'\n    assert candidate(3,38,'pm') == '1538'\n    assert candidate(3,39,'pm') == '1539'\n    assert candidate(3,40,'pm') == '1540'\n    assert candidate(3,41,'pm') == '1541'\n    assert candidate(3,42,'pm') == '1542'\n    assert candidate(3,43,'pm') == '1543'\n    assert candidate(3,44,'pm') == '1544'\n    assert candidate(3,45,'pm') == '1545'\n    assert candidate(3,46,'pm') == '1546'\n    assert candidate(3,47,'pm') == '1547'\n    assert candidate(3,48,'pm') == '1548'\n    assert candidate(3,49,'pm') == '1549'\n    assert candidate(3,50,'pm') == '1550'\n    assert candidate(3,51,'pm') == '1551'\n    assert candidate(3,52,'pm') == '1552'\n    assert candidate(3,53,'pm') == '1553'\n    assert candidate(3,54,'pm') == '1554'\n    assert candidate(3,55,'pm') == '1555'\n    assert candidate(3,56,'pm') == '1556'\n    assert candidate(3,57,'pm') == '1557'\n    assert candidate(3,58,'pm') == '1558'\n    assert candidate(3,59,'pm') == '1559'\n    assert candidate(4,0,'pm') == '1600'\n    assert candidate(4,1,'pm') == '1601'\n    assert candidate(4,2,'pm') == '1602'\n    assert candidate(4,3,'pm') == '1603'\n    assert candidate(4,4,'pm') == '1604'\n    assert candidate(4,5,'pm') == '1605'\n    assert candidate(4,6,'pm') == '1606'\n    assert candidate(4,7,'pm') == '1607'\n    assert candidate(4,8,'pm') == '1608'\n    assert candidate(4,9,'pm') == '1609'\n    assert candidate(4,10,'pm') == '1610'\n    assert candidate(4,11,'pm') == '1611'\n    assert candidate(4,12,'pm') == '1612'\n    assert candidate(4,13,'pm') == '1613'\n    assert candidate(4,14,'pm') == '1614'\n    assert candidate(4,15,'pm') == '1615'\n    assert candidate(4,16,'pm') == '1616'\n    assert candidate(4,17,'pm') == '1617'\n    assert candidate(4,18,'pm') == '1618'\n    assert candidate(4,19,'pm') == '1619'\n    assert candidate(4,20,'pm') == '1620'\n    assert candidate(4,21,'pm') == '1621'\n    assert candidate(4,22,'pm') == '1622'\n    assert candidate(4,23,'pm') == '1623'\n    assert candidate(4,24,'pm') == '1624'\n    assert candidate(4,25,'pm') == '1625'\n    assert candidate(4,26,'pm') == '1626'\n    assert candidate(4,27,'pm') == '1627'\n    assert candidate(4,28,'pm') == '1628'\n    assert candidate(4,29,'pm') == '1629'\n    assert candidate(4,30,'pm') == '1630'\n    assert candidate(4,31,'pm') == '1631'\n    assert candidate(4,32,'pm') == '1632'\n    assert candidate(4,33,'pm') == '1633'\n    assert candidate(4,34,'pm') == '1634'\n    assert candidate(4,35,'pm') == '1635'\n    assert candidate(4,36,'pm') == '1636'\n    assert candidate(4,37,'pm') == '1637'\n    assert candidate(4,38,'pm') == '1638'\n    assert candidate(4,39,'pm') == '1639'\n    assert candidate(4,40,'pm') == '1640'\n    assert candidate(4,41,'pm') == '1641'\n    assert candidate(4,42,'pm') == '1642'\n    assert candidate(4,43,'pm') == '1643'\n    assert candidate(4,44,'pm') == '1644'\n    assert candidate(4,45,'pm') == '1645'\n    assert candidate(4,46,'pm') == '1646'\n    assert candidate(4,47,'pm') == '1647'\n    assert candidate(4,48,'pm') == '1648'\n    assert candidate(4,49,'pm') == '1649'\n    assert candidate(4,50,'pm') == '1650'\n    assert candidate(4,51,'pm') == '1651'\n    assert candidate(4,52,'pm') == '1652'\n    assert candidate(4,53,'pm') == '1653'\n    assert candidate(4,54,'pm') == '1654'\n    assert candidate(4,55,'pm') == '1655'\n    assert candidate(4,56,'pm') == '1656'\n    assert candidate(4,57,'pm') == '1657'\n    assert candidate(4,58,'pm') == '1658'\n    assert candidate(4,59,'pm') == '1659'\n    assert candidate(5,0,'pm') == '1700'\n    assert candidate(5,1,'pm') == '1701'\n    assert candidate(5,2,'pm') == '1702'\n    assert candidate(5,3,'pm') == '1703'\n    assert candidate(5,4,'pm') == '1704'\n    assert candidate(5,5,'pm') == '1705'\n    assert candidate(5,6,'pm') == '1706'\n    assert candidate(5,7,'pm') == '1707'\n    assert candidate(5,8,'pm') == '1708'\n    assert candidate(5,9,'pm') == '1709'\n    assert candidate(5,10,'pm') == '1710'\n    assert candidate(5,11,'pm') == '1711'\n    assert candidate(5,12,'pm') == '1712'\n    assert candidate(5,13,'pm') == '1713'\n    assert candidate(5,14,'pm') == '1714'\n    assert candidate(5,15,'pm') == '1715'\n    assert candidate(5,16,'pm') == '1716'\n    assert candidate(5,17,'pm') == '1717'\n    assert candidate(5,18,'pm') == '1718'\n    assert candidate(5,19,'pm') == '1719'\n    assert candidate(5,20,'pm') == '1720'\n    assert candidate(5,21,'pm') == '1721'\n    assert candidate(5,22,'pm') == '1722'\n    assert candidate(5,23,'pm') == '1723'\n    assert candidate(5,24,'pm') == '1724'\n    assert candidate(5,25,'pm') == '1725'\n    assert candidate(5,26,'pm') == '1726'\n    assert candidate(5,27,'pm') == '1727'\n    assert candidate(5,28,'pm') == '1728'\n    assert candidate(5,29,'pm') == '1729'\n    assert candidate(5,30,'pm') == '1730'\n    assert candidate(5,31,'pm') == '1731'\n    assert candidate(5,32,'pm') == '1732'\n    assert candidate(5,33,'pm') == '1733'\n    assert candidate(5,34,'pm') == '1734'\n    assert candidate(5,35,'pm') == '1735'\n    assert candidate(5,36,'pm') == '1736'\n    assert candidate(5,37,'pm') == '1737'\n    assert candidate(5,38,'pm') == '1738'\n    assert candidate(5,39,'pm') == '1739'\n    assert candidate(5,40,'pm') == '1740'\n    assert candidate(5,41,'pm') == '1741'\n    assert candidate(5,42,'pm') == '1742'\n    assert candidate(5,43,'pm') == '1743'\n    assert candidate(5,44,'pm') == '1744'\n    assert candidate(5,45,'pm') == '1745'\n    assert candidate(5,46,'pm') == '1746'\n    assert candidate(5,47,'pm') == '1747'\n    assert candidate(5,48,'pm') == '1748'\n    assert candidate(5,49,'pm') == '1749'\n    assert candidate(5,50,'pm') == '1750'\n    assert candidate(5,51,'pm') == '1751'\n    assert candidate(5,52,'pm') == '1752'\n    assert candidate(5,53,'pm') == '1753'\n    assert candidate(5,54,'pm') == '1754'\n    assert candidate(5,55,'pm') == '1755'\n    assert candidate(5,56,'pm') == '1756'\n    assert candidate(5,57,'pm') == '1757'\n    assert candidate(5,58,'pm') == '1758'\n    assert candidate(5,59,'pm') == '1759'\n    assert candidate(6,0,'pm') == '1800'\n    assert candidate(6,1,'pm') == '1801'\n    assert candidate(6,2,'pm') == '1802'\n    assert candidate(6,3,'pm') == '1803'\n    assert candidate(6,4,'pm') == '1804'\n    assert candidate(6,5,'pm') == '1805'\n    assert candidate(6,6,'pm') == '1806'\n    assert candidate(6,7,'pm') == '1807'\n    assert candidate(6,8,'pm') == '1808'\n    assert candidate(6,9,'pm') == '1809'\n    assert candidate(6,10,'pm') == '1810'\n    assert candidate(6,11,'pm') == '1811'\n    assert candidate(6,12,'pm') == '1812'\n    assert candidate(6,13,'pm') == '1813'\n    assert candidate(6,14,'pm') == '1814'\n    assert candidate(6,15,'pm') == '1815'\n    assert candidate(6,16,'pm') == '1816'\n    assert candidate(6,17,'pm') == '1817'\n    assert candidate(6,18,'pm') == '1818'\n    assert candidate(6,19,'pm') == '1819'\n    assert candidate(6,20,'pm') == '1820'\n    assert candidate(6,21,'pm') == '1821'\n    assert candidate(6,22,'pm') == '1822'\n    assert candidate(6,23,'pm') == '1823'\n    assert candidate(6,24,'pm') == '1824'\n    assert candidate(6,25,'pm') == '1825'\n    assert candidate(6,26,'pm') == '1826'\n    assert candidate(6,27,'pm') == '1827'\n    assert candidate(6,28,'pm') == '1828'\n    assert candidate(6,29,'pm') == '1829'\n    assert candidate(6,30,'pm') == '1830'\n    assert candidate(6,31,'pm') == '1831'\n    assert candidate(6,32,'pm') == '1832'\n    assert candidate(6,33,'pm') == '1833'\n    assert candidate(6,34,'pm') == '1834'\n    assert candidate(6,35,'pm') == '1835'\n    assert candidate(6,36,'pm') == '1836'\n    assert candidate(6,37,'pm') == '1837'\n    assert candidate(6,38,'pm') == '1838'\n    assert candidate(6,39,'pm') == '1839'\n    assert candidate(6,40,'pm') == '1840'\n    assert candidate(6,41,'pm') == '1841'\n    assert candidate(6,42,'pm') == '1842'\n    assert candidate(6,43,'pm') == '1843'\n    assert candidate(6,44,'pm') == '1844'\n    assert candidate(6,45,'pm') == '1845'\n    assert candidate(6,46,'pm') == '1846'\n    assert candidate(6,47,'pm') == '1847'\n    assert candidate(6,48,'pm') == '1848'\n    assert candidate(6,49,'pm') == '1849'\n    assert candidate(6,50,'pm') == '1850'\n    assert candidate(6,51,'pm') == '1851'\n    assert candidate(6,52,'pm') == '1852'\n    assert candidate(6,53,'pm') == '1853'\n    assert candidate(6,54,'pm') == '1854'\n    assert candidate(6,55,'pm') == '1855'\n    assert candidate(6,56,'pm') == '1856'\n    assert candidate(6,57,'pm') == '1857'\n    assert candidate(6,58,'pm') == '1858'\n    assert candidate(6,59,'pm') == '1859'\n    assert candidate(7,0,'pm') == '1900'\n    assert candidate(7,1,'pm') == '1901'\n    assert candidate(7,2,'pm') == '1902'\n    assert candidate(7,3,'pm') == '1903'\n    assert candidate(7,4,'pm') == '1904'\n    assert candidate(7,5,'pm') == '1905'\n    assert candidate(7,6,'pm') == '1906'\n    assert candidate(7,7,'pm') == '1907'\n    assert candidate(7,8,'pm') == '1908'\n    assert candidate(7,9,'pm') == '1909'\n    assert candidate(7,10,'pm') == '1910'\n    assert candidate(7,11,'pm') == '1911'\n    assert candidate(7,12,'pm') == '1912'\n    assert candidate(7,13,'pm') == '1913'\n    assert candidate(7,14,'pm') == '1914'\n    assert candidate(7,15,'pm') == '1915'\n    assert candidate(7,16,'pm') == '1916'\n    assert candidate(7,17,'pm') == '1917'\n    assert candidate(7,18,'pm') == '1918'\n    assert candidate(7,19,'pm') == '1919'\n    assert candidate(7,20,'pm') == '1920'\n    assert candidate(7,21,'pm') == '1921'\n    assert candidate(7,22,'pm') == '1922'\n    assert candidate(7,23,'pm') == '1923'\n    assert candidate(7,24,'pm') == '1924'\n    assert candidate(7,25,'pm') == '1925'\n    assert candidate(7,26,'pm') == '1926'\n    assert candidate(7,27,'pm') == '1927'\n    assert candidate(7,28,'pm') == '1928'\n    assert candidate(7,29,'pm') == '1929'\n    assert candidate(7,30,'pm') == '1930'\n    assert candidate(7,31,'pm') == '1931'\n    assert candidate(7,32,'pm') == '1932'\n    assert candidate(7,33,'pm') == '1933'\n    assert candidate(7,34,'pm') == '1934'\n    assert candidate(7,35,'pm') == '1935'\n    assert candidate(7,36,'pm') == '1936'\n    assert candidate(7,37,'pm') == '1937'\n    assert candidate(7,38,'pm') == '1938'\n    assert candidate(7,39,'pm') == '1939'\n    assert candidate(7,40,'pm') == '1940'\n    assert candidate(7,41,'pm') == '1941'\n    assert candidate(7,42,'pm') == '1942'\n    assert candidate(7,43,'pm') == '1943'\n    assert candidate(7,44,'pm') == '1944'\n    assert candidate(7,45,'pm') == '1945'\n    assert candidate(7,46,'pm') == '1946'\n    assert candidate(7,47,'pm') == '1947'\n    assert candidate(7,48,'pm') == '1948'\n    assert candidate(7,49,'pm') == '1949'\n    assert candidate(7,50,'pm') == '1950'\n    assert candidate(7,51,'pm') == '1951'\n    assert candidate(7,52,'pm') == '1952'\n    assert candidate(7,53,'pm') == '1953'\n    assert candidate(7,54,'pm') == '1954'\n    assert candidate(7,55,'pm') == '1955'\n    assert candidate(7,56,'pm') == '1956'\n    assert candidate(7,57,'pm') == '1957'\n    assert candidate(7,58,'pm') == '1958'\n    assert candidate(7,59,'pm') == '1959'\n    assert candidate(8,0,'pm') == '2000'\n    assert candidate(8,1,'pm') == '2001'\n    assert candidate(8,2,'pm') == '2002'\n    assert candidate(8,3,'pm') == '2003'\n    assert candidate(8,4,'pm') == '2004'\n    assert candidate(8,5,'pm') == '2005'\n    assert candidate(8,6,'pm') == '2006'\n    assert candidate(8,7,'pm') == '2007'\n    assert candidate(8,8,'pm') == '2008'\n    assert candidate(8,9,'pm') == '2009'\n    assert candidate(8,10,'pm') == '2010'\n    assert candidate(8,11,'pm') == '2011'\n    assert candidate(8,12,'pm') == '2012'\n    assert candidate(8,13,'pm') == '2013'\n    assert candidate(8,14,'pm') == '2014'\n    assert candidate(8,15,'pm') == '2015'\n    assert candidate(8,16,'pm') == '2016'\n    assert candidate(8,17,'pm') == '2017'\n    assert candidate(8,18,'pm') == '2018'\n    assert candidate(8,19,'pm') == '2019'\n    assert candidate(8,20,'pm') == '2020'\n    assert candidate(8,21,'pm') == '2021'\n    assert candidate(8,22,'pm') == '2022'\n    assert candidate(8,23,'pm') == '2023'\n    assert candidate(8,24,'pm') == '2024'\n    assert candidate(8,25,'pm') == '2025'\n    assert candidate(8,26,'pm') == '2026'\n    assert candidate(8,27,'pm') == '2027'\n    assert candidate(8,28,'pm') == '2028'\n    assert candidate(8,29,'pm') == '2029'\n    assert candidate(8,30,'pm') == '2030'\n    assert candidate(8,31,'pm') == '2031'\n    assert candidate(8,32,'pm') == '2032'\n    assert candidate(8,33,'pm') == '2033'\n    assert candidate(8,34,'pm') == '2034'\n    assert candidate(8,35,'pm') == '2035'\n    assert candidate(8,36,'pm') == '2036'\n    assert candidate(8,37,'pm') == '2037'\n    assert candidate(8,38,'pm') == '2038'\n    assert candidate(8,39,'pm') == '2039'\n    assert candidate(8,40,'pm') == '2040'\n    assert candidate(8,41,'pm') == '2041'\n    assert candidate(8,42,'pm') == '2042'\n    assert candidate(8,43,'pm') == '2043'\n    assert candidate(8,44,'pm') == '2044'\n    assert candidate(8,45,'pm') == '2045'\n    assert candidate(8,46,'pm') == '2046'\n    assert candidate(8,47,'pm') == '2047'\n    assert candidate(8,48,'pm') == '2048'\n    assert candidate(8,49,'pm') == '2049'\n    assert candidate(8,50,'pm') == '2050'\n    assert candidate(8,51,'pm') == '2051'\n    assert candidate(8,52,'pm') == '2052'\n    assert candidate(8,53,'pm') == '2053'\n    assert candidate(8,54,'pm') == '2054'\n    assert candidate(8,55,'pm') == '2055'\n    assert candidate(8,56,'pm') == '2056'\n    assert candidate(8,57,'pm') == '2057'\n    assert candidate(8,58,'pm') == '2058'\n    assert candidate(8,59,'pm') == '2059'\n    assert candidate(9,0,'pm') == '2100'\n    assert candidate(9,1,'pm') == '2101'\n    assert candidate(9,2,'pm') == '2102'\n    assert candidate(9,3,'pm') == '2103'\n    assert candidate(9,4,'pm') == '2104'\n    assert candidate(9,5,'pm') == '2105'\n    assert candidate(9,6,'pm') == '2106'\n    assert candidate(9,7,'pm') == '2107'\n    assert candidate(9,8,'pm') == '2108'\n    assert candidate(9,9,'pm') == '2109'\n    assert candidate(9,10,'pm') == '2110'\n    assert candidate(9,11,'pm') == '2111'\n    assert candidate(9,12,'pm') == '2112'\n    assert candidate(9,13,'pm') == '2113'\n    assert candidate(9,14,'pm') == '2114'\n    assert candidate(9,15,'pm') == '2115'\n    assert candidate(9,16,'pm') == '2116'\n    assert candidate(9,17,'pm') == '2117'\n    assert candidate(9,18,'pm') == '2118'\n    assert candidate(9,19,'pm') == '2119'\n    assert candidate(9,20,'pm') == '2120'\n    assert candidate(9,21,'pm') == '2121'\n    assert candidate(9,22,'pm') == '2122'\n    assert candidate(9,23,'pm') == '2123'\n    assert candidate(9,24,'pm') == '2124'\n    assert candidate(9,25,'pm') == '2125'\n    assert candidate(9,26,'pm') == '2126'\n    assert candidate(9,27,'pm') == '2127'\n    assert candidate(9,28,'pm') == '2128'\n    assert candidate(9,29,'pm') == '2129'\n    assert candidate(9,30,'pm') == '2130'\n    assert candidate(9,31,'pm') == '2131'\n    assert candidate(9,32,'pm') == '2132'\n    assert candidate(9,33,'pm') == '2133'\n    assert candidate(9,34,'pm') == '2134'\n    assert candidate(9,35,'pm') == '2135'\n    assert candidate(9,36,'pm') == '2136'\n    assert candidate(9,37,'pm') == '2137'\n    assert candidate(9,38,'pm') == '2138'\n    assert candidate(9,39,'pm') == '2139'\n    assert candidate(9,40,'pm') == '2140'\n    assert candidate(9,41,'pm') == '2141'\n    assert candidate(9,42,'pm') == '2142'\n    assert candidate(9,43,'pm') == '2143'\n    assert candidate(9,44,'pm') == '2144'\n    assert candidate(9,45,'pm') == '2145'\n    assert candidate(9,46,'pm') == '2146'\n    assert candidate(9,47,'pm') == '2147'\n    assert candidate(9,48,'pm') == '2148'\n    assert candidate(9,49,'pm') == '2149'\n    assert candidate(9,50,'pm') == '2150'\n    assert candidate(9,51,'pm') == '2151'\n    assert candidate(9,52,'pm') == '2152'\n    assert candidate(9,53,'pm') == '2153'\n    assert candidate(9,54,'pm') == '2154'\n    assert candidate(9,55,'pm') == '2155'\n    assert candidate(9,56,'pm') == '2156'\n    assert candidate(9,57,'pm') == '2157'\n    assert candidate(9,58,'pm') == '2158'\n    assert candidate(9,59,'pm') == '2159'\n    assert candidate(10,0,'pm') == '2200'\n    assert candidate(10,1,'pm') == '2201'\n    assert candidate(10,2,'pm') == '2202'\n    assert candidate(10,3,'pm') == '2203'\n    assert candidate(10,4,'pm') == '2204'\n    assert candidate(10,5,'pm') == '2205'\n    assert candidate(10,6,'pm') == '2206'\n    assert candidate(10,7,'pm') == '2207'\n    assert candidate(10,8,'pm') == '2208'\n    assert candidate(10,9,'pm') == '2209'\n    assert candidate(10,10,'pm') == '2210'\n    assert candidate(10,11,'pm') == '2211'\n    assert candidate(10,12,'pm') == '2212'\n    assert candidate(10,13,'pm') == '2213'\n    assert candidate(10,14,'pm') == '2214'\n    assert candidate(10,15,'pm') == '2215'\n    assert candidate(10,16,'pm') == '2216'\n    assert candidate(10,17,'pm') == '2217'\n    assert candidate(10,18,'pm') == '2218'\n    assert candidate(10,19,'pm') == '2219'\n    assert candidate(10,20,'pm') == '2220'\n    assert candidate(10,21,'pm') == '2221'\n    assert candidate(10,22,'pm') == '2222'\n    assert candidate(10,23,'pm') == '2223'\n    assert candidate(10,24,'pm') == '2224'\n    assert candidate(10,25,'pm') == '2225'\n    assert candidate(10,26,'pm') == '2226'\n    assert candidate(10,27,'pm') == '2227'\n    assert candidate(10,28,'pm') == '2228'\n    assert candidate(10,29,'pm') == '2229'\n    assert candidate(10,30,'pm') == '2230'\n    assert candidate(10,31,'pm') == '2231'\n    assert candidate(10,32,'pm') == '2232'\n    assert candidate(10,33,'pm') == '2233'\n    assert candidate(10,34,'pm') == '2234'\n    assert candidate(10,35,'pm') == '2235'\n    assert candidate(10,36,'pm') == '2236'\n    assert candidate(10,37,'pm') == '2237'\n    assert candidate(10,38,'pm') == '2238'\n    assert candidate(10,39,'pm') == '2239'\n    assert candidate(10,40,'pm') == '2240'\n    assert candidate(10,41,'pm') == '2241'\n    assert candidate(10,42,'pm') == '2242'\n    assert candidate(10,43,'pm') == '2243'\n    assert candidate(10,44,'pm') == '2244'\n    assert candidate(10,45,'pm') == '2245'\n    assert candidate(10,46,'pm') == '2246'\n    assert candidate(10,47,'pm') == '2247'\n    assert candidate(10,48,'pm') == '2248'\n    assert candidate(10,49,'pm') == '2249'\n    assert candidate(10,50,'pm') == '2250'\n    assert candidate(10,51,'pm') == '2251'\n    assert candidate(10,52,'pm') == '2252'\n    assert candidate(10,53,'pm') == '2253'\n    assert candidate(10,54,'pm') == '2254'\n    assert candidate(10,55,'pm') == '2255'\n    assert candidate(10,56,'pm') == '2256'\n    assert candidate(10,57,'pm') == '2257'\n    assert candidate(10,58,'pm') == '2258'\n    assert candidate(10,59,'pm') == '2259'\n    assert candidate(11,0,'pm') == '2300'\n    assert candidate(11,1,'pm') == '2301'\n    assert candidate(11,2,'pm') == '2302'\n    assert candidate(11,3,'pm') == '2303'\n    assert candidate(11,4,'pm') == '2304'\n    assert candidate(11,5,'pm') == '2305'\n    assert candidate(11,6,'pm') == '2306'\n    assert candidate(11,7,'pm') == '2307'\n    assert candidate(11,8,'pm') == '2308'\n    assert candidate(11,9,'pm') == '2309'\n    assert candidate(11,10,'pm') == '2310'\n    assert candidate(11,11,'pm') == '2311'\n    assert candidate(11,12,'pm') == '2312'\n    assert candidate(11,13,'pm') == '2313'\n    assert candidate(11,14,'pm') == '2314'\n    assert candidate(11,15,'pm') == '2315'\n    assert candidate(11,16,'pm') == '2316'\n    assert candidate(11,17,'pm') == '2317'\n    assert candidate(11,18,'pm') == '2318'\n    assert candidate(11,19,'pm') == '2319'\n    assert candidate(11,20,'pm') == '2320'\n    assert candidate(11,21,'pm') == '2321'\n    assert candidate(11,22,'pm') == '2322'\n    assert candidate(11,23,'pm') == '2323'\n    assert candidate(11,24,'pm') == '2324'\n    assert candidate(11,25,'pm') == '2325'\n    assert candidate(11,26,'pm') == '2326'\n    assert candidate(11,27,'pm') == '2327'\n    assert candidate(11,28,'pm') == '2328'\n    assert candidate(11,29,'pm') == '2329'\n    assert candidate(11,30,'pm') == '2330'\n    assert candidate(11,31,'pm') == '2331'\n    assert candidate(11,32,'pm') == '2332'\n    assert candidate(11,33,'pm') == '2333'\n    assert candidate(11,34,'pm') == '2334'\n    assert candidate(11,35,'pm') == '2335'\n    assert candidate(11,36,'pm') == '2336'\n    assert candidate(11,37,'pm') == '2337'\n    assert candidate(11,38,'pm') == '2338'\n    assert candidate(11,39,'pm') == '2339'\n    assert candidate(11,40,'pm') == '2340'\n    assert candidate(11,41,'pm') == '2341'\n    assert candidate(11,42,'pm') == '2342'\n    assert candidate(11,43,'pm') == '2343'\n    assert candidate(11,44,'pm') == '2344'\n    assert candidate(11,45,'pm') == '2345'\n    assert candidate(11,46,'pm') == '2346'\n    assert candidate(11,47,'pm') == '2347'\n    assert candidate(11,48,'pm') == '2348'\n    assert candidate(11,49,'pm') == '2349'\n    assert candidate(11,50,'pm') == '2350'\n    assert candidate(11,51,'pm') == '2351'\n    assert candidate(11,52,'pm') == '2352'\n    assert candidate(11,53,'pm') == '2353'\n    assert candidate(11,54,'pm') == '2354'\n    assert candidate(11,55,'pm') == '2355'\n    assert candidate(11,56,'pm') == '2356'\n    assert candidate(11,57,'pm') == '2357'\n    assert candidate(11,58,'pm') == '2358'\n    assert candidate(11,59,'pm') == '2359'\n\n","canonical_solution":"def to24hourtime(hour, minute, period):\n    return '%02d%02d' % (hour % 12 + 12 * (period == 'pm'), minute)"}
{"task_id":3500,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite function RemoveExclamationMarks which removes all exclamation marks from a given string.\n\"\"\"\n\n# ====== Solution ======\n\ndef remove_exclamation_marks(s):\n","entry_point":"remove_exclamation_marks","test":"def check(candidate):\n    assert candidate('Hello World!') == 'Hello World'\n    assert candidate('Hello World!!!') == 'Hello World'\n    assert candidate('Hi! Hello!') == 'Hi Hello'\n    assert candidate('') == ''\n    assert candidate('Oh, no!!!') == 'Oh, no'\n\n","canonical_solution":"def remove_exclamation_marks(s):\n    return s.replace('!', '')"}
{"task_id":3503,"prompt":"\"\"\"\n=====Problem statement====\n\nThe number ```89``` is the first integer with more than one digit that fulfills the property partially introduced in the title of this kata. \nWhat's the use of saying \"Eureka\"? Because this sum gives the same number.\n\nIn effect: ```89 = 8^1 + 9^2``` \n\nThe next number in having this property is ```135```.\n\nSee this property again: ```135 = 1^1 + 3^2 + 5^3```\n\nWe need a function to collect these numbers, that may receive two integers ```a```, ```b``` that defines the range ```[a, b]``` (inclusive) and outputs a list of the sorted numbers in the range that fulfills the property described above.\n\nLet's see some cases:\n```python\nsum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nsum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]\n```\nIf there are no numbers of this kind in the range [a, b] the function should output an empty list.\n```python\nsum_dig_pow(90, 100) == []\n```\nEnjoy it!!\n\"\"\"\n\n# ====== Solution ======\n\ndef dig_pow(n):\n    return sum(int(x)**y for y,x in enumerate(str(n), 1))\n\ndef sum_dig_pow(a, b): \n","entry_point":"sum_dig_pow","test":"def check(candidate):\n    assert candidate(1,100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89]\n    assert candidate(10,89) == [89]\n    assert candidate(10,100) == [89]\n    assert candidate(90,100) == []\n    assert candidate(90,150) == [135]\n    assert candidate(50,150) == [89, 135]\n    assert candidate(10,150) == [89, 135]\n    assert candidate(89,135) == [89, 135]\n\n","canonical_solution":"def dig_pow(n):\n    return sum(int(x)**y for y,x in enumerate(str(n), 1))\n\ndef sum_dig_pow(a, b): \n    return [x for x in range(a,b + 1) if x == dig_pow(x)]"}
{"task_id":3504,"prompt":"\"\"\"\n=====Problem statement====\n\nYour task is to create a new implementation of `modpow` so that it computes `(x^y)%n` for large `y`. The problem with the current implementation is that the output of `Math.pow` is so large on our inputs that it won't fit in a 64-bit float.\n\nYou're also going to need to be efficient, because we'll be testing some pretty big numbers.\n\"\"\"\n\n# ====== Solution ======\n\ndef power_mod(b, e, m):\n","entry_point":"power_mod","test":"def check(candidate):\n    assert candidate(11,10,300) == 1\n    assert candidate(11,100000,49) == 32\n    assert candidate(5,100000000,19) == 5\n    assert candidate(2,3,5) == 3\n    assert candidate(4,12,3) == 1\n    assert candidate(200,3000,10) == 0\n    assert candidate(8132,21302,5) == 4\n    assert candidate(9,193125,37) == 26\n    assert candidate(13,81230123,22) == 19\n    assert candidate(29,1013293125,492) == 161\n    assert candidate(31,902938423012,1023) == 961\n\n","canonical_solution":"def power_mod(b, e, m):\n  res, b = 1, b % m\n  while e > 0:\n    if e & 1: res = res * b % m\n    e >>= 1\n    b = b * b % m\n  return res"}
{"task_id":3509,"prompt":"\"\"\"\n=====Problem statement====\n\nScientists working internationally use metric units almost exclusively. Unless that is, they wish to crash multimillion dollars worth of equipment on Mars.\n\nYour task is to write a simple function that takes a number of meters, and outputs it using metric prefixes.\n\nIn practice, meters are only measured in \"mm\" (thousandths of a meter), \"cm\" (hundredths of a meter), \"m\" (meters) and \"km\" (kilometers, or clicks for the US military).\n\nFor this exercise we just want units bigger than a meter, from meters up to yottameters, excluding decameters and hectometers.\n\nAll values passed in will be positive integers.\ne.g.\n\n```python\nmeters(5);\n\/\/ returns \"5m\"\n\nmeters(51500);\n\/\/ returns \"51.5km\"\n\nmeters(5000000);\n\/\/ returns \"5Mm\"\n```\n\nSee http:\/\/en.wikipedia.org\/wiki\/SI_prefix for a full list of prefixes\n\"\"\"\n\n# ====== Solution ======\n\ndef meters(x):\n","entry_point":"meters","test":"def check(candidate):\n    assert candidate(1) == '1m'\n    assert candidate(999) == '999m'\n    assert candidate(123456) == '123.456km'\n    assert candidate(12300000) == '12.3Mm'\n    assert candidate(9000000000.0) == '9Gm'\n    assert candidate(9000000000000.0) == '9Tm'\n    assert candidate(9000000000000000.0) == '9Pm'\n    assert candidate(9e+18) == '9Em'\n    assert candidate(9e+21) == '9Zm'\n    assert candidate(9e+24) == '9Ym'\n\n","canonical_solution":"def meters(x):\n    #your code here\n    arr = ['','k','M','G','T','P','E','Z','Y']\n    count=0\n    while x>=1000 :\n        x \/=1000.00 \n        count+=1\n    if int(x)==x:\n        x=int(x) \n    return str(x)+arr[count]+'m'\n"}
{"task_id":3512,"prompt":"\"\"\"\n=====Problem statement====\n\nJust like in the [\"father\" kata](http:\/\/www.codewars.com\/kata\/find-fibonacci-last-digit\/), you will have to return the last digit of the nth element in the Fibonacci sequence (starting with 1,1, to be extra clear, not with 0,1 or other numbers).\n\nYou will just get much bigger numbers, so good luck bruteforcing your way through it ;)\n```python\nlast_fib_digit(1) == 1\nlast_fib_digit(2) == 1\nlast_fib_digit(3) == 2\nlast_fib_digit(1000) == 5\nlast_fib_digit(1000000) == 5\n```\n``` haskell\nlastFibDigit       1 == 1\nlastFibDigit       2 == 1\nlastFibDigit       3 == 2\nlastFibDigit    1000 == 5\nlastFibDigit 1000000 == 5\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef last_fib_digit(n):\n","entry_point":"last_fib_digit","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(21) == 6\n    assert candidate(302) == 1\n    assert candidate(4003) == 7\n    assert candidate(50004) == 8\n    assert candidate(600005) == 5\n    assert candidate(7000006) == 3\n    assert candidate(80000007) == 8\n    assert candidate(900000008) == 1\n    assert candidate(1000000009) == 9\n\n","canonical_solution":"def last_fib_digit(n):\n    return [0,1,1,2,3,5,8,3,1,4,5,9,4,3,7,0,7,7,4,1,5,6,1,7,8,5,3,8,1,9,0,9,9,8,7,5,2,7,9,6,5,1,6,7,3,0,3,3,6,9,5,4,9,3,2,5,7,2,9,1][n%60]"}
{"task_id":3516,"prompt":"\"\"\"\n=====Problem statement====\n\nYour colleagues have been good enough(?) to buy you a birthday gift. Even though it is your birthday and not theirs, they have decided to play pass the parcel with it so that everyone has an even chance of winning. There are multiple presents, and you will receive one, but not all are nice... One even explodes and covers you in soil... strange office. To make up for this one present is a dog! Happy days! (do not buy dogs as presents, and if you do, never wrap them).\n\nDepending on the number of passes in the game (y), and the present you unwrap (x), return as follows:\n\nx == goodpresent --> return x with num of passes added to each charCode (turn to charCode, add y to each, turn back)\nx == crap || x == empty --> return string sorted alphabetically\nx == bang --> return string turned to char codes, each code reduced by number of passes and summed to a single figure\nx == badpresent --> return 'Take this back!'\nx == dog, return 'pass out from excitement y times' (where y is the value given for y).\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"present","test":"def check(candidate):\n    assert candidate('badpresent',3) == 'Take this back!'\n    assert candidate('goodpresent',9) == 'pxxmy{n|nw}'\n    assert candidate('crap',10) == 'acpr'\n    assert candidate('bang',27) == '300'\n    assert candidate('dog',23) == 'pass out from excitement 23 times'\n\n","canonical_solution":"_RESULTS = {\n    'goodpresent': lambda y: ''.join(chr(ord(c) + y) for c in 'goodpresent'),\n    'crap': lambda y: 'acpr',\n    'empty': lambda y: 'empty',\n    'bang': lambda y: str(sum(ord(c) - y for c in 'bang')),\n    'badpresent': lambda y: 'Take this back!',\n    'dog': lambda y: 'pass out from excitement {} times'.format(y)\n}\n\npresent = lambda x, y: _RESULTS[x](y)"}
{"task_id":3519,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven two arrays of integers `m` and `n`, test if they contain *at least* one identical element. Return `true` if they do; `false` if not.\n\nYour code must handle any value within the range of a 32-bit integer, and must be capable of handling either array being empty (which is a `false` result, as there are no duplicated elements).\n\"\"\"\n\n# ====== Solution ======\n\ndef duplicate_elements(m, n):\n","entry_point":"duplicate_elements","test":"def check(candidate):\n    assert candidate([1, 2, 3, 4, 5],[1, 6, 7, 8, 9]) == True\n    assert candidate([9, 8, 7],[8, 1, 3]) == True\n    assert candidate([2398632, 9172846, 4728162],[2398632, 9235623, 8235492]) == True\n    assert candidate([-2, -4, -6, -8],[-2, -3, -5, -7]) == True\n    assert candidate([-9, -8, -7],[-8, -1, -3]) == True\n    assert candidate([-2398632, -9172846, -4728162],[-2398632, -9235623, -8235492]) == True\n    assert candidate([1, 3, 5, 7, 9],[2, 4, 6, 8]) == False\n    assert candidate([9, 8, 7],[6, 5, 4]) == False\n    assert candidate([],[9, 8, 7, 6, 5]) == False\n    assert candidate([9, 8, 7, 6, 5],[]) == False\n    assert candidate([],[]) == False\n\n","canonical_solution":"def duplicate_elements(m, n):\n    return not set(m).isdisjoint(n)"}
{"task_id":3526,"prompt":"\"\"\"\n=====Problem statement====\n\nCheck your arrows\nYou have a quiver of arrows, but some have been damaged. The quiver contains arrows with an optional range information (different types of targets are positioned at different ranges), so each item is an arrow.\n\nYou need to verify that you have some good ones left, in order to prepare for battle:\n```python\nanyArrows([{'range': 5}, {'range': 10, 'damaged': True}, {'damaged': True}])\n```\n\nIf an arrow in the quiver does not have a damaged status, it means it's new.\n\nThe expected result is a boolean, indicating whether you have any good arrows left.\n\nReference: https:\/\/developer.mozilla.org\/en-US\/docs\/Web\/JavaScript\/Reference\/Functions\/Arrow_functions\n\"\"\"\n\n# ====== Solution ======\n\ndef any_arrows(arrows):\n","entry_point":"any_arrows","test":"def check(candidate):\n    assert candidate([]) == False\n    assert candidate([{'range': 5, 'damaged': False}]) == True\n    assert candidate([{'range': 5, 'damaged': False}, {'range': 15, 'damaged': True}]) == True\n    assert candidate([{'range': 5}, {'range': 10, 'damaged': True}, {'damaged': True}]) == True\n    assert candidate([{'range': 10, 'damaged': True}, {'damaged': True}]) == False\n\n","canonical_solution":"def any_arrows(arrows):\n    return any(not i.get(\"damaged\", False) for i in arrows)\n"}
{"task_id":3531,"prompt":"\"\"\"\n=====Problem statement====\n\nA [Mersenne prime](https:\/\/en.wikipedia.org\/wiki\/Mersenne_prime) is a prime number that can be represented as:\nMn = 2^(n) - 1. Therefore, every Mersenne prime is one less than a power of two. \n\nWrite a function that will return whether the given integer `n` will produce a Mersenne prime or not.\n\nThe tests will check random integers up to 2000.\n\"\"\"\n\n# ====== Solution ======\n\ndef valid_mersenne(n):\n","entry_point":"valid_mersenne","test":"def check(candidate):\n    assert candidate(2) == True\n    assert candidate(3) == True\n    assert candidate(5) == True\n    assert candidate(7) == True\n    assert candidate(11) == False\n    assert candidate(13) == True\n    assert candidate(17) == True\n    assert candidate(19) == True\n    assert candidate(21) == False\n    assert candidate(23) == False\n    assert candidate(31) == True\n    assert candidate(49) == False\n    assert candidate(61) == True\n    assert candidate(89) == True\n    assert candidate(107) == True\n    assert candidate(127) == True\n    assert candidate(221) == False\n    assert candidate(521) == True\n    assert candidate(607) == True\n    assert candidate(1279) == True\n\n","canonical_solution":"def valid_mersenne(n):\n    return n in {2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279}"}
{"task_id":3536,"prompt":"\"\"\"\n=====Problem statement====\n\n# Kata Task\n\nYou are given a list of cogs in a gear train\n\nEach element represents the number of teeth of that cog\n\ne.g. `[100, 50, 25]` means \n* 1st cog has 100 teeth \n* 2nd cog has 50 teeth\n* 3rd cog has 25 teeth\n\nIf the ``nth`` cog rotates clockwise at 1 RPM what is the RPM of the cogs at each end of the gear train? \n\n**Notes**\n* no two cogs share the same shaft\n* return an array whose two elements are RPM of the first and last cogs respectively\n* use negative numbers for anti-clockwise rotation\n* for convenience `n` is zero-based\n* For C and NASM coders, the returned array will be `free`'d.\n\n---\n\nSeries:\n* Cogs\n* Cogs 2\n\"\"\"\n\n# ====== Solution ======\n\ndef cog_RPM(cogs, n):\n","entry_point":"cog_RPM","test":"def check(candidate):\n    assert candidate([100],0) == [1, 1]\n    assert candidate([100, 100, 100, 100],0) == [1, -1]\n    assert candidate([100, 100, 100, 100],1) == [-1, 1]\n    assert candidate([100, 100, 100, 100],2) == [1, -1]\n    assert candidate([100, 100, 100, 100],3) == [-1, 1]\n\n","canonical_solution":"def cog_RPM(cogs, n):\n    return [\n        cogs[n] \/ cogs[0] * (-1 if n % 2 else 1),\n        cogs[n] \/ cogs[-1] * (1 if (len(cogs) - n) % 2 else -1),\n    ]"}
{"task_id":3537,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this Kata we are passing a number (n) into a function. \n\nYour code will determine if the number passed is even (or not). \n\nThe function needs to return either a true or false. \n\nNumbers may be positive or negative, integers or floats.\n\nFloats are considered UNeven for this kata.\n\"\"\"\n\n# ====== Solution ======\n\ndef is_even(n): \n","entry_point":"is_even","test":"def check(candidate):\n    assert candidate(0) == True\n    assert candidate(0.5) == False\n    assert candidate(1) == False\n    assert candidate(2) == True\n    assert candidate(-4) == True\n    assert candidate(15) == False\n    assert candidate(20) == True\n    assert candidate(220) == True\n    assert candidate(222222221) == False\n    assert candidate(500000000) == True\n\n","canonical_solution":"def is_even(n): \n    return n%2 == 0"}
{"task_id":3542,"prompt":"\"\"\"\n=====Problem statement====\n\nThis is related to my other Kata about cats and dogs.\n\n# Kata Task\n\nI have a cat and a dog which I got as kitten \/ puppy.\n\nI forget when that was, but I do know their current ages as `catYears` and `dogYears`.\n\nFind how long I have owned each of my pets and return as a list [`ownedCat`, `ownedDog`]\n\nNOTES:\n* Results are truncated whole numbers of \"human\" years\n\n## Cat Years\n\n* `15` cat years for first year\n* `+9` cat years for second year\n* `+4` cat years for each year after that\n\n## Dog Years\n\n* `15` dog years for first year\n* `+9` dog years for second year\n* `+5` dog years for each year after that\n\n\n\n**References**\n\n* http:\/\/www.catster.com\/cats-101\/calculate-cat-age-in-cat-years\n* http:\/\/www.slate.com\/articles\/news_and_politics\/explainer\/2009\/05\/a_dogs_life.html\n\"\"\"\n\n# ====== Solution ======\n\ndef owned_cat_and_dog(cy, dy):\n","entry_point":"owned_cat_and_dog","test":"def check(candidate):\n    assert candidate(9,7) == [0, 0]\n    assert candidate(15,15) == [1, 1]\n    assert candidate(18,21) == [1, 1]\n    assert candidate(19,17) == [1, 1]\n    assert candidate(24,24) == [2, 2]\n    assert candidate(25,25) == [2, 2]\n    assert candidate(26,26) == [2, 2]\n    assert candidate(27,27) == [2, 2]\n    assert candidate(56,64) == [10, 10]\n\n","canonical_solution":"def owned_cat_and_dog(cy, dy):\n    cat = 0 if cy < 15 else 1 if cy < 24 else 2 + (cy - 24) \/\/ 4\n    dog = 0 if dy < 15 else 1 if dy < 24 else 2 + (dy - 24) \/\/ 5\n    return [cat, dog]"}
{"task_id":3544,"prompt":"\"\"\"\n=====Problem statement====\n\nThe Earth has been invaded by aliens. They demand our beer and threaten to destroy the Earth if we do not supply the exact number of beers demanded.\n\nUnfortunately, the aliens only speak Morse code. Write a program to convert morse code into numbers using the following convention:\n\n1 .----\n2 ..---\n3 ...--\n4 ....-\n5 .....\n6 -....\n7 --...\n8 ---..\n9 ----.\n0 -----\n\"\"\"\n\n# ====== Solution ======\n\nMORSE_TO_NUM = {\n    \".----\" : \"1\",\n    \"..---\" : \"2\",\n    \"...--\" : \"3\",\n    \"....-\" : \"4\",\n    \".....\" : \"5\",\n    \"-....\" : \"6\",\n    \"--...\" : \"7\",\n    \"---..\" : \"8\",\n    \"----.\" : \"9\",\n    \"-----\" : \"0\",\n}\n\ndef morse_converter(s):\n","entry_point":"morse_converter","test":"def check(candidate):\n    assert candidate('.----.----.----.----.----') == 11111\n    assert candidate('..----------...-....----------') == 207600\n    assert candidate('---------------') == 0\n    assert candidate('..---.--------....--') == 2193\n    assert candidate('.----..---...--....-.....-....--...---..----.-----') == 1234567890\n\n","canonical_solution":"MORSE_TO_NUM = {\n    \".----\" : \"1\",\n    \"..---\" : \"2\",\n    \"...--\" : \"3\",\n    \"....-\" : \"4\",\n    \".....\" : \"5\",\n    \"-....\" : \"6\",\n    \"--...\" : \"7\",\n    \"---..\" : \"8\",\n    \"----.\" : \"9\",\n    \"-----\" : \"0\",\n}\n\ndef morse_converter(s):\n    return int(\"\".join(MORSE_TO_NUM[s[i:i+5]] for i in range(0, len(s), 5)))\n"}
{"task_id":3552,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are playing euchre and you want to know the new score after finishing a hand. There are two teams and each hand consists of 5 tricks. The team who wins the majority of the tricks will win points but the number of points varies. To determine the number of points, you must know which team called trump, how many tricks each team won, and if anyone went alone. Scoring is as follows:\n\nFor the team that called trump:\n\n- if they win 2 or less tricks -> other team wins 2 points\n\n- if they win 3 or 4 tricks -> 1 point\n\n- if they don't go alone and win 5 tricks -> 2 points\n\n- if they go alone and win 5 tricks -> 4 points\n\nOnly the team who called trump can go alone and you will notice that it only increases your points if you win all 5 tricks.\n\n\nYour job is to create a method to calculate the new score. When reading the arguments, team 1 is represented by 1 and team 2 is represented by 2. All scores will be stored with this order: { team1, team2 }.\n\"\"\"\n\n# ====== Solution ======\n\ndef update_score(score, trump, alone, tricks):\n","entry_point":"update_score","test":"def check(candidate):\n    assert candidate([4, 0],1,False,[2, 2, 2, 2, 2]) == [4, 2]\n    assert candidate([4, 2],1,True,[2, 2, 2, 2, 2]) == [4, 4]\n    assert candidate([4, 4],2,False,[2, 2, 2, 2, 2]) == [4, 6]\n    assert candidate([4, 6],2,True,[2, 2, 2, 2, 2]) == [4, 10]\n    assert candidate([7, 2],1,False,[1, 2, 2, 2, 2]) == [7, 4]\n    assert candidate([7, 4],1,True,[1, 2, 2, 2, 2]) == [7, 6]\n    assert candidate([7, 6],2,False,[1, 2, 2, 2, 2]) == [7, 7]\n    assert candidate([7, 7],2,True,[1, 2, 2, 2, 2]) == [7, 8]\n    assert candidate([5, 1],1,False,[1, 1, 2, 2, 2]) == [5, 3]\n    assert candidate([5, 3],1,True,[1, 1, 2, 2, 2]) == [5, 5]\n    assert candidate([5, 5],2,False,[1, 1, 2, 2, 2]) == [5, 6]\n    assert candidate([5, 6],2,True,[1, 1, 2, 2, 2]) == [5, 7]\n    assert candidate([3, 4],1,False,[1, 1, 1, 2, 2]) == [4, 4]\n    assert candidate([4, 4],1,True,[1, 1, 1, 2, 2]) == [5, 4]\n    assert candidate([5, 4],2,False,[1, 1, 1, 2, 2]) == [7, 4]\n    assert candidate([7, 4],2,True,[1, 1, 1, 2, 2]) == [9, 4]\n    assert candidate([3, 9],1,False,[1, 1, 1, 1, 2]) == [4, 9]\n    assert candidate([4, 9],1,True,[1, 1, 1, 1, 2]) == [5, 9]\n    assert candidate([5, 9],2,False,[1, 1, 1, 1, 2]) == [7, 9]\n    assert candidate([7, 9],2,True,[1, 1, 1, 1, 2]) == [9, 9]\n    assert candidate([0, 8],1,False,[1, 1, 1, 1, 1]) == [2, 8]\n    assert candidate([2, 8],1,True,[1, 1, 1, 1, 1]) == [6, 8]\n    assert candidate([6, 8],2,False,[1, 1, 1, 1, 1]) == [8, 8]\n    assert candidate([8, 8],2,True,[1, 1, 1, 1, 1]) == [10, 8]\n\n","canonical_solution":"def update_score(score, trump, alone, tricks):\n    done = tricks.count(trump)\n    mul = 2 if done == 5 and alone else 1\n    add = 1 if done in (3, 4) else 2\n    winner = trump if done > 2 else (3 - trump)\n    return [pts + (add * mul if team == winner else 0) for team, pts in enumerate(score, 1)]"}
{"task_id":3553,"prompt":"\"\"\"\n=====Problem statement====\n\nThere's a new security company in Paris, and they decided to give their employees an algorithm to make first name recognition faster. In the blink of an eye, they can now detect if a string is a first name, no matter if it is a one-word name or an hyphenated name. They're given this documentation with the algorithm: \n\n*In France, you'll often find people with hyphenated first names. They're called \"pr\u00e9noms compos\u00e9s\".\nThere could be two, or even more words linked to form a new name, quite like jQuery function chaining ;). \nThey're linked using the - symbol, like Marie-Joelle, Jean-Michel, Jean-Mouloud. \nThanks to this algorithm, you can now recognize hyphenated names quicker than Flash !* \n(yeah, their employees know how to use jQuery. Don't ask me why)\n\n\nYour mission if you accept it, recreate the algorithm.\nUsing the function **showMe**, which takes a **yourID** argument, you will check if the given argument is a name or not, by returning true or false. \n\n*Note that*\n\n- String will either be a one-word first name, or an hyphenated first name , its words being linked by \"-\". \n- Words can only start with an uppercase letter, and then lowercase letters (from a to z)\n\n\nNow is your time to help the guards !\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\n\ndef show_me(name):\n","entry_point":"show_me","test":"def check(candidate):\n    assert candidate('Francis') == True\n    assert candidate('Jean-Eluard') == True\n    assert candidate('Le Mec') == False\n    assert candidate('Bernard-Henry-Levy') == True\n    assert candidate('Meme Gertrude') == False\n    assert candidate('A-a-a-a----a-a') == False\n    assert candidate('Z-------------') == False\n    assert candidate('Jean-luc') == False\n    assert candidate('Jean--Luc') == False\n    assert candidate('JeanLucPicard') == False\n    assert candidate('-Jean-Luc') == False\n    assert candidate('Jean-Luc-Picard-') == False\n\n","canonical_solution":"import re\n\n\ndef show_me(name):\n    return bool(re.match(r'(-[A-Z][a-z]+)+$', '-' + name))"}
{"task_id":3564,"prompt":"\"\"\"\n=====Problem statement====\n\nwrite me a function `stringy` that takes a `size` and returns a `string` of alternating `'1s'` and `'0s'`.\n\nthe string should start with a `1`.\n\na string with `size` 6 should return :`'101010'`.\n\nwith `size` 4 should return : `'1010'`.\n\nwith `size` 12 should return : `'101010101010'`.\n\nThe size will always be positive and will only use whole numbers.\n\"\"\"\n\n# ====== Solution ======\n\ndef stringy(size):\n","entry_point":"stringy","test":"def check(candidate):\n    assert candidate(3) == '101'\n    assert candidate(5) == '10101'\n    assert candidate(12) == '101010101010'\n    assert candidate(26) == '10101010101010101010101010'\n    assert candidate(28) == '1010101010101010101010101010'\n\n","canonical_solution":"def stringy(size):\n    return \"\".join([str(i % 2) for i in range(1, size + 1)])"}
{"task_id":3566,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven two integer arrays where the second array is a shuffled duplicate of the first array with one element missing, find the missing element.\n\nPlease note, there may be duplicates in the arrays, so checking if a numerical value exists in one and not the other is not a valid solution.\n\n```\nfind_missing([1, 2, 2, 3], [1, 2, 3]) => 2\n```\n```\nfind_missing([6, 1, 3, 6, 8, 2], [3, 6, 6, 1, 2]) => 8\n```\n\nThe first array will always have at least one element.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_missing(arr1, arr2):\n","entry_point":"find_missing","test":"def check(candidate):\n    assert candidate([1, 2, 3],[1, 3]) == 2\n    assert candidate([6, 1, 3, 6, 8, 2],[3, 6, 6, 1, 2]) == 8\n    assert candidate([7],[]) == 7\n    assert candidate([4, 3, 3, 61, 8, 8],[8, 61, 8, 3, 4]) == 3\n    assert candidate([0, 0, 0, 0, 0],[0, 0, 0, 0]) == 0\n\n","canonical_solution":"def find_missing(arr1, arr2):\n    return sum(arr1) - sum(arr2)\n"}
{"task_id":3572,"prompt":"\"\"\"\n=====Problem statement====\n\n### Task\n King Arthur and his knights are having a New Years party. Last year Lancelot was jealous of Arthur, because Arthur had a date and Lancelot did not, and they started a duel.\n\n To prevent this from happening again, Arthur wants to make sure that there are at least as many women as men at this year's party. He gave you a list of integers of all the party goers. \n \n Arthur needs you to return true if he needs to invite more women or false if he is all set.\n\n### Input\/Output\n\n\n - `[input]` integer array `L` (`$a` in PHP)\n\n  An array (guaranteed non-associative in PHP) representing the genders of the attendees, where `-1` represents `women` and `1` represents `men`.\n  \n  `2 <= L.length <= 50`\n  \n\n- `[output]` a boolean value\n\n  `true` if Arthur need to invite more women, `false` otherwise.\n\"\"\"\n\n# ====== Solution ======\n\ndef invite_more_women(arr):\n","entry_point":"invite_more_women","test":"def check(candidate):\n    assert candidate([1, -1, 1]) == True\n    assert candidate([-1, -1, -1]) == False\n    assert candidate([1, -1]) == False\n    assert candidate([1, 1, 1]) == True\n    assert candidate([]) == False\n\n","canonical_solution":"def invite_more_women(arr):\n    return sum(arr) > 0"}
{"task_id":3581,"prompt":"\"\"\"\n=====Problem statement====\n\nThanks to the effects of El Nino this year my holiday snorkelling trip was akin to being in a washing machine... Not fun at all.\n\nGiven a string made up of '~' and '\\_' representing waves and calm respectively, your job is to check whether a person would become seasick.\n\nRemember, only the process of change from wave to calm (and vice versa) will add to the effect (really wave peak to trough but this will do). Find out how many changes in level the string has and if that figure is more than 20% of the string, return \"Throw Up\", if less, return \"No Problem\".\n\"\"\"\n\n# ====== Solution ======\n\ndef sea_sick(sea):\n","entry_point":"sea_sick","test":"def check(candidate):\n    assert candidate('~') == 'No Problem'\n    assert candidate('_~~~~~~~_~__~______~~__~~_~~') == 'Throw Up'\n    assert candidate('______~___~_') == 'Throw Up'\n    assert candidate('____') == 'No Problem'\n    assert candidate('_~~_~____~~~~~~~__~_~') == 'Throw Up'\n\n","canonical_solution":"def sea_sick(sea):\n    return \"Throw Up\" if (sea.count(\"~_\") + sea.count(\"_~\"))\/len(sea) > 0.2 else \"No Problem\""}
{"task_id":3589,"prompt":"\"\"\"\n=====Problem statement====\n\nMake a function that receives a value, ```val``` and outputs the smallest higher number than the given value, and this number belong to a set of positive integers that have the following properties:\n\n- their digits occur only once\n\n- they are odd\n\n- they are multiple of three\n\n```python\nnext_numb(12) == 15\n\nnext_numb(13) == 15\n\nnext_numb(99) == 105\n\nnext_numb(999999) == 1023459\n\nnext_number(9999999999) == \"There is no possible number that\nfulfills those requirements\"\n```\n\nEnjoy the kata!!\n\"\"\"\n\n# ====== Solution ======\n\ndef unique_digits(n):\n    return len(set(str(n))) == len(str(n))\n\ndef next_numb(val):\n","entry_point":"next_numb","test":"def check(candidate):\n    assert candidate(12) == 15\n    assert candidate(13) == 15\n    assert candidate(99) == 105\n    assert candidate(999999) == 1023459\n    assert candidate(9999999999) == 'There is no possible number that fulfills those requirements'\n\n","canonical_solution":"def unique_digits(n):\n    return len(set(str(n))) == len(str(n))\n\ndef next_numb(val):\n    val += 1\n    while val % 3: val += 1\n    if val % 2 == 0: val += 3\n    \n    while not unique_digits(val):\n        val += 6\n        if val > 9876543210: break\n    else:\n        return val\n    \n    return \"There is no possible number that fulfills those requirements\"\n"}
{"task_id":3594,"prompt":"\"\"\"\n=====Problem statement====\n\n**An [isogram](https:\/\/en.wikipedia.org\/wiki\/Isogram)** (also known as a \"nonpattern word\") is a logological term for a word or phrase without a repeating letter. It is also used by some to mean a word or phrase in which each letter appears the same number of times, not necessarily just once.\n\nYou task is to write a method `isogram?` that takes a string argument and returns true if the string has the properties of being an isogram and false otherwise. Anything that is not a string is not an isogram (ints, nils, etc.)\n\n\n**Properties:**\n \n - must be a string\n - cannot be nil or empty\n - each letter appears the same number of times (not necessarily just once)\n - letter case is not important (= case insensitive)\n - non-letter characters (e.g. hyphens) should be ignored\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import Counter\nimport re\n\ndef is_isogram(word):\n","entry_point":"is_isogram","test":"def check(candidate):\n    assert candidate(None) == False\n    assert candidate(3) == False\n    assert candidate('Dermatoglyphics') == True\n    assert candidate('isogram') == True\n    assert candidate('eleven') == False\n    assert candidate('moOse') == False\n    assert candidate('isIsogram') == False\n    assert candidate('') == False\n    assert candidate('-.-') == False\n    assert candidate('subdermatoglyphic') == True\n    assert candidate('Alphabet') == False\n    assert candidate('thumbscrew-japingly') == True\n    assert candidate('Hjelmqvist-Gryb-Zock-Pfund-Wax') == True\n    assert candidate('Emily Jung Schwartzkopf') == True\n    assert candidate('aabbccddeeffgg') == True\n\n","canonical_solution":"from collections import Counter\nimport re\n\ndef is_isogram(word):\n    if type(word) is not str or not word: return False\n    return len(set( Counter(re.sub(r'[^a-z]', \"\", word.lower())).values() )) == 1"}
{"task_id":3598,"prompt":"\"\"\"\n=====Problem statement====\n\nFinding your seat on a plane is never fun, particularly for a long haul flight... You arrive, realise again just how little leg room you get, and sort of climb into the seat covered in a pile of your own stuff.\n\nTo help confuse matters (although they claim in an effort to do the opposite) many airlines omit the letters 'I' and 'J' from their seat naming system.\n\nthe naming system consists of a number (in this case between 1-60) that denotes the section of the plane where the seat is (1-20 = front, 21-40 = middle, 40+ = back). This number is followed by a letter, A-K with the exclusions mentioned above.\n\nLetters A-C denote seats on the left cluster, D-F the middle and G-K the right.\n\nGiven a seat number, your task is to return the seat location in the following format:\n\n'2B' would return 'Front-Left'.\n\nIf the number is over 60, or the letter is not valid, return 'No Seat!!'.\n\"\"\"\n\n# ====== Solution ======\n\ndef plane_seat(a):\n","entry_point":"plane_seat","test":"def check(candidate):\n    assert candidate('2B') == 'Front-Left'\n    assert candidate('20B') == 'Front-Left'\n    assert candidate('58I') == 'No Seat!!'\n    assert candidate('60D') == 'Back-Middle'\n    assert candidate('17K') == 'Front-Right'\n\n","canonical_solution":"def plane_seat(a):\n    front, middle, back = (list(range(1,21)), list(range(21,41)), list(range(41,61)))\n    left, center, right = ('ABC', 'DEF', \"GHK\")\n    x, y = ('', '')\n        \n    if int(a[:-1]) in front:    x = 'Front-'\n    if int(a[:-1]) in middle:   x = 'Middle-'\n    if int(a[:-1]) in back:     x = 'Back-'\n\n    if a[-1] in left:    y = 'Left'\n    if a[-1] in center:  y = 'Middle'\n    if a[-1] in right:   y = 'Right'\n    \n    return x+y if all((x,y)) else 'No Seat!!'\n"}
{"task_id":3607,"prompt":"\"\"\"\n=====Problem statement====\n\nNot considering number 1, the integer 153 is the first integer having this property:\nthe sum of the third-power of each of its digits  is equal to 153. Take a look:\n153 = 1^3 + 5^3 + 3^3 = 1 + 125 + 27 = 153\n\nThe next number that experiments this particular behaviour is 370 with the same power.\n\nWrite the function `eq_sum_powdig()`, that finds the numbers below a given upper limit `hMax` that fulfill this property but with different exponents as a power for the digits.\n\neq_sum_powdig(hMax, exp): ----> sequence of numbers (sorted list) (Number one should not be considered).\n\nLet's see some cases:\n```python\neq_sum_powdig(100, 2) ----> []\n\neq_sum_powdig(1000, 2) ----> []\n\neq_sum_powdig(200, 3) ----> [153]\n\neq_sum_powdig(370, 3) ----> [153, 370]\n```\nEnjoy it !!\n\"\"\"\n\n# ====== Solution ======\n\ndef eq_sum_powdig(hMax, exp):\n","entry_point":"eq_sum_powdig","test":"def check(candidate):\n    assert candidate(100,2) == []\n    assert candidate(1000,2) == []\n    assert candidate(2000,2) == []\n    assert candidate(200,3) == [153]\n    assert candidate(370,3) == [153, 370]\n    assert candidate(400,3) == [153, 370, 371]\n    assert candidate(500,3) == [153, 370, 371, 407]\n    assert candidate(1000,3) == [153, 370, 371, 407]\n    assert candidate(1500,3) == [153, 370, 371, 407]\n\n","canonical_solution":"def eq_sum_powdig(hMax, exp):\n    return [i for i in range(2, hMax + 1) if i == sum(int(c) ** exp for c in str(i))]\n"}
{"task_id":3617,"prompt":"\"\"\"\n=====Problem statement====\n\nAn array is called `zero-balanced` if its elements sum to `0` and for each positive element `n`, there exists another element that is the negative of `n`. Write a function named `\u00ecsZeroBalanced` that returns `true` if its argument is `zero-balanced` array, else return `false`. Note that an `empty array` will not sum to `zero`.\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import Counter\n\ndef is_zero_balanced(arr):\n","entry_point":"is_zero_balanced","test":"def check(candidate):\n    assert candidate([3]) == False\n    assert candidate([-3]) == False\n    assert candidate([0, 0, 0, 0, 0, 0]) == True\n    assert candidate([0, 1, -1]) == True\n    assert candidate([]) == False\n    assert candidate([3, -2, -1]) == False\n    assert candidate([0]) == True\n    assert candidate([1, 1, -2]) == False\n    assert candidate([-1, 1, -2, 2, -2, -2, -4, 4]) == False\n    assert candidate([0, 0, 0, 0, 0]) == True\n\n","canonical_solution":"from collections import Counter\n\ndef is_zero_balanced(arr):\n    c = Counter(arr)\n    return bool(arr) and all(c[k] == c[-k] for k in c)"}
{"task_id":3622,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a simple regex to validate a username. Allowed characters are:\n\n- lowercase letters,\n- numbers,\n- underscore\n\nLength should be between 4 and 16 characters (both included).\n\"\"\"\n\n# ====== Solution ======\n\nimport re\ndef validate_usr(un):\n","entry_point":"validate_usr","test":"def check(candidate):\n    assert candidate('asddsa') == True\n    assert candidate('a') == False\n    assert candidate('Hass') == False\n    assert candidate('Hasd_12assssssasasasasasaasasasasas') == False\n    assert candidate('') == False\n    assert candidate('____') == True\n    assert candidate('012') == False\n    assert candidate('p1pp1') == True\n    assert candidate('asd43 34') == False\n    assert candidate('asd43_34') == True\n\n","canonical_solution":"import re\ndef validate_usr(un):\n    return re.match('^[a-z0-9_]{4,16}$', un) != None"}
{"task_id":3629,"prompt":"\"\"\"\n=====Problem statement====\n\nMash 2 arrays together so that the returning array has alternating elements of the 2 arrays . Both arrays will always be the same length.\n\neg. [1,2,3] + ['a','b','c'] =  [1, 'a', 2, 'b', 3, 'c']\n\"\"\"\n\n# ====== Solution ======\n\ndef array_mash(xs, ys):\n","entry_point":"array_mash","test":"def check(candidate):\n    assert candidate([1, 2, 3],['a', 'b', 'c']) == [1, 'a', 2, 'b', 3, 'c']\n    assert candidate([1, 2, 3, 4, 5],['a', 'b', 'c', 'd', 'e']) == [1, 'a', 2, 'b', 3, 'c', 4, 'd', 5, 'e']\n    assert candidate([1, 1, 1, 1],[2, 2, 2, 2]) == [1, 2, 1, 2, 1, 2, 1, 2]\n    assert candidate([1, 8, 'hello', 'dog'],['fish', '2', 9, 10]) == [1, 'fish', 8, '2', 'hello', 9, 'dog', 10]\n    assert candidate([None, 4],[None, 'hello']) == [None, None, 4, 'hello']\n    assert candidate([1],[2]) == [1, 2]\n    assert candidate(['h', 'l', 'o', 'o', 'l'],['e', 'l', 'w', 'r', 'd']) == ['h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd']\n\n","canonical_solution":"def array_mash(xs, ys):\n    return [z for p in zip(xs, ys) for z in p]"}
{"task_id":3632,"prompt":"\"\"\"\n=====Problem statement====\n\nThe __Hamming weight__ of a string is the number of symbols that are different from the zero-symbol of the alphabet used. There are several algorithms for efficient computing of the Hamming weight for numbers. In this Kata, speaking technically, you have to find out the number of '1' bits in a binary representation of a number. Thus,\n\nThe interesting part of this task is that you have to do it *without* string operation (hey, it's not really interesting otherwise)\n\n ;)\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"hamming_weight","test":"def check(candidate):\n    assert candidate(0) == 0\n    assert candidate(1) == 1\n    assert candidate(2) == 1\n    assert candidate(10) == 2\n    assert candidate(21) == 3\n    assert candidate(2048) == 1\n\n","canonical_solution":"def hamming_weight(x):return bin(x).count('1')"}
{"task_id":3649,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are a biologist working on the amino acid  composition of proteins. Every protein consists of a long chain of 20 different amino acids with different properties. \nCurrently, you are collecting data on the percentage, various amino acids make up a protein you are working on. As manually counting the occurences of amino acids takes too long (especially when counting more than one amino acid), you decide to write a program for this task:\n\nWrite a function that takes two arguments,\n 1. A (snippet of a) protein sequence\n 2. A list of amino acid residue codes \n\nand returns the rounded percentage of the protein that the given amino acids make up. \nIf no amino acid list is given, return the percentage of hydrophobic amino acid residues [\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"].\n\"\"\"\n\n# ====== Solution ======\n\ndef aa_percentage(seq, residues=[\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"]):\n","entry_point":"aa_percentage","test":"def check(candidate):\n    assert candidate('MSRSLLLRFLLFLLLLPPLP',['M']) == 5\n    assert candidate('MSRSLLLRFLLFLLLLPPLP',['M', 'L']) == 55\n    assert candidate('MSRSLLLRFLLFLLLLPPLP',['F', 'S', 'L']) == 70\n    assert candidate('MSRSLLLRFLLFLLLLPPLP') == 65\n    assert candidate('RLMADDFFGQTLMAAAAAAQERRR',['A']) == 29\n    assert candidate('RLMADDFFGQTLMAAAAAAQERRR',['A', 'R', 'D']) == 54\n    assert candidate('RLMADDFFGQTLMAAAAAAQERRR') == 54\n    assert candidate('PLPPLPLLEELELRPFFMAAGGTPLAMMGG',['X']) == 0\n    assert candidate('PLPPLPLLEELELRPFFMAAGGTPLAMMGG',['P', 'L']) == 43\n    assert candidate('PLPPLPLLEELELRPFFMAAGGTPLAMMGG',['P', 'E', 'L', 'R', 'F', 'M', 'A', 'G', 'T']) == 100\n    assert candidate('PLPPLPLLEELELRPFFMAAGGTPLAMMGG') == 50\n\n","canonical_solution":"def aa_percentage(seq, residues=[\"A\", \"I\", \"L\", \"M\", \"F\", \"W\", \"Y\", \"V\"]):\n  return round(sum(seq.count(r) for r in residues)\/len(seq)*100)"}
{"task_id":3664,"prompt":"\"\"\"\n=====Problem statement====\n\nYou will be given a string (x) featuring a cat 'C' and a mouse 'm'. The rest of the string will be made up of '.'. \n\nYou need to find out if the cat can catch the mouse from it's current position. The cat can jump over three characters. So:\n\nC.....m returns 'Escaped!'  <-- more than three characters between\n\nC...m returns 'Caught!'   <-- as there are three characters between the two, the cat can jump.\n\"\"\"\n\n# ====== Solution ======\n\ndef cat_mouse(x):\n","entry_point":"cat_mouse","test":"def check(candidate):\n    assert candidate('C....m') == 'Escaped!'\n    assert candidate('C..m') == 'Caught!'\n    assert candidate('C.....m') == 'Escaped!'\n    assert candidate('C.m') == 'Caught!'\n    assert candidate('m...C') == 'Caught!'\n\n","canonical_solution":"def cat_mouse(x):\n    return 'Escaped!' if x.count('.') > 3 else 'Caught!'"}
{"task_id":3665,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are given two positive integers `a` and `b` (`a < b <= 20000`). Complete the function which returns a list of all those numbers in the interval `[a, b)` whose digits are made up of prime numbers (`2, 3, 5, 7`) but which are not primes themselves.\n\n\nBe careful about your timing!\n\n\nGood luck :)\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import sqrt\ndef is_prime(n):\n    if n < 2: return False\n    for x in range(2, int(sqrt(n)) + 1):\n        if n % x == 0: return False\n    return True\n\ndef all_dig_prime(n):\n    for d in str(n):\n        if d not in \"2357\": return False\n    return True\n\ndef not_primes(a, b):\n","entry_point":"not_primes","test":"def check(candidate):\n    assert candidate(2,222) == [22, 25, 27, 32, 33, 35, 52, 55, 57, 72, 75, 77]\n    assert candidate(2,77) == [22, 25, 27, 32, 33, 35, 52, 55, 57, 72, 75]\n    assert candidate(2700,3000) == [2722, 2723, 2725, 2727, 2732, 2733, 2735, 2737, 2752, 2755, 2757, 2772, 2773, 2775]\n    assert candidate(500,999) == [522, 525, 527, 532, 533, 535, 537, 552, 553, 555, 572, 573, 575, 722, 723, 725, 732, 735, 737, 752, 753, 755, 772, 775, 777]\n    assert candidate(999,2500) == [2222, 2223, 2225, 2227, 2232, 2233, 2235, 2252, 2253, 2255, 2257, 2272, 2275, 2277, 2322, 2323, 2325, 2327, 2332, 2335, 2337, 2352, 2353, 2355, 2372, 2373, 2375]\n\n","canonical_solution":"from math import sqrt\ndef is_prime(n):\n    if n < 2: return False\n    for x in range(2, int(sqrt(n)) + 1):\n        if n % x == 0: return False\n    return True\n\ndef all_dig_prime(n):\n    for d in str(n):\n        if d not in \"2357\": return False\n    return True\n\ndef not_primes(a, b):\n    res = []\n    for i in range(a,b):\n        if all_dig_prime(i) and not is_prime(i): res.append(i)\n    return res"}
{"task_id":3671,"prompt":"\"\"\"\n=====Problem statement====\n\nMake a function that returns the value multiplied by 50 and increased by 6. If the value entered is a string it should return \"Error\".\n\nNote: in `C#`, you'll always get the input as a string, so the above applies if the string isn't representing a double value.\n\"\"\"\n\n# ====== Solution ======\n\ndef problem(a):\n","entry_point":"problem","test":"def check(candidate):\n    assert candidate('hello') == 'Error'\n    assert candidate(1) == 56\n    assert candidate(5) == 256\n    assert candidate(0) == 6\n    assert candidate(1.2) == 66\n    assert candidate(3) == 156\n    assert candidate('RyanIsCool') == 'Error'\n\n","canonical_solution":"def problem(a):\n    try:\n        return a * 50 + 6\n    except TypeError:\n        return \"Error\""}
{"task_id":3674,"prompt":"\"\"\"\n=====Problem statement====\n\nImplement a function that adds two numbers together and returns their sum in binary. The conversion can be done before, or after the addition.\n\nThe binary number returned should be a string.\n\"\"\"\n\n# ====== Solution ======\n\ndef add_binary(a,b):\n","entry_point":"add_binary","test":"def check(candidate):\n    assert candidate(1,1) == '10'\n    assert candidate(0,1) == '1'\n    assert candidate(1,0) == '1'\n    assert candidate(2,2) == '100'\n    assert candidate(51,12) == '111111'\n    assert candidate(5,9) == '1110'\n    assert candidate(10,10) == '10100'\n    assert candidate(100,100) == '11001000'\n    assert candidate(4096,1) == '1000000000001'\n    assert candidate(0,2174483647) == '10000001100110111111110010111111'\n\n","canonical_solution":"def add_binary(a,b):\n    return bin(a+b)[2:]\n"}
{"task_id":3678,"prompt":"\"\"\"\n=====Problem statement====\n\nYou've just entered a programming contest and have a chance to win a million dollars. This is the last question you have to solve, so your victory (and your vacation) depend on it. Can you guess the function just by looking at the test cases? There are two numerical inputs and one numerical output. Goodluck!\n\nhint: go\n here\n\"\"\"\n\n# ====== Solution ======\n\nTABLE = str.maketrans('0123456789','9876543210')\n\ndef code(*args):\n","entry_point":"code","test":"def check(candidate):\n    assert candidate(9,8) == 1\n    assert candidate(123,456) == 1419\n    assert candidate(3,2) == 13\n    assert candidate(1,1) == 16\n    assert candidate(12,8) == 88\n    assert candidate(200,100) == 1698\n    assert candidate(100,200) == 1698\n\n","canonical_solution":"TABLE = str.maketrans('0123456789','9876543210')\n\ndef code(*args):\n    return sum(map(lambda n:int(str(n).translate(TABLE)), args))"}
{"task_id":3689,"prompt":"\"\"\"\n=====Problem statement====\n\nHow much bigger is a 16-inch pizza compared to an 8-inch pizza? A more pragmatic question is: How many 8-inch pizzas \"fit\" in a 16-incher?\n\nThe answer, as it turns out, is exactly four 8-inch pizzas. For sizes that don't correspond to a round number of 8-inchers, you must round the number of slices (one 8-inch pizza = 8 slices), e.g.:\n\n```python\nhow_many_pizzas(16) -> \"pizzas: 4, slices: 0\"\nhow_many_pizzas(12) -> \"pizzas: 2, slices: 2\"\nhow_many_pizzas(8) -> \"pizzas: 1, slices: 0\"\nhow_many_pizzas(6) -> \"pizzas: 0, slices: 4\"\nhow_many_pizzas(0) -> \"pizzas: 0, slices: 0\"\n```\nGet coding quick, so you can choose the ideal size for your next meal!\n\"\"\"\n\n# ====== Solution ======\n\ndef how_many_pizzas(n):\n","entry_point":"how_many_pizzas","test":"def check(candidate):\n    assert candidate(16) == 'pizzas: 4, slices: 0'\n    assert candidate(12) == 'pizzas: 2, slices: 2'\n    assert candidate(8) == 'pizzas: 1, slices: 0'\n    assert candidate(6) == 'pizzas: 0, slices: 4'\n    assert candidate(0) == 'pizzas: 0, slices: 0'\n\n","canonical_solution":"def how_many_pizzas(n):\n    return 'pizzas: {}, slices: {}'.format(*divmod(n * n \/\/ 8, 8))"}
{"task_id":3694,"prompt":"\"\"\"\n=====Problem statement====\n\nMuch cooler than your run-of-the-mill Fibonacci numbers, the Triple Shiftian are so defined: `T[n] = 4 * T[n-1] - 5 * T[n-2] + 3 * T[n-3]`.\n\nYou are asked to create a function which accept a base with the first 3 numbers and then returns the nth element.\n```python\ntriple_shiftian([1,1,1],25) == 1219856746\ntriple_shiftian([1,2,3],25) == 2052198929\ntriple_shiftian([6,7,2],25) == -2575238999\ntriple_shiftian([3,2,1],35) == 23471258855679\ntriple_shiftian([1,9,2],2) ==  2\n```\n*Note: this is meant to be an interview quiz, so the description is scarce in detail on purpose*\n\nSpecial thanks to the [first person I met in person here in London just because of CW](http:\/\/www.codewars.com\/users\/webtechalex) and that assisted me during the creation of this kata ;)\n\"\"\"\n\n# ====== Solution ======\n\ndef triple_shiftian(T,n):\n","entry_point":"triple_shiftian","test":"def check(candidate):\n    assert candidate([1, 1, 1],25) == 1219856746\n    assert candidate([1, 2, 3],25) == 2052198929\n    assert candidate([3, 2, 1],25) == 2827228055\n    assert candidate([6, 7, 2],25) == -2575238999\n    assert candidate([1, 1, 1],35) == 10127083068293\n    assert candidate([1, 2, 3],35) == 17037073417493\n    assert candidate([3, 2, 1],35) == 23471258855679\n    assert candidate([6, 7, 2],35) == -21379280887590\n    assert candidate([3, 2, 1],0) == 3\n    assert candidate([6, 7, 2],2) == 2\n\n","canonical_solution":"def triple_shiftian(T,n):\n    for i in range(3,n+1):\n        T.append(4 * T[i-1] - 5 * T[i-2] + 3 * T[i-3])\n    return T[n]  "}
{"task_id":3698,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this exercise, you will have to create a function named tiyFizzBuzz. This function will take on a string parameter and will return that string with some characters replaced, depending on the value:\n\n- If a letter is a upper case consonants, replace that character with \"Iron\".\n- If a letter is a lower case consonants or a non-alpha character, do nothing to that character\n- If a letter is a upper case vowel, replace that character with \"Iron Yard\".\n- If a letter is a lower case vowel, replace that character with \"Yard\".\n\nReady?\n\"\"\"\n\n# ====== Solution ======\n\ndef tiy_fizz_buzz(s):\n","entry_point":"tiy_fizz_buzz","test":"def check(candidate):\n    assert candidate(' ') == ' '\n    assert candidate('H') == 'Iron'\n    assert candidate('b') == 'b'\n    assert candidate('A') == 'Iron Yard'\n    assert candidate('a') == 'Yard'\n    assert candidate('Hello WORLD!') == 'IronYardllYard IronIron YardIronIronIron!'\n    assert candidate('H6H4Na .\/?U') == 'Iron6Iron4IronYard .\/?Iron Yard'\n\n","canonical_solution":"def tiy_fizz_buzz(s):\n    return \"\".join((\"Iron \"*c.isupper() + \"Yard\"*(c.lower() in \"aeiou\")).strip() or c for c in s)"}
{"task_id":3700,"prompt":"\"\"\"\n=====Problem statement====\n\nA family of kookaburras are in my backyard.\n\nI can't see them all, but I can hear them!\n\n# How many kookaburras are there?\n\n\n\n\n## Hint \n\nThe trick to counting kookaburras is to listen carefully\n\n* The males go ```HaHaHa```...\n\n* The females go ```hahaha```...\n\n* And they always alternate male\/female\n\n\n\n^ Kata Note : No validation is necessary; only valid input will be passed :-)\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\ndef kooka_counter(laughing):\n","entry_point":"kooka_counter","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('hahahahaha') == 1\n    assert candidate('hahahahahaHaHaHa') == 2\n    assert candidate('HaHaHahahaHaHa') == 3\n    assert candidate('hahahahahahahaHaHa') == 2\n\n","canonical_solution":"import re\n\ndef kooka_counter(laughing):\n    return len(re.findall(r'(ha)+|(Ha)+',laughing))"}
{"task_id":3701,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that calculates the *least common multiple* of its arguments; each argument is assumed to be a non-negative integer. In the case that there are no arguments (or the provided array in compiled languages is empty), return `1`.\n\n~~~if:objc\nNOTE: The first (and only named) argument of the function `n` specifies the number of arguments in the variable-argument list. Do **not** take `n` into account when computing the LCM of the numbers.\n~~~\n\"\"\"\n\n# ====== Solution ======\n\nfrom functools import reduce\ndef lcm(*args):\n    return reduce(lcms, args) if args else 1\n\ndef gcd(a,b):\n    \"\"\"Euclidean Algorithm\"\"\"\n    return b if a == 0 else gcd(b % a, a)\n    \ndef lcms(a, b):\n","entry_point":"lcm","test":"def check(candidate):\n    assert candidate(2,5) == 10\n    assert candidate(2,3,4) == 12\n    assert candidate(9) == 9\n    assert candidate(0) == 0\n    assert candidate(0,1) == 0\n    assert candidate(1,1,1) == 1\n    assert candidate(5,6,7,9,6,9,18,4,5,15,15,10,17,7) == 21420\n    assert candidate(17,20,4,15,4,18,12,14,20,19,2,14,13,7) == 5290740\n    assert candidate(11,13,4,5,17,4,10,13,16,13,13) == 194480\n    assert candidate(20,1,6,10,3,7,8,4) == 840\n    assert candidate(3,9,9,19,18,14,18,9) == 2394\n    assert candidate(3,9,9,19,18,14,18,0) == 0\n\n","canonical_solution":"from functools import reduce\ndef lcm(*args):\n    return reduce(lcms, args) if args else 1\n\ndef gcd(a,b):\n    \"\"\"Euclidean Algorithm\"\"\"\n    return b if a == 0 else gcd(b % a, a)\n    \ndef lcms(a, b):\n    return (a*b) \/\/ gcd(a,b)"}
{"task_id":3706,"prompt":"\"\"\"\n=====Problem statement====\n\nAssume that you started to store items in progressively expanding square location, like this for the first 9 numbers:\n\n```\n05 04 03\n06 01 02\n07 08 09\n```\n\nAnd like this for the expanding to include up to the first 25 numbers:\n\n```\n17 16 15 14 13\n18 05 04 03 12\n19 06 01 02 11\n20 07 08 09 10\n21 22 23 24 25\n```\n\nYou might easily notice that the first - and innermost - layer containes only one number (`01`), the second one  - immediately around it - contains 8 numbers (number in the `02-09` range) and so on.\n\nYour task is to create a function that given a number `n` simply returns the number of layers required to store up to `n` (included).\n\n```python\nlayers(1) == 1\nlayers(5) == 2\nlayers(25) == 3\nlayers(30) == 4\nlayers(50) == 5\n```\n\n**Fair warning:** you will always and only get positive integers, but be ready for bigger numbers in the tests!\n\nIf you had fun with this, also try some follow up kata: [progressive spiral number branch](https:\/\/www.codewars.com\/kata\/progressive-spiral-number-branch\/) and [progressive spiral number distance](https:\/\/www.codewars.com\/kata\/progressive-spiral-number-distance\/).\n\n*[Base idea taken from [here](http:\/\/adventofcode.com\/2017\/day\/3)]*\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil, sqrt\n\ndef layers(n):\n","entry_point":"layers","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(5) == 2\n    assert candidate(25) == 3\n    assert candidate(30) == 4\n    assert candidate(50) == 5\n\n","canonical_solution":"from math import ceil, sqrt\n\ndef layers(n):\n    return ceil(sqrt(n)) \/\/ 2 + 1"}
{"task_id":3709,"prompt":"\"\"\"\n=====Problem statement====\n\nThis kata is about multiplying a given number by eight if it is an even number and by nine otherwise.\n\"\"\"\n\n# ====== Solution ======\n\ndef simple_multiplication(number) :\n","entry_point":"simple_multiplication","test":"def check(candidate):\n    assert candidate(2) == 16\n    assert candidate(1) == 9\n    assert candidate(8) == 64\n    assert candidate(4) == 32\n    assert candidate(5) == 45\n\n","canonical_solution":"def simple_multiplication(number) :\n    return number * 9 if number % 2 else number * 8"}
{"task_id":3711,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function xMasTree(height) that returns a christmas tree of the correct height. The height is passed through to the function and the function should return a list containing each line of the tree. \n```\nxMasTree(5) should return : ['____#____', '___###___', '__#####__', '_#######_', '#########', '____#____', '____#____']\nxMasTree(3) should return : ['__#__', '_###_', '#####', '__#__', '__#__']\n```\nThe final idea is for the tree to look like this if you decide to print each element of the list: \n``` \nxMasTree(5) will result in:\n____#____              1\n___###___              2\n__#####__              3\n_#######_              4\n#########       -----> 5 - Height of Tree\n____#____        1      \n____#____        2 - Trunk\/Stem of Tree\n\nxMasTree(3) will result in:\n__#__                  1\n_###_                  2\n#####          ----->  3 - Height of Tree\n__#__           1\n__#__           2 - Trunk\/Stem of Tree\n```\nPad with underscores i.e _ so each line is the same length. The last line forming the tree having only hashtags, no spaces. Also remember the trunk\/stem of the tree.\n\"\"\"\n\n# ====== Solution ======\n\ndef xMasTree(n):\n","entry_point":"xMasTree","test":"def check(candidate):\n    assert candidate(3) == ['__#__', '_###_', '#####', '__#__', '__#__']\n    assert candidate(7) == ['______#______', '_____###_____', '____#####____', '___#######___', '__#########__', '_###########_', '#############', '______#______', '______#______']\n    assert candidate(2) == ['_#_', '###', '_#_', '_#_']\n    assert candidate(4) == ['___#___', '__###__', '_#####_', '#######', '___#___', '___#___']\n    assert candidate(6) == ['_____#_____', '____###____', '___#####___', '__#######__', '_#########_', '###########', '_____#_____', '_____#_____']\n\n","canonical_solution":"def xMasTree(n):\n   return [(\"#\"*(x*2+1)).center(n*2-1, \"_\") for x in list(range(n))+[0]*2]"}
{"task_id":3712,"prompt":"\"\"\"\n=====Problem statement====\n\n## Task\n\nYour challenge is to write a function named `getSlope`\/`get_slope`\/`GetSlope` that calculates the slope of the line through two points.\n\n## Input\n\n```if:javascript,python\nEach point that the function takes in is an array 2 elements long. The first number is the x coordinate and the second number is the y coordinate.\nIf the line through the two points is vertical or if the same point is given twice, the function should return `null`\/`None`.\n```\n\n```if:csharp\n`GetSlope` will take in two Point objects. If the line through the two points is vertical, or the two points are the same, return `null`.\n\nThe Point object:\n\n~~~\npublic class Point : System.Object\n{\n  public double X;\n  public double Y;\n  \n  public Point(double x, double y)\n  {\n    this.X = x;\n    this.Y = y;\n  }\n  \n  public override string ToString()\n  {\n    return $\"({this.X}, {this.Y})\";\n  }\n  \n  public override bool Equals(object point)\n  {\n    \/\/ Typechecking\n    if (point == null || point.GetType() != this.GetType())\n    {\n      return false;\n    }\n    \n    return this.ToString() == point.ToString();\n  }\n}\n~~~\n\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef getSlope(p1, p2):\n","entry_point":"getSlope","test":"def check(candidate):\n    assert candidate([1, 1],[2, 2]) == 1\n    assert candidate([-5, -5],[9, 9]) == 1\n    assert candidate([1, 8],[2, 9]) == 1\n    assert candidate([8, 3],[-4, 5]) == -0.16666666666666666\n    assert candidate([5, 3],[8, 9]) == 2\n    assert candidate([1, 3],[0, 3]) == 0\n    assert candidate([11, 1],[1, 11]) == -1\n    assert candidate([1, 1],[1, 2]) == None\n    assert candidate([-5, 9],[-5, 12]) == None\n    assert candidate([1, 1],[1, 1]) == None\n    assert candidate([-5, 9],[-5, 9]) == None\n\n","canonical_solution":"def getSlope(p1, p2):\n    return None if p1[0] == p2[0] else (p2[1] - p1[1])\/(p2[0] - p1[0])\n"}
{"task_id":3715,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n The sequence of `Chando` is an infinite sequence of all Chando's numbers in ascending order.\n\n A number is called `Chando's` if it is an integer that can be represented as a sum of different positive integer powers of 5.\n\n The first Chando's numbers is 5 (5^1). And the following nth Chando's numbers are:\n ```\n 25  (5^2)\n 30  (5^1 + 5^2)\n 125 (5^3)\n 130 (5^1 + 5^3)\n 150 (5^2 + 5^3)\n ...\n ...\n ```\n\n Your task is to find the Chando's nth number for a given `n`.\n\n# Input\/Output\n\n\n - `[input]` integer `n`\n\n  `1 <= n <= 7000`\n\n\n - `[output]` an integer\n\n  nth Chando's number\n\"\"\"\n\n# ====== Solution ======\n\ndef nth_chandos_number(n):\n","entry_point":"nth_chandos_number","test":"def check(candidate):\n    assert candidate(1) == 5\n    assert candidate(2) == 25\n    assert candidate(9) == 630\n    assert candidate(123) == 97530\n    assert candidate(23) == 3280\n\n","canonical_solution":"def nth_chandos_number(n):\n    return int((bin(n)+\"0\")[2:], 5)"}
{"task_id":3717,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a list of white pawns on a chessboard (any number of them, meaning from 0 to 64 and with the possibility to be positioned everywhere), determine how many of them have their backs covered by another. \nPawns attacking upwards since we have only white ones.\n\nPlease remember that a pawn attack(and defend as well) only the 2 square on the sides in front of him. https:\/\/en.wikipedia.org\/wiki\/Pawn_(chess)#\/media\/File:Pawn_(chess)_movements.gif\n\nThis is how the chess board coordinates are defined:\nABCDEFGH8\u265c\u265e\u265d\u265b\u265a\u265d\u265e\u265c7\u265f\u265f\u265f\u265f\u265f\u265f\u265f\u265f65432\u2659\u2659\u2659\u2659\u2659\u2659\u2659\u26591\u2656\u2658\u2657\u2655\u2654\u2657\u2658\u2656\n\"\"\"\n\n# ====== Solution ======\n\ndef covered_pawns(pawns):\n","entry_point":"covered_pawns","test":"def check(candidate):\n    assert candidate(['f7', 'b1', 'h1', 'c7', 'h7']) == 0\n    assert candidate(['e5', 'b2', 'b4', 'g4', 'a1', 'a5']) == 2\n    assert candidate(['a2', 'b1', 'c2']) == 2\n    assert candidate(['a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'g1', 'g2', 'g3', 'g4', 'g5', 'g6', 'g7', 'g8', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'h7', 'h8']) == 56\n    assert candidate([]) == 0\n\n","canonical_solution":"def covered_pawns(pawns):\n    pawns = set(pawns)\n    return len({p for p in pawns for x,y in [map(ord, p)] if {chr(x-1)+chr(y-1), chr(x+1)+chr(y-1)} & pawns})"}
{"task_id":3719,"prompt":"\"\"\"\n=====Problem statement====\n\nFor a pole vaulter, it is very important to begin the approach run at the best possible starting mark. This is affected by numerous factors and requires fine-tuning in practice. But there is a guideline that will help a beginning vaulter start at approximately the right location for the so-called \"three-step approach,\" based on the vaulter's body height.\n\nThis guideline was taught to me in feet and inches, but due to the international nature of Codewars, I am creating this kata to use metric units instead.\n\nYou are given the following two guidelines to begin with:\n(1) A vaulter with a height of 1.52 meters should start at 9.45 meters on the runway.\n(2) A vaulter with a height of 1.83 meters should start at 10.67 meters on the runway.\n\nYou will receive a vaulter's height in meters (which will always lie in a range between a minimum of 1.22 meters and a maximum of 2.13 meters). Your job is to return the best starting mark in meters, rounded to two decimal places.\n\nHint: Based on the two guidelines given above, you will want to account for the change in starting mark per change in body height. This involves a linear relationship. But there is also a constant offset involved. If you can determine the rate of change described above, you should be able to determine that constant offset.\n\"\"\"\n\n# ====== Solution ======\n\ndef starting_mark(height):\n","entry_point":"starting_mark","test":"def check(candidate):\n    assert candidate(1.52) == 9.45\n    assert candidate(1.83) == 10.67\n    assert candidate(1.22) == 8.27\n    assert candidate(2.13) == 11.85\n    assert candidate(1.75) == 10.36\n\n","canonical_solution":"def starting_mark(height):\n    return round(9.45 + (10.67 - 9.45) \/ (1.83 - 1.52) * (height - 1.52), 2)"}
{"task_id":3722,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function that returns the average of an array of numbers (\"scores\"), rounded to the nearest whole number. You are not allowed to use any loops (including for, for\/in, while, and do\/while loops).\n\"\"\"\n\n# ====== Solution ======\n\ndef average(array):\n","entry_point":"average","test":"def check(candidate):\n    assert candidate([5, 78, 52, 900, 1]) == 207\n    assert candidate([5, 25, 50, 75]) == 39\n    assert candidate([2]) == 2\n    assert candidate([1, 1, 1, 1, 9999]) == 2001\n    assert candidate([0]) == 0\n\n","canonical_solution":"def average(array):\n    return round(sum(array) \/ len(array))"}
{"task_id":3724,"prompt":"\"\"\"\n=====Problem statement====\n\nA hero is on his way to the castle to complete his mission. However, he's been told that the castle is surrounded with a couple of powerful dragons! each dragon takes 2 bullets to be defeated, our hero has no idea how many bullets he should carry.. Assuming he's gonna grab a specific given number of bullets and move forward to fight another specific given number of dragons, will he survive?\n\nReturn True if yes, False otherwise :)\n\"\"\"\n\n# ====== Solution ======\n\ndef hero(bullets, dragons):\n","entry_point":"hero","test":"def check(candidate):\n    assert candidate(10,5) == True\n    assert candidate(7,4) == False\n    assert candidate(4,5) == False\n    assert candidate(100,40) == True\n    assert candidate(1500,751) == False\n    assert candidate(0,1) == False\n\n","canonical_solution":"def hero(bullets, dragons):\n    return bullets >= dragons * 2"}
{"task_id":3728,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite function describeList which returns \"empty\" if the list is empty or \"singleton\" if it contains only one element or \"longer\"\" if more.\n\"\"\"\n\n# ====== Solution ======\n\ndef describeList(lst):\n","entry_point":"describeList","test":"def check(candidate):\n    assert candidate([]) == 'empty'\n    assert candidate([1]) == 'singleton'\n    assert candidate([1, 2, 5, 4]) == 'longer'\n    assert candidate(['one']) == 'singleton'\n    assert candidate(['one', 'two']) == 'longer'\n    assert candidate([[1, 2]]) == 'singleton'\n\n","canonical_solution":"def describeList(lst):\n    return [\"empty\",\"singleton\",\"longer\"][min(len(lst),2)]"}
{"task_id":3732,"prompt":"\"\"\"\n=====Problem statement====\n\nA Madhav array has the following property:\n\n```a[0] = a[1] + a[2] = a[3] + a[4] + a[5] = a[6] + a[7] + a[8] + a[9] = ...```\n\nComplete the function\/method that returns `true` if the given array is a Madhav array, otherwise it returns `false`.\n\n*Edge cases: An array of length* `0` *or* `1` *should not be considered a Madhav array as there is nothing to compare.*\n\"\"\"\n\n# ====== Solution ======\n\ndef is_madhav_array(arr):\n","entry_point":"is_madhav_array","test":"def check(candidate):\n    assert candidate([6, 2, 4, 2, 2, 2, 1, 5, 0, 0]) == True\n    assert candidate([6, 2, 4, 2, 2, 2, 1, 5, 0, -100]) == False\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, -2, -1]) == True\n    assert candidate([-6, -3, -3, 8, -5, -4]) == False\n    assert candidate([-6, -3, -3, 8, -10, -4]) == True\n    assert candidate([3, 1, 2, 3, 0]) == False\n    assert candidate([3, 3]) == False\n    assert candidate([]) == False\n    assert candidate([1]) == False\n    assert candidate([5, 2, 4, 1, 0, 3]) == False\n    assert candidate([6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 6]) == True\n    assert candidate([6, 2, 4, 2, 2, 2, 1, 5, 0, 0, -12, 13, -5, 4, 1]) == False\n    assert candidate([2, 1, 1]) == True\n    assert candidate([2, 1, 1, 4, -1, -1]) == True\n\n","canonical_solution":"def is_madhav_array(arr):\n    nTerms = ((1+8*len(arr))**.5-1)\/2\n    return (len(arr) > 1 and not nTerms%1 and\n            len({ sum(arr[int(i*(i+1)\/\/2):int(i*(i+1)\/\/2)+i+1]) for i in range(int(nTerms))}) == 1)"}
{"task_id":3735,"prompt":"\"\"\"\n=====Problem statement====\n\nYou will get an array of numbers. \n\nEvery preceding number is smaller than the one following it.\n\nSome numbers will be missing, for instance:\n```\n[-3,-2,1,5] \/\/missing numbers are: -1,0,2,3,4\n```\nYour task is to return an array of those missing numbers:\n```\n[-1,0,2,3,4]\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef find_missing_numbers(arr):\n","entry_point":"find_missing_numbers","test":"def check(candidate):\n    assert candidate([-3, -2, 1, 4]) == [-1, 0, 2, 3]\n    assert candidate([-1, 0, 1, 2, 3, 4]) == []\n    assert candidate([]) == []\n    assert candidate([0]) == []\n    assert candidate([-4, 4]) == [-3, -2, -1, 0, 1, 2, 3]\n\n","canonical_solution":"def find_missing_numbers(arr):\n    if not arr:\n        return []\n    return sorted(set(range(arr[0] + 1, arr[-1])).difference(arr))\n"}
{"task_id":3740,"prompt":"\"\"\"\n=====Problem statement====\n\n###Instructions\n\nA time period starting from ```'hh:mm'``` lasting until ```'hh:mm'``` is stored in an array:\n```\n['08:14', '11:34']\n```\nA set of different time periods is then stored in a 2D Array like so, each in its own sub-array:\n```\n[['08:14','11:34'], ['08:16','08:18'], ['22:18','01:14'], ['09:30','10:32'], ['04:23','05:11'], ['11:48','13:48'], ['01:12','01:14'], ['01:13','08:15']]\n```\nWrite a function that will take a 2D Array like the above as argument and return a 2D Array of the argument's sub-arrays sorted in ascending order.\n\nTake note of the following:\n\n* The first time period starts at the earliest time  possible ```('00:00'+)```.\n* The next time period is the one that starts the soonest **after** the prior time period finishes. If several time periods begin at the same hour, pick the first one showing up in the original array.\n* The next time period can start the same time the last one finishes.\n\nThis:\n```\n[['08:14','11:34'], ['08:16','08:18'], ['13:48','01:14'], ['09:30','10:32'], ['04:23','05:11'], ['11:48','13:48'], ['01:12','01:14'], ['01:13','08:15']]\n```\nShould return:\n```\n[['01:12','01:14'], ['04:23','05:11'], ['08:14','11:34'], ['11:48','13:48'], ['13:48','01:14'], ['08:16','08:18'], ['09:30','10:32'], ['01:13','08:15']]\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef sort_time(arr):\n","entry_point":"sort_time","test":"def check(candidate):\n    assert candidate([['08:14', '11:34'], ['08:16', '08:18'], ['13:48', '01:14'], ['09:30', '10:32'], ['04:23', '05:11'], ['11:48', '13:48'], ['01:12', '01:14'], ['01:13', '08:15']]) == [['01:12', '01:14'], ['04:23', '05:11'], ['08:14', '11:34'], ['11:48', '13:48'], ['13:48', '01:14'], ['08:16', '08:18'], ['09:30', '10:32'], ['01:13', '08:15']]\n    assert candidate([['00:00', '00:05'], ['16:37', '18:19'], ['12:07', '12:12'], ['00:30', '02:49'], ['12:12', '12:14'], ['12:14', '15:00'], ['15:00', '19:32']]) == [['00:00', '00:05'], ['00:30', '02:49'], ['12:07', '12:12'], ['12:12', '12:14'], ['12:14', '15:00'], ['15:00', '19:32'], ['16:37', '18:19']]\n    assert candidate([['12:00', '10:01'], ['06:31', '14:23'], ['03:02', '07:58'], ['08:13', '10:05'], ['18:37', '04:22'], ['12:58', '14:28'], ['01:51', '14:40'], ['04:27', '01:00'], ['22:56', '23:33'], ['19:23', '07:00'], ['02:13', '16:14'], ['10:40', '02:36'], ['11:49', '00:10']]) == [['01:51', '14:40'], ['18:37', '04:22'], ['04:27', '01:00'], ['02:13', '16:14'], ['19:23', '07:00'], ['08:13', '10:05'], ['10:40', '02:36'], ['03:02', '07:58'], ['11:49', '00:10'], ['06:31', '14:23'], ['22:56', '23:33'], ['12:00', '10:01'], ['12:58', '14:28']]\n    assert candidate([['07:05', '01:22'], ['07:40', '07:39'], ['17:35', '15:16'], ['21:33', '11:22'], ['02:58', '17:50'], ['18:43', '13:14'], ['18:15', '11:02'], ['12:42', '10:06'], ['00:26', '02:12']]) == [['00:26', '02:12'], ['02:58', '17:50'], ['18:15', '11:02'], ['12:42', '10:06'], ['17:35', '15:16'], ['18:43', '13:14'], ['21:33', '11:22'], ['07:05', '01:22'], ['07:40', '07:39']]\n    assert candidate([['17:29', '06:34'], ['00:46', '15:02'], ['04:59', '22:28'], ['22:16', '21:53'], ['08:44', '00:57']]) == [['00:46', '15:02'], ['17:29', '06:34'], ['08:44', '00:57'], ['04:59', '22:28'], ['22:16', '21:53']]\n    assert candidate([['13:40', '00:19'], ['11:09', '13:58'], ['06:50', '14:51'], ['00:15', '00:02'], ['19:18', '08:32'], ['03:19', '12:49'], ['18:16', '05:57'], ['14:27', '02:50'], ['01:11', '12:24']]) == [['00:15', '00:02'], ['01:11', '12:24'], ['13:40', '00:19'], ['03:19', '12:49'], ['14:27', '02:50'], ['06:50', '14:51'], ['18:16', '05:57'], ['11:09', '13:58'], ['19:18', '08:32']]\n    assert candidate([['06:10', '04:38'], ['11:23', '08:13'], ['14:15', '01:21'], ['23:15', '23:27'], ['16:01', '12:16'], ['07:24', '19:36'], ['16:16', '03:07']]) == [['06:10', '04:38'], ['07:24', '19:36'], ['23:15', '23:27'], ['11:23', '08:13'], ['14:15', '01:21'], ['16:01', '12:16'], ['16:16', '03:07']]\n    assert candidate([['07:41', '07:02'], ['02:47', '11:37'], ['16:04', '12:52'], ['03:55', '09:03'], ['00:16', '20:48'], ['02:44', '14:11'], ['23:12', '12:22'], ['22:29', '05:37'], ['18:22', '12:27'], ['17:44', '01:02'], ['03:15', '03:42']]) == [['00:16', '20:48'], ['22:29', '05:37'], ['07:41', '07:02'], ['16:04', '12:52'], ['17:44', '01:02'], ['02:44', '14:11'], ['18:22', '12:27'], ['23:12', '12:22'], ['02:47', '11:37'], ['03:15', '03:42'], ['03:55', '09:03']]\n    assert candidate([['11:33', '18:09'], ['02:10', '08:51'], ['01:56', '18:22'], ['06:16', '21:38'], ['12:24', '19:01'], ['23:09', '20:42'], ['20:39', '09:01'], ['13:13', '06:13'], ['04:40', '12:01']]) == [['01:56', '18:22'], ['20:39', '09:01'], ['11:33', '18:09'], ['23:09', '20:42'], ['02:10', '08:51'], ['12:24', '19:01'], ['04:40', '12:01'], ['13:13', '06:13'], ['06:16', '21:38']]\n    assert candidate([['08:15', '19:22'], ['08:35', '00:16'], ['19:37', '08:24'], ['18:33', '08:26'], ['20:17', '05:56'], ['23:45', '18:08'], ['02:52', '13:29']]) == [['02:52', '13:29'], ['18:33', '08:26'], ['08:35', '00:16'], ['08:15', '19:22'], ['19:37', '08:24'], ['20:17', '05:56'], ['23:45', '18:08']]\n\n","canonical_solution":"def sort_time(arr):\n    arr, s = sorted(arr, key=lambda t: t[0]), []\n    while arr:\n        nextTP = next((i for i,t in enumerate(arr) if not s or t[0] >= s[-1][1]), 0)\n        s.append(arr.pop(nextTP))\n    return s"}
{"task_id":3743,"prompt":"\"\"\"\n=====Problem statement====\n\nA grid is a perfect starting point for many games (Chess, battleships, Candy Crush!).\n\nMaking a digital chessboard I think is an interesting way of visualising how loops can work together.\n\nYour task is to write a function that takes two integers `rows` and `columns` and returns a chessboard pattern as a two dimensional array.\n\nSo `chessBoard(6,4)` should return an array like this:\n\n\n    [\n            [\"O\",\"X\",\"O\",\"X\"],\n            [\"X\",\"O\",\"X\",\"O\"],\n            [\"O\",\"X\",\"O\",\"X\"],\n            [\"X\",\"O\",\"X\",\"O\"],\n            [\"O\",\"X\",\"O\",\"X\"],\n            [\"X\",\"O\",\"X\",\"O\"]\n    ]\n\nAnd `chessBoard(3,7)` should return this:\n\n\n    [\n        [\"O\",\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"],\n        [\"X\",\"O\",\"X\",\"O\",\"X\",\"O\",\"X\"],\n        [\"O\",\"X\",\"O\",\"X\",\"O\",\"X\",\"O\"]\n    ]\n\nThe white spaces should be represented by an: `'O'`\n\nand the black an: `'X'`\n\nThe first row should always start with a white space `'O'`\n\"\"\"\n\n# ====== Solution ======\n\ndef chess_board(rows, columns):\n","entry_point":"chess_board","test":"def check(candidate):\n    assert candidate(1,1) == [['O']]\n    assert candidate(1,2) == [['O', 'X']]\n    assert candidate(2,1) == [['O'], ['X']]\n    assert candidate(2,2) == [['O', 'X'], ['X', 'O']]\n    assert candidate(6,6) == [['O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O'], ['O', 'X', 'O', 'X', 'O', 'X'], ['X', 'O', 'X', 'O', 'X', 'O']]\n\n","canonical_solution":"def chess_board(rows, columns):\n    return [[\"OX\"[(row+col)%2] for col in range(columns)] for row in range(rows)]"}
{"task_id":3753,"prompt":"\"\"\"\n=====Problem statement====\n\n```if-not:swift\nWrite simple .camelCase method (`camel_case` function in PHP, `CamelCase` in C# or `camelCase` in Java) for strings. All words must have their first letter capitalized without spaces.\n```\n```if:swift\nWrite a simple `camelCase` function for strings. All words must have their first letter capitalized and all spaces removed.\n```\nFor instance:\n\n```python\ncamelcase(\"hello case\") => HelloCase\ncamelcase(\"camel case word\") => CamelCaseWord\n```\n```c#\nusing Kata;\n\n\"hello case\".CamelCase(); \/\/ => \"HelloCase\"\n\"camel case word\".CamelCase(); \/\/ => \"CamelCaseWord\"\n```\n\nDon't forget to rate this kata! Thanks :)\n\"\"\"\n\n# ====== Solution ======\n\ndef camel_case(string):\n","entry_point":"camel_case","test":"def check(candidate):\n    assert candidate('test case') == 'TestCase'\n    assert candidate('camel case method') == 'CamelCaseMethod'\n    assert candidate('say hello ') == 'SayHello'\n    assert candidate(' camel case word') == 'CamelCaseWord'\n    assert candidate('') == ''\n\n","canonical_solution":"def camel_case(string):\n    return string.title().replace(\" \", \"\")"}
{"task_id":3765,"prompt":"\"\"\"\n=====Problem statement====\n\nAlgorithmic predicament - Bug Fixing #9\n\nOh no! Timmy's algorithim has gone wrong! help Timmy fix his algorithim! \n\nTask\nYour task is to fix timmy's algorithim so it returns the group name with the highest total age. \n\nYou will receive two groups of `people` objects, with two properties `name` and `age`. The name property is a string and the age property is a number.  \nYour goal is to make the total the age of all people having the same name through both groups and return the name of the one with the highest age. If two names have the same total age return the first alphabetical name.\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import Counter\nfrom itertools import chain\n\n\ndef highest_age(persons1, persons2):\n","entry_point":"highest_age","test":"def check(candidate):\n    assert candidate([{'name': 'kay', 'age': 1}, {'name': 'john', 'age': 13}, {'name': 'kay', 'age': 76}],[{'name': 'john', 'age': 1}, {'name': 'alice', 'age': 77}]) == 'alice'\n    assert candidate([{'name': 'kay', 'age': 1}, {'name': 'john', 'age': 13}, {'name': 'kay', 'age': 76}],[{'name': 'john', 'age': 1}, {'name': 'alice', 'age': 76}]) == 'kay'\n    assert candidate([{'name': 'kay', 'age': 1}, {'name': 'john', 'age': 130}, {'name': 'kay', 'age': 76}],[{'name': 'john', 'age': 1}, {'name': 'alice', 'age': 76}]) == 'john'\n    assert candidate([{'name': 'kay', 'age': 1}, {'name': 'john', 'age': 130}, {'name': 'kay', 'age': 130}],[{'name': 'john', 'age': 1}, {'name': 'alice', 'age': 76}]) == 'john'\n    assert candidate([{'name': 'kay', 'age': 2}, {'name': 'john', 'age': 130}, {'name': 'kay', 'age': 130}],[{'name': 'john', 'age': 1}, {'name': 'alice', 'age': 76}]) == 'kay'\n\n","canonical_solution":"from collections import Counter\nfrom itertools import chain\n\n\ndef highest_age(persons1, persons2):\n    c = Counter()\n\n    for p in chain(persons1, persons2):\n        c[p['name']] += p['age']\n\n    return min(iter(c.items()), key=lambda n_a: (-n_a[1], n_a[0]))[0] if c else None\n"}
{"task_id":3766,"prompt":"\"\"\"\n=====Problem statement====\n\n~~~if-not:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getUniquePrimeFactorsWithProducts** an array containing the prime factors to their respective powers. \n\nexemple: `getUniquePrimeFactorsWithProducts(100)` returns `[4,25]`\n~~~\n~~~if:java\nYou have to code a function **getAllPrimeFactors** wich take an integer as parameter and return an array containing its prime decomposition by ascending factors, if a factors appears multiple time in the decomposition it should appear as many time in the array. \n\nexemple: `getAllPrimeFactors(100)` returns `[2,2,5,5]` in this order. \n\nThis decomposition may not be the most practical. \n\nYou should also write **getUniquePrimeFactorsWithCount**, a function which will return an array containing two arrays: one with prime numbers appearing in the decomposition and the other containing their respective power. \n\nexemple: `getUniquePrimeFactorsWithCount(100)` returns `[[2,5],[2,2]]`\n\nYou should also write **getPrimeFactorPotencies** an array containing the prime factors to their respective powers. \n\nexemple: `getPrimeFactorPotencies(100)` returns `[4,25]`\n~~~\n\nErrors, if:\n\n* `n` is not a number\n* `n` not an integer \n* `n` is negative or 0 \n\nThe three functions should respectively return `[]`,  `[[],[]]` and `[]`. \n\nEdge cases: \n\n* if `n=0`, the function should respectively return `[]`, `[[],[]]` and  `[]`.\n* if `n=1`, the function should respectively return `[1]`, `[[1],[1]]`, `[1]`.\n* if `n=2`, the function should respectively return `[2]`, `[[2],[1]]`, `[2]`.\n\nThe result for `n=2` is normal. The result for `n=1` is arbitrary and has been chosen to return a usefull result. The result for `n=0` is also arbitrary \nbut can not be chosen to be both usefull and intuitive. (`[[0],[0]]` would be meaningfull but wont work for general use of decomposition, `[[0],[1]]` would work but is not intuitive.)\n\"\"\"\n\n# ====== Solution ======\n\ndef getAllPrimeFactors(n):\n","entry_point":"getAllPrimeFactors","test":"def check(candidate):\n    assert candidate(10) == [2, 5]\n    assert candidate(100) == [2, 2, 5, 5]\n    assert candidate(1000) == [2, 2, 2, 5, 5, 5]\n    assert candidate(1000001) == [101, 9901]\n    assert candidate(0) == []\n    assert candidate(1) == [1]\n    assert candidate(2) == [2]\n    assert candidate('a') == []\n    assert candidate(1.1) == []\n    assert candidate(-1) == []\n\n","canonical_solution":"def getAllPrimeFactors(n):\n    if n == 0: return []\n    elif n == 1: return [1]\n    elif type(n) != int: return errora\n    elif n < 0: return errora\n    allfacts = []\n    current = 2\n    n_copy = n\n    while current <= n:\n        if n_copy % current == 0:\n            allfacts.append(current)\n            n_copy \/= current\n        else:\n            current += 1\n    return allfacts\n    \n    \ndef getUniquePrimeFactorsWithCount(n):\n    if type(n) != int: return errorb\n    elif n < 0: return errorb\n    primes = []\n    power = []\n    listA = getAllPrimeFactors(n)\n    for i in range(len(listA)):\n        if listA[i] not in primes:\n            primes.append(listA[i])\n            power.append(1)\n        else:\n            power[-1] += 1\n    return [primes, power]\n\ndef getUniquePrimeFactorsWithProducts(n):\n    if type(n) != int: return errorc\n    elif n < 0: return errorc\n    listlist = getUniquePrimeFactorsWithCount(n)\n    listc = []\n    for i in range(len(listlist[0])):\n        listc.append(listlist[0][i] ** listlist[1][i])\n    return listc\n\nerrora = []\nerrorb = [[], []]\nerrorc = []"}
{"task_id":3770,"prompt":"\"\"\"\n=====Problem statement====\n\nHello! Your are given x and y and 2D array size tuple (width, height) and you have to:\nCalculate the according index in 1D space (zero-based). \nDo reverse operation.\n\nImplement:\nto_1D(x, y, size):\n  --returns index in 1D space\nto_2D(n, size)\n  --returns x and y in 2D space\n\n1D array: [0, 1, 2, 3, 4, 5, 6, 7, 8]\n2D array: [[0 -> (0,0), 1 -> (1,0), 2 -> (2,0)], \n           [3 -> (0,1), 4 -> (1,1), 5 -> (2,1)], \n           [6 -> (0,2), 7 -> (1,2), 8 -> (2,2)]]\n\n\nto_1D(0, 0, (3,3)) returns 0\nto_1D(1, 1, (3,3)) returns 4\nto_1D(2, 2, (3,3)) returns 8\nto_2D(5, (3,3)) returns (2,1)\nto_2D(3, (3,3)) returns (0,1)\n\nAssume all input are valid:\n\n1 < width  < 500; \n1 < height < 500\n\"\"\"\n\n# ====== Solution ======\n\ndef to_1D(x, y, size):\n","entry_point":"to_1D","test":"def check(candidate):\n    assert candidate(0,0,[3, 3]) == 0\n    assert candidate(1,1,[3, 3]) == 4\n    assert candidate(2,2,[3, 3]) == 8\n    assert candidate(0,0,[1, 1]) == 0\n    assert candidate(1,5,[4, 6]) == 21\n    assert candidate(2,3,[4, 6]) == 14\n\n","canonical_solution":"def to_1D(x, y, size):\n    return y * size[0] + x    \n    \ndef to_2D(n, size):\n    return (n % size[0], n \/\/ size[0])"}
{"task_id":3771,"prompt":"\"\"\"\n=====Problem statement====\n\nCongratulations! That Special Someone has given you their phone number.\n\nBut WAIT, is it a valid number? \n\nYour task is to write a function that verifies whether a given string contains a valid British mobile (cell) phone number or not. \n\nIf valid, return 'In with a chance'.\n\nIf invalid, or if you're given an empty string, return 'Plenty more fish in the sea'.\n\nA number can be valid in the following ways: \n\nHere in the UK mobile numbers begin with '07' followed by 9 other digits, e.g. '07454876120'.\n\nSometimes the number is preceded by the country code, the prefix '+44', which replaces the '0' in \u201807\u2019, e.g. '+447454876120'.\n\nAnd sometimes you will find numbers with dashes in-between digits or on either side, e.g. '+44--745---487-6120' or '-074-54-87-61-20-'. As you can see, dashes may be consecutive. \n\nGood Luck Romeo\/Juliette!\n\"\"\"\n\n# ====== Solution ======\n\nimport re\nyes = \"In with a chance\"\nno = \"Plenty more fish in the sea\"\ndef validate_number(string):\n","entry_point":"validate_number","test":"def check(candidate):\n    assert candidate('07454876120') == 'In with a chance'\n    assert candidate('0754876120') == 'Plenty more fish in the sea'\n    assert candidate('0745--487-61-20') == 'In with a chance'\n    assert candidate('+447535514555') == 'In with a chance'\n    assert candidate('-07599-51-4555') == 'In with a chance'\n    assert candidate('075335440555') == 'Plenty more fish in the sea'\n    assert candidate('+337535512555') == 'Plenty more fish in the sea'\n    assert candidate('00535514555') == 'Plenty more fish in the sea'\n    assert candidate('+447+4435512555') == 'Plenty more fish in the sea'\n    assert candidate('+44') == 'Plenty more fish in the sea'\n\n","canonical_solution":"import re\nyes = \"In with a chance\"\nno = \"Plenty more fish in the sea\"\ndef validate_number(string):\n  return yes if re.match(r'^(\\+44|0)7[\\d]{9}$',re.sub('-','',string)) else no"}
{"task_id":3781,"prompt":"\"\"\"\n=====Problem statement====\n\nYou should have done Product Partitions I to do this second part.\nIf you solved it, you should have notice that we try to obtain the multiplicative partitions with ```n \u2264 100 ```.\n\nIn this kata we will have more challenging values, our ```n \u2264  10000```. So, we need a more optimized a faster code.\n\nWe need the function ```prod_int_partII()``` that will give all the amount of different products, excepting the number itself multiplied by one.\n\nThe function ```prod_int_partII()``` will receive two arguments, the number ```n``` for the one we have to obtain all the multiplicative partitions, and an integer s that determines the products that have an amount of factors equals to ```s```.\n\nThe function will output a list with this structure:\n```python\n[(1), (2), [(3)]]\n\n(1) Total amount of different products we can obtain, using the factors of n. (We do not consider the product n . 1)\n\n(2) Total amount of products that have an amount of factors equals to s.\n\n[(3)] A list of lists with each product represented with by a sorted list of the factors. All the product- lists should be sorted also.\nIf we have only one product-list as a result, the function will give only the list \nand will not use the list of lists\n```\nLet's see some cases:\n```python\nprod_int_partII(36, 3) == [8, 3, [[2, 2, 9], [2, 3, 6], [3, 3, 4]]]\n\n\/\/\/ (1) ----> 8 # Amount of different products, they are: [2, 2, 3, 3], [2, 2, 9], \n[2, 3, 6], [2, 18], [3, 3, 4], [3, 12], [4, 9], [6, 6] (8 products)\n    \n    (2) ----> 3 # Amount of products with three factors (see them bellow)\n\n    (3) ----> [[2, 2, 9], [2, 3, 6], [3, 3, 4]] # These are the products with 3 factors\n```\n```python\nprod_int_partII(48, 5) == [11, 1, [2, 2, 2, 2, 3]] # Only one list.\n```\nAgain consider that some numbers will not have multiplicative partitions.\n```python\nprod_int_partII(37, 2) == [0, 0, []]\n```\nHappy coding!!\n\n(Recursion is advisable)\n\"\"\"\n\n# ====== Solution ======\n\ndef prod_int_partII(n, s, min_=2):\n","entry_point":"prod_int_partII","test":"def check(candidate):\n    assert candidate(36,3) == [8, 3, [[2, 2, 9], [2, 3, 6], [3, 3, 4]]]\n    assert candidate(48,5) == [11, 1, [2, 2, 2, 2, 3]]\n    assert candidate(37,2) == [0, 0, []]\n    assert candidate(96,5) == [18, 2, [[2, 2, 2, 2, 6], [2, 2, 2, 3, 4]]]\n    assert candidate(96,6) == [18, 1, [2, 2, 2, 2, 2, 3]]\n\n","canonical_solution":"def prod_int_partII(n, s, min_=2):\n    total, fac = 0, []\n    for d in range(min_, int(n ** .5) + 1):\n        if not n % d:\n            count, l, sub = prod_int_partII(n \/\/ d, s-1, d)\n            if l == 1: sub = [sub]\n            total += count + 1\n            fac.extend([d] + x for x in sub)\n    if s == 1: fac = [[n]]\n    return [total, len(fac), fac[0] if len(fac) == 1 else fac]"}
{"task_id":3785,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function that returns an array containing the first `l` digits from the `n`th diagonal of [Pascal's triangle](https:\/\/en.wikipedia.org\/wiki\/Pascal's_triangle).\n\n`n = 0` should generate the first diagonal of the triangle (the 'ones'). The first number in each diagonal should be 1.\n\nIf `l = 0`, return an empty array. Assume that both `n` and `l` will be non-negative integers in all test cases.\n\"\"\"\n\n# ====== Solution ======\n\ndef generate_diagonal(d, l):\n","entry_point":"generate_diagonal","test":"def check(candidate):\n    assert candidate(0,10) == [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n    assert candidate(1,10) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    assert candidate(2,10) == [1, 3, 6, 10, 15, 21, 28, 36, 45, 55]\n    assert candidate(3,10) == [1, 4, 10, 20, 35, 56, 84, 120, 165, 220]\n    assert candidate(4,10) == [1, 5, 15, 35, 70, 126, 210, 330, 495, 715]\n    assert candidate(10,0) == []\n    assert candidate(100,6) == [1, 101, 5151, 176851, 4598126, 96560646]\n\n","canonical_solution":"def generate_diagonal(d, l):\n    result = [1] if l else []\n    for k in range(1, l):\n        result.append(result[-1] * (d+k) \/\/ k)\n    return result"}
{"task_id":3786,"prompt":"\"\"\"\n=====Problem statement====\n\n# Do you ever wish you could talk like Siegfried of KAOS ?\n\n## YES, of course you do!\n\nhttps:\/\/en.wikipedia.org\/wiki\/Get_Smart\n\n\n\n# Task\n\nWrite the function ```siegfried``` to replace the letters of a given sentence.\n\nApply the rules using the course notes below. Each week you will learn some more rules.\n\nUnd by ze fifz vek yu vil be speakink viz un aksent lik Siegfried viz no trubl at al!\n\n\n# Lessons\n\n## Week 1\n\n* ```ci``` -> ```si```\n* ```ce``` -> ```se```\n* ```c``` -> ```k``` (except ```ch``` leave alone)\n\n## Week 2\n\n* ```ph``` -> ```f```\n\n## Week 3\n\n* remove trailing ```e``` (except for all 2 and 3 letter words)\n* replace double letters with single letters (e.g. ```tt``` -> ```t```)\n\n## Week 4\n\n* ```th``` -> ```z```\n* ```wr``` -> ```r```\n* ```wh``` -> ```v```\n* ```w``` -> ```v```\n\n## Week 5\n\n* ```ou``` -> ```u```\n* ```an``` -> ```un```\n* ```ing``` -> ```ink``` (but only when ending words)\n* ```sm``` -> ```schm``` (but only when beginning words)\n\n\n\n# Notes\n\n* You must retain the case of the original sentence\n* Apply rules strictly in the order given above\n* Rules are cummulative. So for week 3 first apply week 1 rules, then week 2 rules, then week 3 rules\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\nPATTERNS = [re.compile(r'(?i)ci|ce|c(?!h)'),\n            re.compile(r'(?i)ph'),\n            re.compile(r'(?i)(?<!\\b[a-z]{1})(?<!\\b[a-z]{2})e\\b|([a-z])\\1'),\n            re.compile(r'(?i)th|w[rh]?'),\n            re.compile(r'(?i)ou|an|ing\\b|\\bsm')]\n            \nCHANGES  = {\"ci\": \"si\", \"ce\": \"se\", \"c\":\"k\",                     # Week 1\n            \"ph\": \"f\",                                           # Week 2\n            \"th\": \"z\",  \"wr\": \"r\",  \"wh\":  \"v\",   \"w\": \"v\",      # Week 4\n            \"ou\": \"u\",  \"an\": \"un\", \"ing\": \"ink\", \"sm\": \"schm\"}  # Week 5\n\ndef change(m):\n    tok = m.group(0)\n    rep = CHANGES.get( tok.lower(), \"\" if None in m.groups() else m.group()[0] )        # default value used for week 3 only\n    if tok[0].isupper(): rep = rep.title()\n    return rep\n        \ndef siegfried(week, txt):\n","entry_point":"siegfried","test":"def check(candidate):\n    assert candidate(1,'City civilians') == 'Sity sivilians'\n    assert candidate(1,'Centre receiver') == 'Sentre reseiver'\n    assert candidate(1,'Chatanooga choo choo crashed') == 'Chatanooga choo choo krashed'\n    assert candidate(1,'Capital city cats chew cheese') == 'Kapital sity kats chew cheese'\n    assert candidate(2,'Photo of 5 pheasants with graphs') == 'Foto of 5 feasants with grafs'\n    assert candidate(3,'Meet me at the same place at noon') == 'Met me at the sam plas at non'\n    assert candidate(3,'The time is now') == 'The tim is now'\n    assert candidate(3,'Be quite quiet') == 'Be quit quiet'\n    assert candidate(3,'Aardvarks are nice most of the time') == 'Ardvarks are nis most of the tim'\n    assert candidate(5,'And another thing Mr Smart, I want no more trouble!') == 'Und unozer zink Mr Schmart, I vunt no mor trubl!'\n    assert candidate(5,'You ought to behave yourself Smart!') == 'Yu ught to behav yurself Schmart!'\n    assert candidate(5,'Smart and 99 were husband and wife') == 'Schmart und 99 ver husbund und vif'\n    assert candidate(5,'.. Mr Maxwell be The Smart ..') == '.. Mr Maxvel be Ze Schmart ..'\n    assert candidate(5,'.. Mr Maxwell be We Smart ..') == '.. Mr Maxvel be Ve Schmart ..'\n    assert candidate(5,'Be be The the We we Me me She she') == 'Be be Ze ze Ve ve Me me She she'\n    assert candidate(5,'be Be the The we We me Me she She') == 'be Be ze Ze ve Ve me Me she She'\n    assert candidate(5,'be the wee me') == 'be ze ve me'\n    assert candidate(5,'be we Maxwell be We bee wee') == 'be ve Maxvel be Ve be ve'\n    assert candidate(5,'Be like Me') == 'Be lik Me'\n    assert candidate(5,'be the same') == 'be ze sam'\n    assert candidate(5,'The same bee we see') == 'Ze sam be ve se'\n    assert candidate(5,'It was an inglorious ending') == 'It vas un inglorius endink'\n\n","canonical_solution":"import re\n\nPATTERNS = [re.compile(r'(?i)ci|ce|c(?!h)'),\n            re.compile(r'(?i)ph'),\n            re.compile(r'(?i)(?<!\\b[a-z]{1})(?<!\\b[a-z]{2})e\\b|([a-z])\\1'),\n            re.compile(r'(?i)th|w[rh]?'),\n            re.compile(r'(?i)ou|an|ing\\b|\\bsm')]\n            \nCHANGES  = {\"ci\": \"si\", \"ce\": \"se\", \"c\":\"k\",                     # Week 1\n            \"ph\": \"f\",                                           # Week 2\n            \"th\": \"z\",  \"wr\": \"r\",  \"wh\":  \"v\",   \"w\": \"v\",      # Week 4\n            \"ou\": \"u\",  \"an\": \"un\", \"ing\": \"ink\", \"sm\": \"schm\"}  # Week 5\n\ndef change(m):\n    tok = m.group(0)\n    rep = CHANGES.get( tok.lower(), \"\" if None in m.groups() else m.group()[0] )        # default value used for week 3 only\n    if tok[0].isupper(): rep = rep.title()\n    return rep\n        \ndef siegfried(week, txt):\n    for n in range(week):\n        txt = PATTERNS[n].sub(change, txt)\n    return txt"}
{"task_id":3801,"prompt":"\"\"\"\n=====Problem statement====\n\nIf\u3000`a = 1, b = 2, c = 3 ... z = 26`\n\nThen `l + o + v + e = 54`\n\nand `f + r + i + e + n + d + s + h + i + p = 108`\n\nSo `friendship` is twice stronger than `love` :-)\n\nThe input will always be in lowercase and never be empty.\n\"\"\"\n\n# ====== Solution ======\n\ndef words_to_marks(s):\n","entry_point":"words_to_marks","test":"def check(candidate):\n    assert candidate('attitude') == 100\n    assert candidate('friends') == 75\n    assert candidate('family') == 66\n    assert candidate('selfness') == 99\n    assert candidate('knowledge') == 96\n\n","canonical_solution":"def words_to_marks(s):\n  return sum(ord(c)-96 for c in s)"}
{"task_id":3814,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a time in AM\/PM format as a string, convert it to military (24-hour) time as a string.\n\nMidnight is 12:00:00AM on a 12-hour clock, and 00:00:00 on a 24-hour clock. Noon is 12:00:00PM on a 12-hour clock, and 12:00:00 on a 24-hour clock\n\n\nSample Input: 07:05:45PM\nSample Output: 19:05:45\n\nTry not to use built in DateTime libraries.\n\nFor more information on military time, check the wiki https:\/\/en.wikipedia.org\/wiki\/24-hour_clock#Military_time\n\"\"\"\n\n# ====== Solution ======\n\ndef get_military_time(time):\n","entry_point":"get_military_time","test":"def check(candidate):\n    assert candidate('12:00:01AM') == '00:00:01'\n    assert candidate('01:02:03AM') == '01:02:03'\n    assert candidate('02:04:05AM') == '02:04:05'\n    assert candidate('03:06:07AM') == '03:06:07'\n    assert candidate('04:08:09AM') == '04:08:09'\n    assert candidate('05:10:11AM') == '05:10:11'\n    assert candidate('06:12:13AM') == '06:12:13'\n    assert candidate('07:14:15AM') == '07:14:15'\n    assert candidate('08:16:17AM') == '08:16:17'\n    assert candidate('09:18:19AM') == '09:18:19'\n    assert candidate('10:20:21AM') == '10:20:21'\n    assert candidate('11:22:23AM') == '11:22:23'\n    assert candidate('12:24:25PM') == '12:24:25'\n    assert candidate('01:26:27PM') == '13:26:27'\n    assert candidate('02:28:29PM') == '14:28:29'\n    assert candidate('03:30:31PM') == '15:30:31'\n    assert candidate('04:32:33PM') == '16:32:33'\n    assert candidate('05:34:35PM') == '17:34:35'\n    assert candidate('06:36:37PM') == '18:36:37'\n    assert candidate('07:38:39PM') == '19:38:39'\n    assert candidate('08:40:41PM') == '20:40:41'\n    assert candidate('09:42:43PM') == '21:42:43'\n    assert candidate('10:44:45PM') == '22:44:45'\n    assert candidate('11:46:47PM') == '23:46:47'\n\n","canonical_solution":"def get_military_time(time):\n    if time[-2:] == 'AM':\n        hour = '00' if time[0:2] == '12' else time[0:2]\n    else:\n        hour = '12' if time[0:2] == '12' else str(int(time[0:2])+12)\n    return hour + time[2:-2]"}
{"task_id":3816,"prompt":"\"\"\"\n=====Problem statement====\n\nMove every letter in the provided string forward 10 letters through the alphabet.\n\nIf it goes past 'z', start again at 'a'.\n\nInput will be a string with length > 0.\n\"\"\"\n\n# ====== Solution ======\n\nfrom string import ascii_lowercase as al\n\ntbl = str.maketrans(al, al[10:] + al[:10])\ndef move_ten(st):\n","entry_point":"move_ten","test":"def check(candidate):\n    assert candidate('testcase') == 'docdmkco'\n    assert candidate('codewars') == 'mynogkbc'\n    assert candidate('exampletesthere') == 'ohkwzvodocdrobo'\n    assert candidate('returnofthespacecamel') == 'bodebxypdroczkmomkwov'\n    assert candidate('bringonthebootcamp') == 'lbsxqyxdrolyydmkwz'\n    assert candidate('weneedanofficedog') == 'goxoonkxyppsmonyq'\n\n","canonical_solution":"from string import ascii_lowercase as al\n\ntbl = str.maketrans(al, al[10:] + al[:10])\ndef move_ten(st):\n    return st.translate(tbl)"}
{"task_id":3822,"prompt":"\"\"\"\n=====Problem statement====\n\nFor a given array whose element values are randomly picked from single-digit integers `0` to `9`, return an array with the same digit order but all `0`'s paired. Paring two `0`'s generates one `0` at the location of the first.\n\nEx:\n```python\npair_zeros([0, 1, 0, 2])\n# paired: ^-----^ cull second zero\n       == [0, 1, 2];\n#   kept: ^\n\npair_zeros([0, 1, 0, 0])\n# paired: ^-----^\n       == [0, 1,    0];\n#   kept: ^\n\npair_zeros([1, 0, 7, 0, 1])\n# paired:    ^-----^\n       == [1, 0, 7,    1];\n#   kept:    ^\n\npair_zeros([0, 1, 7, 0, 2, 2, 0, 0, 1, 0])\n# paired: ^--------^ \n#        [0, 1, 7,    2, 2, 0, 0, 1, 0]\n#   kept: ^         paired: ^--^\n       == [0, 1, 7,    2, 2, 0,    1, 0];\n#   kept:                   ^\n```\n\nHere are the 2 important rules:\n\n1. Pairing happens from left to right in the array. However, for each pairing, the \"second\" `0` will always be paired towards the first (right to left)\n2. `0`'s generated by pairing can NOT be paired again\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import count\ndef pair_zeros(arr, *args):\n","entry_point":"pair_zeros","test":"def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1]) == [1]\n    assert candidate([1, 2, 3]) == [1, 2, 3]\n    assert candidate([0]) == [0]\n    assert candidate([0, 0]) == [0]\n    assert candidate([1, 0, 1, 0, 2, 0, 0]) == [1, 0, 1, 2, 0]\n    assert candidate([0, 0, 0]) == [0, 0]\n    assert candidate([1, 0, 1, 0, 2, 0, 0, 3, 0]) == [1, 0, 1, 2, 0, 3, 0]\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0]\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == [0, 0, 0, 0, 0, 0, 0]\n\n","canonical_solution":"from itertools import count\ndef pair_zeros(arr, *args):\n    c = count(1)\n    return [elem for elem in arr if elem != 0 or next(c) % 2]"}
{"task_id":3827,"prompt":"\"\"\"\n=====Problem statement====\n\nBelow is a right-angled triangle:\n\n```\n  |\\\n  | \\\n  |  \\\n  |   \\ \no |    \\ h \n  |     \\\n  |    \u03b8 \\\n  |_______\\ \n     a\n```\n\nYour challange is to write a function (```missingAngle``` in C\/C#, ```missing_angle``` in Ruby), that calculates the angle \u03b8 in degrees to the nearest integer. You will be given three arguments representing each side: o, h and a. One of the arguments equals zero. Use the length of the two other sides to calculate \u03b8. You will not be expected to handle any erronous data in your solution.\n\"\"\"\n\n# ====== Solution ======\n\nimport math\n\ndef missing_angle(h, a, o):\n","entry_point":"missing_angle","test":"def check(candidate):\n    assert candidate(0,400,300) == 37\n    assert candidate(5,4,0) == 37\n    assert candidate(8,0,5) == 39\n    assert candidate(16.7,0,12.3) == 47\n    assert candidate(7,5,0) == 44\n\n","canonical_solution":"import math\n\ndef missing_angle(h, a, o):\n    if h == 0:\n        radians = math.atan(o\/a)\n    elif a == 0:\n        radians = math.asin(o\/h)\n    else:\n        radians = math.acos(a\/h)\n    return round(math.degrees(radians))"}
{"task_id":3844,"prompt":"\"\"\"\n=====Problem statement====\n\n*** Nova polynomial from roots*** \n\nThis kata is from a series on polynomial handling. ( [#1](http:\/\/www.codewars.com\/kata\/nova-polynomial-1-add-1)   [#2](http:\/\/www.codewars.com\/kata\/570eb07e127ad107270005fe)  [#3](http:\/\/www.codewars.com\/kata\/5714041e8807940ff3001140 )   [#4](http:\/\/www.codewars.com\/kata\/571a2e2df24bdfd4e20001f5))\n\nConsider a polynomial in a list where each element in the list element corresponds to the factors. The factor order is the position in the list. The first element is the zero order factor (the constant).\n\np = [a0, a1, a2, a3] signifies the polynomial a0 + a1x + a2x^2 + a3*x^3\n\nIn this kata create the polynomial from a list of roots:\n\n[r0, r1 ,r2, r3 ]\n\np = (x-r0)(x-r1)(x-r2)(x-r3)\n\nnote: no roots should return the identity polynomial.\n\n```python \npoly_from_roots([4]) = [-4, 1]\npoly_from_roots([0, 0, 0, 0] ) = [0, 0, 0, 0, 1]\npoly_from_roots([]) = [1]\n```\nThe first katas of this series is preloaded in the code and can be used: [poly_add](http:\/\/www.codewars.com\/kata\/570eb07e127ad107270005fe) [poly_multiply](http:\/\/www.codewars.com\/kata\/570eb07e127ad107270005fe)\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"poly_from_roots","test":"def check(candidate):\n    assert candidate([4]) == [-4, 1]\n    assert candidate([0, 0, 0, 0]) == [0, 0, 0, 0, 1]\n    assert candidate([1, 1, 1, 1]) == [1, -4, 6, -4, 1]\n    assert candidate([-1, 1, 2, -2]) == [4, 0, -5, 0, 1]\n    assert candidate([]) == [1]\n\n","canonical_solution":"import numpy\n\ndef poly_from_roots(r): return list(reversed(numpy.poly(tuple(r)))) if len(r)>0 else [1]"}
{"task_id":3845,"prompt":"\"\"\"\n=====Problem statement====\n\nCalculate the product of all elements in an array.\n```if:csharp\nIf the array is *null*, you should throw `ArgumentNullException` and if the array is empty, you should throw `InvalidOperationException`.\n\nAs a challenge, try writing your method in just one line of code. It's possible to have only 36 characters within your method.\n```\n```if:javascript\nIf the array is `null` or is empty, the function should return `null`.\n```\n```if:haskell\nIf the array is empty then return Nothing, else return Just product.\n```\n```if:php\nIf the array is `NULL` or empty, return `NULL`.\n```\n```if:python\nIf the array is empty or `None`, return `None`.\n```\n```if:ruby\nIf the array is `nil` or is empty, the function should return `nil`.\n```\n```if:crystal\nIf the array is `nil` or is empty, the function should return `nil`.\n```\n```if:groovy\nIf the array is `null` or `empty` return `null`.\n```\n```if:julia\nIf the input is `nothing` or an empty array, return `nothing`\n```\n\"\"\"\n\n# ====== Solution ======\n\nfrom functools import reduce\nfrom operator import mul\n\n\ndef product(numbers):\n","entry_point":"product","test":"def check(candidate):\n    assert candidate([5, 4, 1, 3, 9]) == 540\n    assert candidate([-2, 6, 7, 8]) == -672\n    assert candidate([10]) == 10\n    assert candidate([0, 2, 9, 7]) == 0\n    assert candidate(None) == None\n    assert candidate([]) == None\n\n","canonical_solution":"from functools import reduce\nfrom operator import mul\n\n\ndef product(numbers):\n    return reduce(mul, numbers) if numbers else None"}
{"task_id":3856,"prompt":"\"\"\"\n=====Problem statement====\n\nThe prime number sequence starts with: `2,3,5,7,11,13,17,19...`. Notice that `2` is in position `one`. \n\n`3` occupies position `two`, which is a prime-numbered position. Similarly, `5`, `11` and `17` also occupy prime-numbered positions. We shall call primes such as `3,5,11,17` dominant primes because they occupy prime-numbered positions in the prime number sequence. Let's call this `listA`. \n\nAs you can see from listA, for the prime range `range(0,10)`, there are `only two` dominant primes (`3` and `5`) and the sum of these primes is: `3 + 5 = 8`. \n\nSimilarly, as shown in listA, in the `range (6,20)`, the dominant primes in this range are `11` and `17`, with a sum of `28`.\n\nGiven a `range (a,b)`, what is the sum of dominant primes within that range? Note that  `a <= range <= b` and `b` will not exceed `500000`.\n\nGood luck!\n\nIf you like this Kata, you will enjoy:\n\n[Simple Prime Streaming](https:\/\/www.codewars.com\/kata\/5a908da30025e995880000e3)\n\n[Sum of prime-indexed elements](https:\/\/www.codewars.com\/kata\/59f38b033640ce9fc700015b)\n\n[Divisor harmony](https:\/\/www.codewars.com\/kata\/59bf97cd4f98a8b1cd00007e)\n\"\"\"\n\n# ====== Solution ======\n\nn = 500000\nsieve, PRIMES = [0]*(n\/\/2+1), [0,2]\nfor i in range(3, n+1, 2):\n    if not sieve[i\/\/2]:\n        PRIMES.append(i)\n        for j in range(i**2, n+1, i*2): sieve[j\/\/2] = 1\n\nDOMINANTS = []\nfor p in PRIMES:\n    if p >= len(PRIMES): break\n    DOMINANTS.append(PRIMES[p])\n\ndef solve(a,b):\n","entry_point":"solve","test":"def check(candidate):\n    assert candidate(0,10) == 8\n    assert candidate(2,200) == 1080\n    assert candidate(200,2000) == 48132\n    assert candidate(500,10000) == 847039\n    assert candidate(1000,100000) == 52114889\n    assert candidate(2000,200000) == 183035206\n    assert candidate(3000,400000) == 650120994\n    assert candidate(4000,500000) == 972664400\n\n","canonical_solution":"n = 500000\nsieve, PRIMES = [0]*(n\/\/2+1), [0,2]\nfor i in range(3, n+1, 2):\n    if not sieve[i\/\/2]:\n        PRIMES.append(i)\n        for j in range(i**2, n+1, i*2): sieve[j\/\/2] = 1\n\nDOMINANTS = []\nfor p in PRIMES:\n    if p >= len(PRIMES): break\n    DOMINANTS.append(PRIMES[p])\n\ndef solve(a,b):\n    return sum(p for p in DOMINANTS if a <= p <= b)"}
{"task_id":3857,"prompt":"\"\"\"\n=====Problem statement====\n\n###BACKGROUND:\nJacob recently decided to get healthy and lose some weight. He did a lot of reading and research and after focusing on steady exercise and a healthy diet for several months, was able to shed over 50 pounds! Now he wants to share his success, and has decided to tell his friends and family how much weight they could expect to lose if they used the same plan he followed.\n\nLots of people are really excited about Jacob's program and they want to know how much weight they would lose if they followed his plan. Unfortunately, he's really bad at math, so he's turned to you to help write a program that will calculate the expected weight loss for a particular person, given their weight and how long they think they want to continue the plan.\n\n###TECHNICAL DETAILS:\nJacob's weight loss protocol, if followed closely, yields loss according to a simple formulae, depending on gender. Men can expect to lose 1.5% of their current body weight each week they stay on plan. Women can expect to lose 1.2%. (Children are advised to eat whatever they want, and make sure to play outside as much as they can!)\n\n###TASK:\nWrite a function that takes as input:\n```\n- The person's gender ('M' or 'F');\n- Their current weight (in pounds);\n- How long they want to stay true to the protocol (in weeks);\n```\nand then returns the expected weight at the end of the program.\n\n###NOTES:\nWeights (both input and output) should be decimals, rounded to the nearest tenth.\nDuration (input) should be a whole number (integer). If it is not, the function should round to the nearest whole number.\nWhen doing input parameter validity checks, evaluate them in order or your code will not pass final tests.\n\"\"\"\n\n# ====== Solution ======\n\ndef lose_weight(gender, weight, duration):\n","entry_point":"lose_weight","test":"def check(candidate):\n    assert candidate('K',200,10) == 'Invalid gender'\n    assert candidate('M',0,10) == 'Invalid weight'\n    assert candidate('M',-5,10) == 'Invalid weight'\n    assert candidate('F',160,0) == 'Invalid duration'\n    assert candidate('F',160,-10) == 'Invalid duration'\n    assert candidate(',',0,1100) == 'Invalid gender'\n    assert candidate('??',-10,-10) == 'Invalid gender'\n    assert candidate('llama',1,-10) == 'Invalid gender'\n    assert candidate('F',-461.9,0.0) == 'Invalid weight'\n    assert candidate('M',250,5) == 231.8\n    assert candidate('F',190,8) == 172.5\n    assert candidate('M',405,12) == 337.8\n    assert candidate('F',130,7) == 119.5\n\n","canonical_solution":"def lose_weight(gender, weight, duration):\n    if not gender in ['M', 'F']: return 'Invalid gender'\n    if weight <= 0: return 'Invalid weight'\n    if duration <= 0: return 'Invalid duration'\n    \n    nl = 0.985 if gender == 'M' else 0.988\n    \n    for i in range(duration): weight *= nl\n    return round(weight, 1)"}
{"task_id":3879,"prompt":"\"\"\"\n=====Problem statement====\n\nYou love coffee and want to know what beans you can afford to buy it.\n\nThe first argument to your search function will be a number which represents your budget.\n\nThe second argument will be an array of coffee bean prices.\n\nYour 'search' function should return the stores that sell coffee within your budget. \n\nThe search function should return a string of prices for the coffees beans you can afford. The prices in this string are to be sorted in ascending order.\n\"\"\"\n\n# ====== Solution ======\n\ndef search(budget, prices):\n","entry_point":"search","test":"def check(candidate):\n    assert candidate(3,[6, 1, 2, 9, 2]) == '1,2,2'\n    assert candidate(14,[7, 3, 23, 9, 14, 20, 7]) == '3,7,7,9,14'\n    assert candidate(0,[6, 1, 2, 9, 2]) == ''\n    assert candidate(10,[]) == ''\n    assert candidate(24,[24, 0, 100, 2, 5]) == '0,2,5,24'\n    assert candidate(24,[2.7, 0, 100.9, 1, 5.5]) == '0,1,2.7,5.5'\n    assert candidate(-1,[1, 2, 3, 4]) == ''\n    assert candidate(-1,[-1, 0, 1, 2, 3, 4]) == '-1'\n    assert candidate(14,[17, 33, 23, 19, 19, 20, 17]) == ''\n    assert candidate(14,[13, 15, 14, 14, 15, 13]) == '13,13,14,14'\n\n","canonical_solution":"def search(budget, prices):\n    return ','.join(str(a) for a in sorted(prices) if a <= budget)\n"}
{"task_id":3886,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this Kata, you will be given an integer array and your task is to return the sum of elements occupying prime-numbered indices. \n\n~~~if-not:fortran\nThe first element of the array is at index `0`.\n~~~\n\n~~~if:fortran\nThe first element of an array is at index `1`.\n~~~\n\n\nGood luck! \n\nIf you like this Kata, try:\n\n[Dominant primes](https:\/\/www.codewars.com\/kata\/59ce11ea9f0cbc8a390000ed). It takes this idea a step further.\n\n[Consonant value](https:\/\/www.codewars.com\/kata\/59c633e7dcc4053512000073)\n\"\"\"\n\n# ====== Solution ======\n\ndef is_prime(n):\n    return n >= 2 and all(n%i for i in range(2, 1+int(n**.5)))\n    \ndef total(arr):\n","entry_point":"total","test":"def check(candidate):\n    assert candidate([]) == 0\n    assert candidate([1, 2, 3, 4]) == 7\n    assert candidate([1, 2, 3, 4, 5, 6]) == 13\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8]) == 21\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == 21\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]) == 33\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) == 47\n\n","canonical_solution":"def is_prime(n):\n    return n >= 2 and all(n%i for i in range(2, 1+int(n**.5)))\n    \ndef total(arr):\n    return sum(n for i, n in enumerate(arr) if is_prime(i))"}
{"task_id":3891,"prompt":"\"\"\"\n=====Problem statement====\n\nThe new \u00a35 notes have been recently released in the UK and they've certainly became a sensation! Even those of us who haven't been carrying any cash around for a while, having given in to the convenience of cards, suddenly like to have some of these in their purses and pockets. But how many of them could you get with what's left from your salary after paying all bills? The programme that you're about to write will count this for you!\n\nGiven a salary and the array of bills, calculate your disposable income for a month and return it as a number of new \u00a35 notes you can get with that amount. If the money you've got (or do not!) doesn't allow you to get any \u00a35 notes return 0.\n\n\u00a3\u00a3\u00a3 GOOD LUCK! \u00a3\u00a3\u00a3\n\"\"\"\n\n# ====== Solution ======\n\ndef get_new_notes(salary, bills):\n","entry_point":"get_new_notes","test":"def check(candidate):\n    assert candidate(2000,[500, 160, 400]) == 188\n    assert candidate(1260,[500, 50, 100]) == 122\n    assert candidate(3600,[1800, 350, 460, 500, 15]) == 95\n    assert candidate(1995,[1500, 19, 44]) == 86\n    assert candidate(10000,[1800, 500, 1200, 655, 150]) == 1139\n    assert candidate(2300,[590, 1500, 45, 655, 150]) == 0\n    assert candidate(5300,[1190, 1010, 1045, 55, 10, 19, 55]) == 383\n    assert candidate(2000,[500, 495, 100, 900]) == 1\n    assert candidate(2000,[500, 496, 100, 900]) == 0\n    assert candidate(2000,[500, 494, 100, 900]) == 1\n\n","canonical_solution":"def get_new_notes(salary, bills):\n    return max((salary - sum(bills)), 0) \/\/ 5"}
{"task_id":3896,"prompt":"\"\"\"\n=====Problem statement====\n\nIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.\n\nFinish the solution so that it returns the sum of all the multiples of 3 or 5 **below** the number passed in. \n\n> Note: If the number is a multiple of **both** 3 and 5, only count it *once*.\n> Also, if a number is negative, return 0(for languages that do have them)\n  \n###### *Courtesy of projecteuler.net*\n\"\"\"\n\n# ====== Solution ======\n\ndef solution(number):\n","entry_point":"solution","test":"def check(candidate):\n    assert candidate(10) == 23\n    assert candidate(20) == 78\n    assert candidate(0) == 0\n    assert candidate(1) == 0\n    assert candidate(200) == 9168\n\n","canonical_solution":"def solution(number):\n    return sum(x for x in range(number) if x % 3 == 0 or x % 5 == 0)\n"}
{"task_id":3899,"prompt":"\"\"\"\n=====Problem statement====\n\nYour Goal is to create a function that takes  two strings, a guess and a phone number. \n\nBased on the guess, the function should display a portion of the phone number:\n\n    guess_my_number('052', '123-451-2345')\n    would return the string: '#2#-#5#-2##5'\n    \n    or\n    \n    guess_my_number('142', '123-451-2345')\n    would return the string: '12#-4#1-2#4#'\n    \nOrder of the guess string should not matter, and should not have duplicates of the ten digitis 0-9. Guess will never be an empty string or contains any other charachters. The phone number will always bea ten digit number in the format ###-###-####.\n\nThe default number of 123-451-2345 should be included, but can be overwriten by a different number if supplied at the time of execution.\n\"\"\"\n\n# ====== Solution ======\n\ndef guess_my_number(guess, number = '123-451-2345'):\n","entry_point":"guess_my_number","test":"def check(candidate):\n    assert candidate('0') == '###-###-####'\n    assert candidate('01') == '1##-##1-####'\n    assert candidate('012') == '12#-##1-2###'\n    assert candidate('0123') == '123-##1-23##'\n    assert candidate('01234') == '123-4#1-234#'\n    assert candidate('012345') == '123-451-2345'\n\n","canonical_solution":"def guess_my_number(guess, number = '123-451-2345'):\n    return \"\".join(c if c in guess+\"-\" else \"#\" for c in number)\n"}
{"task_id":3901,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this Kata, you will be given a ```number```, two indexes (```index1``` and ```index2```) and a ```digit``` to look for. Your task will be to check if the ```digit``` exists in the ```number```, within the ```indexes``` given.\n\nBe careful, the ```index2``` is not necessarily more than the ```index1```.\n\n```\n  index1 == 2 and index2 == 5 -> snippet from 2 to 5 positons;\n  index1 == 5 and index2 == 2 -> snippet from 2 to 5 positons;\n\n  number.length = 14;\n  \n  0 <= index1 < 14;\n  \n  0 <= index2 < 14;\n  \n  index2 is inclusive in search snippet;\n  \n  0 <= digit <= 9;\n\n```\n\nFind more details below: \n\n```\n\n  checkDigit(12345678912345, 1, 0, 1) -> true, 1 exists in 12\n  \n  checkDigit(12345678912345, 0, 1, 2) -> true, 2 exists in 12\n  \n  checkDigit(67845123654000, 4, 2, 5) -> true, 4 exists in 845\n  \n  checkDigit(66688445364856, 0, 0, 6) -> true, 6 exists in 6\n  \n  checkDigit(87996599994565, 2, 5, 1) -> false, 1 doesn't exist in 9965\n  \n```\n\"\"\"\n\n# ====== Solution ======\n\ndef check_digit(n, idx1, idx2, digit):\n","entry_point":"check_digit","test":"def check(candidate):\n    assert candidate(1234567,1,0,1) == True\n    assert candidate(1234567,0,1,2) == True\n    assert candidate(67845123654,4,2,4) == True\n    assert candidate(6668844536485,0,0,6) == True\n    assert candidate(9999999999,2,5,1) == False\n\n","canonical_solution":"def check_digit(n, idx1, idx2, digit):\n    return str(digit) in str(n)[idx1:idx2+1] + str(n)[idx2:idx1+1]"}
{"task_id":3903,"prompt":"\"\"\"\n=====Problem statement====\n\nIn Russia, there is an army-purposed station named UVB-76 or \"Buzzer\" (see also https:\/\/en.wikipedia.org\/wiki\/UVB-76). Most of time specific \"buzz\" noise is being broadcasted, but on very rare occasions, the buzzer signal is interrupted and a voice transmission in Russian takes place. Transmitted messages have always the same format like this:\n\n MDZHB 01 213 SKIF 38 87 23 95 \n\nor: \n\n MDZHB 80 516 GANOMATIT 21 23 86 25 \n\nMessage format consists of following parts:\n\n Initial keyword \"MDZHB\"; \n Two groups of digits, 2 digits in first and 3 in second ones; \n Some keyword of arbitrary length consisting only of uppercase letters; \n Final 4 groups of digits with 2 digits in each group. \n\n  \nYour task is to write a function that can validate the correct UVB-76 message. Function should return \"True\" if message is in correct format and \"False\" otherwise.\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"validate","test":"def check(candidate):\n    assert candidate('Is this a right message?') == False\n    assert candidate('MDZHB 85 596 KLASA 81 00 02 91') == True\n    assert candidate('MDZHB 12 733 EDINENIE 67 79 66 32') == True\n    assert candidate('MDZHV 60 130 VATRUKH 58 89 54 54') == False\n    assert candidate('MDZHB 85 596 BRAMIRKA 81 00 02 91') == True\n    assert candidate('MDZHB 12 733 INITIAL 67 79 66 32') == True\n    assert candidate('MDZHB 60 130 KROLI5T 58 89 54 54') == False\n    assert candidate('MDZHB 85 596 KAMASIT 81 00 02 91') == True\n    assert candidate('MDZHB 12 733 PREGRADA 67 79 66 32') == True\n    assert candidate('MD2HB 60 1S0 AKKRETSIA 58 89 54 54') == False\n    assert candidate('Is this a wrong message?') == False\n    assert candidate('MDZHBMDZHB 855 56 KLASA 81 00 02 91') == False\n    assert candidate('MDZHB 12 733 EDIN ENIE 67 79 66 32') == False\n    assert candidate('MDZHB 60 130 FRONTAL 58 89 54 54') == True\n    assert candidate('MDZHB 85 596 PALEOLIT 81 12 52 91') == True\n    assert candidate('MDZHB 12 733 6INITIAL 67 79 66 32') == False\n    assert candidate('MDZHB 60 130 KRO-LIST 58 89 54 54') == False\n    assert candidate('MDZHB 85 596 MDZHB 81 00 02 9') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67 79 66 32') == True\n    assert candidate('MD2HB 60 120 AKKRETSIA 58895454') == False\n    assert candidate('MDZHB 102 733 BZHDM 67 79 66 32') == False\n    assert candidate('MDZHB 60 13 KROLIST 58 89 54 54') == False\n    assert candidate('MDZHB 85 596 MDZHB 81 00 02 99') == True\n    assert candidate('MDZHB 12 733 VOSKHOD 677 79 66 32') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67 793 66 32') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67 79 663 32') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67 79 66 322') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67793 66 32') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67 79') == False\n    assert candidate('MDZHB 12 733 VOSKHOD 67 79 66') == False\n\n","canonical_solution":"import re\nvalidate = lambda msg: bool(re.match('^MDZHB \\d\\d \\d\\d\\d [A-Z]+ \\d\\d \\d\\d \\d\\d \\d\\d$', msg))"}
{"task_id":3912,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array containing only integers, add all the elements and return the binary equivalent of that sum.\n\nIf the array contains any non-integer element (e.g. an object, a float, a string and so on), return false.\n\n**Note:** The sum of an empty array is zero.\n\n```python\narr2bin([1,2]) == '11'\narr2bin([1,2,'a']) == False\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef arr2bin(arr):\n","entry_point":"arr2bin","test":"def check(candidate):\n    assert candidate([1, 2]) == '11'\n    assert candidate([1, 2, 3, 4, 5]) == '1111'\n    assert candidate([1, 10, 100, 1000]) == '10001010111'\n    assert candidate([1, 2, -1, -2]) == '0'\n    assert candidate([1, 2, -1, -2, 1]) == '1'\n    assert candidate([]) == '0'\n\n","canonical_solution":"def arr2bin(arr):\n    for x in arr:\n        if(type(x) != int):\n            return False\n    return '{0:b}'.format(sum(arr))"}
{"task_id":3921,"prompt":"\"\"\"\n=====Problem statement====\n\nCorrect this code so that it takes one argument, `x`, and returns \"`x` is more than zero\" if `x` is positive (and nonzero), and otherwise, returns \"`x` is equal to or less than zero.\" In both cases, replace `x` with the actual value of `x`.\n\"\"\"\n\n# ====== Solution ======\n\ndef corrections(x):\n","entry_point":"corrections","test":"def check(candidate):\n    assert candidate(8) == '8 is more than zero.'\n    assert candidate(1) == '1 is more than zero.'\n    assert candidate(-2) == '-2 is equal to or less than zero.'\n    assert candidate(-1) == '-1 is equal to or less than zero.'\n    assert candidate(0) == '0 is equal to or less than zero.'\n\n","canonical_solution":"def corrections(x):\n    str = \"{0} is more than zero.\" if x > 0 else \"{0} is equal to or less than zero.\"\n    return str.format(x)"}
{"task_id":3928,"prompt":"\"\"\"\n=====Problem statement====\n\nYou can print your name on a billboard ad. Find out how much it will cost you. Each letter has a default price of \u00a330, but that can be different if you are given 2 parameters instead of 1.\n\nYou can not use multiplier \"*\" operator.\n\nIf your name would be Jeong-Ho Aristotelis, ad would cost \u00a3600.\n20 leters * 30 = 600 (Space counts as a letter).\n\"\"\"\n\n# ====== Solution ======\n\ndef billboard(name, price=30):\n","entry_point":"billboard","test":"def check(candidate):\n    assert candidate('Jeong-Ho Aristotelis') == 600\n    assert candidate('Abishai Charalampos') == 570\n    assert candidate('Idwal Augustin') == 420\n    assert candidate('Hadufuns John',20) == 260\n    assert candidate('Zoroaster Donnchadh') == 570\n    assert candidate('Claude Miljenko') == 450\n    assert candidate('Werner Vigi',15) == 165\n    assert candidate('Anani Fridumar') == 420\n    assert candidate('Paolo Oli') == 270\n    assert candidate('Hjalmar Liupold',40) == 600\n    assert candidate('Simon Eadwulf') == 390\n\n","canonical_solution":"def billboard(name, price=30):\n    return sum(price for letter in name)"}
{"task_id":3937,"prompt":"\"\"\"\n=====Problem statement====\n\nWe want to find the numbers higher or equal than 1000 that the sum of every four consecutives digits cannot be higher than a certain given value.\nIf the number is ``` num = d1d2d3d4d5d6 ```, and the maximum sum of 4 contiguous digits is ```maxSum```, then:\n```python\nd1 + d2 + d3 + d4 <= maxSum\nd2 + d3 + d4 + d5 <= maxSum\nd3 + d4 + d5 + d6 <= maxSum\n```\nFor that purpose, we need to create a function, ```max_sumDig()```, that receives ```nMax```, as the max value of the interval to study (the range (1000, nMax) ), and a certain value, ```maxSum```, the maximum sum that every four consecutive digits should be less or equal to. The function should output the following list with the data detailed bellow:\n\n```[(1), (2), (3)]```\n\n(1) - the amount of numbers that satisfy the constraint presented above \n\n(2) - the closest number to the mean of the results, if there are more than one, the smallest number should be chosen.\n\n(3) - the total sum of all the found numbers\n\nLet's see a case with all the details:\n```\nmax_sumDig(2000, 3) -------> [11, 1110, 12555]\n\n(1) -There are 11 found numbers: 1000, 1001, 1002, 1010, 1011, 1020, 1100, 1101, 1110, 1200 and 2000\n\n(2) - The mean of all the found numbers is:\n      (1000 + 1001 + 1002 + 1010 + 1011 + 1020 + 1100 + 1101 + 1110 + 1200 + 2000) \/11 = 1141.36363,  \n      so 1110 is the number that is closest to that mean value.\n\n(3) - 12555 is the sum of all the found numbers\n      1000 + 1001 + 1002 + 1010 + 1011 + 1020 + 1100 + 1101 + 1110 + 1200 + 2000 = 12555\n\nFinally, let's see another cases\n```\nmax_sumDig(2000, 4) -----> [21, 1120, 23665]\n\nmax_sumDig(2000, 7) -----> [85, 1200, 99986]\n\nmax_sumDig(3000, 7) -----> [141, 1600, 220756]\n```\n\nHappy coding!!\n\"\"\"\n\n# ====== Solution ======\n\ndef max_sumDig_aux(nmax, maxsm):\n    res, i = [], 1000\n    while (i <= nmax):\n        a = list(str(i))\n        j, b = 0, 0\n        while (j <= len(a) - 4):\n            if (sum(map(int, a[j:j+4])) <= maxsm):\n                b += 1\n            j += 1\n        if (b == j):\n            res.append(i)\n        i += 1\n    return res\n    \ndef max_sumDig(nmax, maxsm):\n","entry_point":"max_sumDig","test":"def check(candidate):\n    assert candidate(2000,3) == [11, 1110, 12555]\n    assert candidate(2000,4) == [21, 1120, 23665]\n    assert candidate(2000,7) == [85, 1200, 99986]\n    assert candidate(3000,7) == [141, 1600, 220756]\n    assert candidate(4000,4) == [35, 2000, 58331]\n    assert candidate(5000,2) == [5, 1100, 6111]\n    assert candidate(5000,3) == [15, 1200, 21666]\n    assert candidate(5000,4) == [35, 2000, 58331]\n    assert candidate(5000,5) == [70, 2000, 132216]\n    assert candidate(5000,6) == [122, 2010, 244875]\n    assert candidate(5000,7) == [196, 2110, 413306]\n    assert candidate(5000,8) == [296, 2200, 649951]\n    assert candidate(5000,9) == [426, 2250, 967696]\n\n","canonical_solution":"def max_sumDig_aux(nmax, maxsm):\n    res, i = [], 1000\n    while (i <= nmax):\n        a = list(str(i))\n        j, b = 0, 0\n        while (j <= len(a) - 4):\n            if (sum(map(int, a[j:j+4])) <= maxsm):\n                b += 1\n            j += 1\n        if (b == j):\n            res.append(i)\n        i += 1\n    return res\n    \ndef max_sumDig(nmax, maxsm):\n    res = max_sumDig_aux(nmax, maxsm)\n    l = len(res)\n    s = sum(res)\n    m = s \/ float(l)\n    d = list([(abs(x - m), x) for x in res])\n    d.sort()\n    return [l, d[0][1], s]\n"}
{"task_id":3942,"prompt":"\"\"\"\n=====Problem statement====\n\nThere is enough money available on ATM in nominal value 10, 20, 50, 100, 200 and 500 dollars.\n\nYou are given money in nominal value of `n` with `1<=n<=1500`.\n\nTry to find minimal number of notes that must be used to repay in dollars, or output -1 if it is impossible.\n\nGood Luck!!!\n\"\"\"\n\n# ====== Solution ======\n\ndef solve(n):\n","entry_point":"solve","test":"def check(candidate):\n    assert candidate(770) == 4\n    assert candidate(550) == 2\n    assert candidate(10) == 1\n    assert candidate(1250) == 4\n    assert candidate(125) == -1\n    assert candidate(666) == -1\n    assert candidate(42) == -1\n\n","canonical_solution":"def solve(n):\n    if n%10: return -1\n    c, billet = 0, iter((500,200,100,50,20,10))\n    while n:\n        x, r = divmod(n, next(billet))\n        c, n = c+x, r\n    return c"}
{"task_id":3944,"prompt":"\"\"\"\n=====Problem statement====\n\nYour task is to return the sum of Triangular Numbers up-to-and-including the `nth` Triangular Number.\n\nTriangular Number: \"any of the series of numbers (1, 3, 6, 10, 15, etc.) obtained by continued summation of the natural numbers 1, 2, 3, 4, 5, etc.\"\n\n```\n[01]\n02 [03]\n04 05 [06]\n07 08 09 [10]\n11 12 13 14 [15]\n16 17 18 19 20 [21]\n```\n\ne.g. If `4` is given: `1 + 3 + 6 + 10 = 20`.\n\nTriangular Numbers cannot be negative so return 0 if a negative number is given.\n\"\"\"\n\n# ====== Solution ======\n\ndef sum_triangular_numbers(n):\n","entry_point":"sum_triangular_numbers","test":"def check(candidate):\n    assert candidate(6) == 56\n    assert candidate(34) == 7140\n    assert candidate(-291) == 0\n    assert candidate(943) == 140205240\n    assert candidate(-971) == 0\n\n","canonical_solution":"def sum_triangular_numbers(n):\n    return n*(n+1)*(n+2)\/6 if n>0 else 0"}
{"task_id":3948,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array, return the reversed version of the array (a different kind of reverse though), you reverse portions of the array, you'll be given a length argument which represents the length of each portion you are to reverse.\n\nE.g\n  \n  if after reversing some portions of the array and the length of the remaining portion in the array is not up to the length argument, just reverse them.\n  \n\n`selReverse(array, length)`\n\n- array - array to reverse\n- length - length of each portion to reverse\n\nNote : if the length argument exceeds the array length, reverse all of them, if the length argument is zero do not reverse at all.\n\"\"\"\n\n# ====== Solution ======\n\ndef sel_reverse(arr,l):\n","entry_point":"sel_reverse","test":"def check(candidate):\n    assert candidate([2, 4, 6, 8, 10, 12, 14, 16],3) == [6, 4, 2, 12, 10, 8, 16, 14]\n    assert candidate([2, 4, 6, 8, 10, 12, 14, 16],2) == [4, 2, 8, 6, 12, 10, 16, 14]\n    assert candidate([1, 2, 3, 4, 5, 6],2) == [2, 1, 4, 3, 6, 5]\n    assert candidate([1, 2, 3, 4, 5, 6],0) == [1, 2, 3, 4, 5, 6]\n    assert candidate([1, 2, 3, 4, 5, 6],10) == [6, 5, 4, 3, 2, 1]\n\n","canonical_solution":"def sel_reverse(arr,l):\n    return [ elt for i in range(0, len(arr), l) for elt in arr[i:i+l][::-1] ] if l != 0 else arr"}
{"task_id":3949,"prompt":"\"\"\"\n=====Problem statement====\n\nComplete the function, which calculates how much you need to tip based on the total amount of the bill and the service. \n\nYou need to consider the following ratings:\n\n- Terrible: tip 0%\n- Poor: tip 5%\n- Good: tip 10%\n- Great: tip 15%\n- Excellent: tip 20%\n\nThe rating is **case insensitive** (so \"great\" = \"GREAT\"). If an unrecognised rating is received, then you need to return:\n\n* `\"Rating not recognised\"` in Javascript, Python and Ruby...\n* ...or `null` in Java\n* ...or `-1` in C#\n\nBecause you're a nice person, you **always round up** the tip, regardless of the service.\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil\ndef calculate_tip(amount, rating):\n","entry_point":"calculate_tip","test":"def check(candidate):\n    assert candidate(30,'poor') == 2\n    assert candidate(20,'Excellent') == 4\n    assert candidate(20,'hi') == 'Rating not recognised'\n    assert candidate(107.65,'GReat') == 17\n    assert candidate(20,'great!') == 'Rating not recognised'\n\n","canonical_solution":"from math import ceil\ndef calculate_tip(amount, rating):\n    tips = {\n        'terrible': 0,\n        'poor' : .05,\n        'good' : .1,\n        'great' : .15,\n        'excellent' : .2\n    }\n    if rating.lower() in tips:\n        return ceil(amount * tips[rating.lower()])\n    else:\n        return 'Rating not recognised'"}
{"task_id":3958,"prompt":"\"\"\"\n=====Problem statement====\n\nLeonardo Fibonacci in a rare portrait of his younger days\n\nI assume you are all familiar with the famous Fibonacci sequence, having to get each number as the sum of the previous two (and typically starting with either `[0,1]` or `[1,1]` as the first numbers).\n\nWhile there are plenty of variation on it ([including](https:\/\/www.codewars.com\/kata\/tribonacci-sequence) [a few](https:\/\/www.codewars.com\/kata\/fibonacci-tribonacci-and-friends) [I wrote](https:\/\/www.codewars.com\/kata\/triple-shiftian-numbers\/)), usually the catch is all the same: get a starting (signature) list of numbers, then proceed creating more with the given rules.\n\nWhat if you were to get to get two parameters, one with the signature (starting value) and the other with the number you need to sum at each iteration to obtain the next one?\n\nAnd there you have it, getting 3 parameters:\n\n* a signature of length `length`\n* a second parameter is a list\/array of indexes of the last `length` elements you need to use to obtain the next item in the sequence (consider you can end up not using a few or summing the same number multiple times)' in other words, if you get a signature of length `5` and `[1,4,2]` as indexes, at each iteration you generate the next number by summing the 2nd, 5th and 3rd element (the ones with indexes `[1,4,2]`) of the last 5 numbers\n* a third and final parameter is of course which sequence element you need to return (starting from zero, I don't want to bother you with adding\/removing 1s or just coping with the fact that after years on CodeWars we all count as computers do):\n\n```python\ncustom_fib([1,1],[0,1],2) == 2 #classical fibonacci!\ncustom_fib([1,1],[0,1],3) == 3 #classical fibonacci!\ncustom_fib([1,1],[0,1],4) == 5 #classical fibonacci!\ncustom_fib([3,5,2],[0,1,2],4) == 17 #similar to my Tribonacci\ncustom_fib([7,3,4,1],[1,1],6) == 2 #can you figure out how it worked ;)?\n```\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import deque\n\ndef custom_fib(signature, indexes, n):\n","entry_point":"custom_fib","test":"def check(candidate):\n    assert candidate([1, 1],[0, 1],2) == 2\n    assert candidate([1, 1],[0, 1],3) == 3\n    assert candidate([1, 1],[0, 1],4) == 5\n    assert candidate([3, 5, 2],[0, 1, 2],4) == 17\n    assert candidate([7, 3, 4, 1],[1, 1],6) == 2\n\n","canonical_solution":"from collections import deque\n\ndef custom_fib(signature, indexes, n):\n    fib = deque(signature)\n    for _ in range(n):\n        fib.append(sum(map(fib.__getitem__, indexes)))\n        fib.popleft()\n    return fib[0]"}
{"task_id":3970,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a triangle of consecutive odd numbers:\n\n```\n             1\n          3     5\n       7     9    11\n   13    15    17    19\n21    23    25    27    29\n...\n```\n\nfind the triangle's row knowing its index (the rows are 1-indexed), e.g.:\n\n```\nodd_row(1)  ==  [1]\nodd_row(2)  ==  [3, 5]\nodd_row(3)  ==  [7, 9, 11]\n```\n\n**Note**: your code should be optimized to handle big inputs.\n\n___\n\nThe idea for this kata was taken from this kata: [Sum of odd numbers](https:\/\/www.codewars.com\/kata\/sum-of-odd-numbers)\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"odd_row","test":"def check(candidate):\n    assert candidate(1) == [1]\n    assert candidate(2) == [3, 5]\n    assert candidate(13) == [157, 159, 161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181]\n    assert candidate(19) == [343, 345, 347, 349, 351, 353, 355, 357, 359, 361, 363, 365, 367, 369, 371, 373, 375, 377, 379]\n    assert candidate(41) == [1641, 1643, 1645, 1647, 1649, 1651, 1653, 1655, 1657, 1659, 1661, 1663, 1665, 1667, 1669, 1671, 1673, 1675, 1677, 1679, 1681, 1683, 1685, 1687, 1689, 1691, 1693, 1695, 1697, 1699, 1701, 1703, 1705, 1707, 1709, 1711, 1713, 1715, 1717, 1719, 1721]\n    assert candidate(93) == [8557, 8559, 8561, 8563, 8565, 8567, 8569, 8571, 8573, 8575, 8577, 8579, 8581, 8583, 8585, 8587, 8589, 8591, 8593, 8595, 8597, 8599, 8601, 8603, 8605, 8607, 8609, 8611, 8613, 8615, 8617, 8619, 8621, 8623, 8625, 8627, 8629, 8631, 8633, 8635, 8637, 8639, 8641, 8643, 8645, 8647, 8649, 8651, 8653, 8655, 8657, 8659, 8661, 8663, 8665, 8667, 8669, 8671, 8673, 8675, 8677, 8679, 8681, 8683, 8685, 8687, 8689, 8691, 8693, 8695, 8697, 8699, 8701, 8703, 8705, 8707, 8709, 8711, 8713, 8715, 8717, 8719, 8721, 8723, 8725, 8727, 8729, 8731, 8733, 8735, 8737, 8739, 8741]\n\n","canonical_solution":"odd_row = lambda n:list(range(n*(n-1)+1,n*(n+1),2))\n"}
{"task_id":3973,"prompt":"\"\"\"\n=====Problem statement====\n\nIt's pretty straightforward. Your goal is to create a function that removes the first and last characters of a string. You're given one parameter, the original string.  You don't have to worry with strings with less than two characters.\n\"\"\"\n\n# ====== Solution ======\n\ndef remove_char(s):\n","entry_point":"remove_char","test":"def check(candidate):\n    assert candidate('eloquent') == 'loquen'\n    assert candidate('country') == 'ountr'\n    assert candidate('person') == 'erso'\n    assert candidate('place') == 'lac'\n    assert candidate('ok') == ''\n    assert candidate('ooopsss') == 'oopss'\n\n","canonical_solution":"def remove_char(s):\n    return s[1 : -1]"}
{"task_id":3983,"prompt":"\"\"\"\n=====Problem statement====\n\nIf you have completed the Tribonacci sequence kata, you would know by now that mister Fibonacci has at least a bigger brother. If not, give it a quick look to get how things work.\n\nWell, time to expand the family a little more: think of a Quadribonacci starting with a signature of 4 elements and each following element is the sum of the 4 previous, a Pentabonacci (well *Cinquebonacci* would probably sound a bit more italian, but it would also sound really awful) with a signature of 5 elements and each following element is the sum of the 5 previous, and so on.\n\nWell, guess what? You have to build a Xbonacci function that takes a **signature** of X elements *- and remember each next element is the sum of the last X elements -* and returns the first **n** elements of the so seeded sequence.\n\n```\nxbonacci {1,1,1,1} 10 = {1,1,1,1,4,7,13,25,49,94}\nxbonacci {0,0,0,0,1} 10 = {0,0,0,0,1,1,2,4,8,16}\nxbonacci {1,0,0,0,0,0,1} 10 = {1,0,0,0,0,0,1,2,3,6}\nxbonacci {1,1} produces the Fibonacci sequence\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef Xbonacci(signature,n):\n","entry_point":"Xbonacci","test":"def check(candidate):\n    assert candidate([0, 1],10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n    assert candidate([1, 1],10) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    assert candidate([0, 0, 0, 0, 1],10) == [0, 0, 0, 0, 1, 1, 2, 4, 8, 16]\n    assert candidate([1, 0, 0, 0, 0, 0, 1],10) == [1, 0, 0, 0, 0, 0, 1, 2, 3, 6]\n    assert candidate([1, 0, 0, 0, 0, 0, 0, 0, 0, 0],20) == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 4, 8, 16, 32, 64, 128, 256]\n    assert candidate([0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0],10) == [0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0],20) == [0.5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 2, 4, 8, 16, 32, 64, 128]\n    assert candidate([0, 0, 0, 0, 0, 0, 0, 0, 0, 0],20) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 0],9) == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 0],0) == []\n\n","canonical_solution":"def Xbonacci(signature,n):\n    output, x = signature[:n], len(signature)\n    while len(output) < n:\n        output.append(sum(output[-x:]))\n    return output"}
{"task_id":3984,"prompt":"\"\"\"\n=====Problem statement====\n\nIf you like Taco Bell, you will be familiar with their signature doritos locos taco. They're very good.\n\n\nWhy can't everything be a taco? We're going to attempt that here, turning every word we find into the taco bell recipe with each ingredient.\n\n\nWe want to input a word as a string, and return a list representing that word as a taco.\n\n***Key***\n\nall vowels (except 'y') = beef\n\nt = tomato\n\nl = lettuce\n\nc = cheese\n\ng = guacamole\n\ns = salsa\n\n  \n***NOTE***    \nWe do not care about case here. 'S' is therefore equivalent to 's' in our taco.\n  \nIgnore all other letters; we don't want our taco uneccesarily clustered or else it will be too difficult to eat.\n\nNote that no matter what ingredients are passed, our taco will always have a shell.\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\nTACODICT = {\n             't':'tomato', \n             'l':'lettuce',\n             'c':'cheese',\n             'g':'guacamole',\n             's':'salsa'\n           }\n\ndef tacofy(word):\n","entry_point":"tacofy","test":"def check(candidate):\n    assert candidate('') == ['shell', 'shell']\n    assert candidate('a') == ['shell', 'beef', 'shell']\n    assert candidate('ogl') == ['shell', 'beef', 'guacamole', 'lettuce', 'shell']\n    assert candidate('alel') == ['shell', 'beef', 'lettuce', 'beef', 'lettuce', 'shell']\n    assert candidate('MaXwElL') == ['shell', 'beef', 'beef', 'lettuce', 'lettuce', 'shell']\n    assert candidate('ggg') == ['shell', 'guacamole', 'guacamole', 'guacamole', 'shell']\n    assert candidate('Alex is Super Cool') == ['shell', 'beef', 'lettuce', 'beef', 'beef', 'salsa', 'salsa', 'beef', 'beef', 'cheese', 'beef', 'beef', 'lettuce', 'shell']\n    assert candidate('ydjkpwqrzto') == ['shell', 'tomato', 'beef', 'shell']\n    assert candidate('abtlcgs') == ['shell', 'beef', 'tomato', 'lettuce', 'cheese', 'guacamole', 'salsa', 'shell']\n\n","canonical_solution":"import re\n\nTACODICT = {\n             't':'tomato', \n             'l':'lettuce',\n             'c':'cheese',\n             'g':'guacamole',\n             's':'salsa'\n           }\n\ndef tacofy(word):\n    return ['shell'] + [TACODICT.get(c, 'beef') for c in re.sub('[^aeioutlcgs]+' ,'', word.lower())] + ['shell']"}
{"task_id":3988,"prompt":"\"\"\"\n=====Problem statement====\n\n[Run-length encoding](http:\/\/en.wikipedia.org\/wiki\/Run-length_encoding) (RLE) is a very simple form of lossless data compression in which runs of data are stored as a single data value and count.\n\nA simple form of RLE would encode the string `\"AAABBBCCCD\"` as `\"3A3B3C1D\"` meaning, first there are `3 A`, then `3 B`, then `3 C` and last there is `1 D`.\n\nYour task is to write a RLE encoder and decoder using this technique. The texts to encode will always consist of only uppercase characters, no numbers.\n\"\"\"\n\n# ====== Solution ======\n\nfrom re import sub\n\ndef encode(string):\n","entry_point":"encode","test":"def check(candidate):\n    assert candidate('A') == '1A'\n    assert candidate('AAA') == '3A'\n    assert candidate('AB') == '1A1B'\n    assert candidate('AAABBBCCCA') == '3A3B3C1A'\n    assert candidate('QQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB') == '513Q1A1023B'\n\n","canonical_solution":"from re import sub\n\ndef encode(string):\n    return sub(r'(.)\\1*', lambda m: str(len(m.group(0))) + m.group(1),string)\n    \ndef decode(string): \n    return sub(r'(\\d+)(\\D)', lambda m: m.group(2) * int(m.group(1)),string)"}
{"task_id":3999,"prompt":"\"\"\"\n=====Problem statement====\n\nYour job is to return the volume of a cup when given the diameter of the top, the diameter of the bottom and the height.\n\nYou know that there is a steady gradient from the top to the bottom.\n\nYou want to return the volume rounded to 2 decimal places.\n\nExmples:\n```python\ncup_volume(1, 1, 1)==0.79\n\ncup_volume(10, 8, 10)==638.79\n\ncup_volume(1000, 1000, 1000)==785398163.4\n\ncup_volume(13.123, 123.12, 1)==4436.57\n\ncup_volume(5, 12, 31)==1858.51\n```\n\nYou will only be passed positive numbers.\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import pi\n\ndef cup_volume(d1, d2, h):\n","entry_point":"cup_volume","test":"def check(candidate):\n    assert candidate(1,1,1) == 0.79\n    assert candidate(10,8,10) == 638.79\n    assert candidate(1000,1000,1000) == 785398163.4\n    assert candidate(13.123,123.12,1) == 4436.57\n    assert candidate(5,12,31) == 1858.51\n\n","canonical_solution":"from math import pi\n\ndef cup_volume(d1, d2, h):\n    return round(h \/ 12.0 * pi * (d1**2 + d1*d2 + d2**2), 2)"}
{"task_id":4022,"prompt":"\"\"\"\n=====Problem statement====\n\n# A History Lesson\n\nSoundex is an interesting phonetic algorithm developed nearly 100 years ago for indexing names as they are pronounced in English. The goal is for homophones to be encoded to the same representation so that they can be matched despite minor differences in spelling.\n\nReference: https:\/\/en.wikipedia.org\/wiki\/Soundex\n\n\n\n# Preface\n\nI first read about Soundex over 30 years ago. At the time it seemed to me almost  like  A.I. that you could just type in somebody's name the way it sounded and there was still a pretty good chance it could match the correct person record. That was about the same year as the first \"Terminator\" movie so it was easy for me to put 2 and 2 together and conclude that Arnie must have had some kind of futuristic Soundex chip in his titanium skull helping him to locate ```Serah Coner```... or was it ```Sarh Connor```... or maybe ```Sayra Cunnarr```...\n\n:-)\n\n\n\n# Task\n\nIn this Kata you will encode strings using a Soundex variation called \"American Soundex\" using the following (case insensitive) steps:\n\n* Save the first letter. Remove all occurrences of ```h``` and ```w``` except first letter.\n* Replace all consonants (include the first letter) with digits as follows:\n * ```b```, ```f```, ```p```, ```v``` = 1\n * ```c```, ```g```, ```j```, ```k```, ```q```, ```s```, ```x```, ```z``` = 2\n * ```d```, ```t``` = 3\n * ```l``` = 4\n * ```m```, ```n``` = 5\n * ```r``` = 6\n* Replace all adjacent same digits with one digit.\n* Remove all occurrences of ```a```, ```e```, ```i```, ```o```, ```u```, ```y``` except first letter.\n* If first symbol is a digit replace it with letter saved on step 1.\n* Append 3 zeros if result contains less than 3 digits. Remove all except first letter and 3 digits after it\n\n## Input\n\nA space separated string of one or more names. E.g.\n\n```Sarah Connor```\n\n## Output\n\nSpace separated string of equivalent Soundex codes (the first character of each code must be uppercase). E.g.\n\n```S600 C560```\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\nREPLACMENTS  = [\"BFPV\", \"CGJKQSXZ\", \"DT\",\"L\",\"MN\",\"R\"]\nER1, ER2     = \"HW\", \"AEIOUY\"\n\nTABLE_ERASE1 = str.maketrans(\"\", \"\", ER1)\nTABLE_NUMS   = str.maketrans( ''.join(REPLACMENTS), ''.join( str(n)*len(elt) for n,elt in enumerate(REPLACMENTS, 1)) )\nTABLE_ERASE2 = str.maketrans(\"\", \"\", ER2)\n\n\ndef formatSoundex(w):\n    s = w[0]*(w[0] in ER1+ER2) +  re.sub(r'(\\d)\\1*', r'\\1', w.translate(TABLE_ERASE1).translate(TABLE_NUMS)).translate(TABLE_ERASE2)\n    return ((w[0] if s[0].isdigit() else s[0]) + s[1:] + \"000\")[:4]\n\ndef soundex(name):\n","entry_point":"soundex","test":"def check(candidate):\n    assert candidate('Sarah Connor') == 'S600 C560'\n    assert candidate('Sara Conar') == 'S600 C560'\n    assert candidate('Serah Coner') == 'S600 C560'\n    assert candidate('Sarh Connor') == 'S600 C560'\n    assert candidate('Sayra Cunnarr') == 'S600 C560'\n    assert candidate('Tim') == 'T500'\n    assert candidate('Joe') == 'J000'\n    assert candidate('Bob') == 'B100'\n    assert candidate('Robert') == 'R163'\n    assert candidate('Rupert') == 'R163'\n    assert candidate('Rubin') == 'R150'\n    assert candidate('Ashcraft') == 'A261'\n    assert candidate('Ashcroft') == 'A261'\n    assert candidate('Tymczak') == 'T522'\n    assert candidate('Pfister') == 'P236'\n    assert candidate('zxqurlwbx') == 'Z641'\n    assert candidate('uryrtkzp') == 'U663'\n\n","canonical_solution":"import re\n\nREPLACMENTS  = [\"BFPV\", \"CGJKQSXZ\", \"DT\",\"L\",\"MN\",\"R\"]\nER1, ER2     = \"HW\", \"AEIOUY\"\n\nTABLE_ERASE1 = str.maketrans(\"\", \"\", ER1)\nTABLE_NUMS   = str.maketrans( ''.join(REPLACMENTS), ''.join( str(n)*len(elt) for n,elt in enumerate(REPLACMENTS, 1)) )\nTABLE_ERASE2 = str.maketrans(\"\", \"\", ER2)\n\n\ndef formatSoundex(w):\n    s = w[0]*(w[0] in ER1+ER2) +  re.sub(r'(\\d)\\1*', r'\\1', w.translate(TABLE_ERASE1).translate(TABLE_NUMS)).translate(TABLE_ERASE2)\n    return ((w[0] if s[0].isdigit() else s[0]) + s[1:] + \"000\")[:4]\n\ndef soundex(name):\n    return ' '.join(formatSoundex(w.upper()) for w in name.split(\" \"))"}
{"task_id":4023,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a string of words, you need to find the highest scoring word.\n\nEach letter of a word scores points according to its position in the alphabet: `a = 1, b = 2, c = 3` etc.\n\nYou need to return the highest scoring word as a string.\n\nIf two words score the same, return the word that appears earliest in the original string.\n\nAll letters will be lowercase and all inputs will be valid.\n\"\"\"\n\n# ====== Solution ======\n\ndef high(x):\n","entry_point":"high","test":"def check(candidate):\n    assert candidate('man i need a taxi up to ubud') == 'taxi'\n    assert candidate('what time are we climbing up the volcano') == 'volcano'\n    assert candidate('take me to semynak') == 'semynak'\n    assert candidate('massage yes massage yes massage') == 'massage'\n    assert candidate('take two bintang and a dance please') == 'bintang'\n\n","canonical_solution":"def high(x):\n    return max(x.split(), key=lambda k: sum(ord(c) - 96 for c in k))"}
{"task_id":4026,"prompt":"\"\"\"\n=====Problem statement====\n\n### Preface\nYou are currently working together with a local community to build a school teaching children how to code. First plans have been made and the community wants to decide on the best location for the coding school.\nIn order to make this decision data about the location of students and potential locations is collected. \n\n### Problem\nIn order to be able to attract and teach as many students as possible we want to minimize the total traveling distance for potential students. The streets system is organized in a traditional grid system and students can only travel horizontally or vertically (not diagonal).\n\nThe locations of interested students is given as an array with the first value of each entry presenting the x coordinate and the second value presenting the y coordinate:\n```python\nstudents = [[3,7],[2,2],[14,1], ...];\n```\nPotential locations are passed as an array of objects with an unique id, a x and y coordinate:\n```python\nlocations = [{\"id\": 1, \"x\": 3, \"y\": 4}, {\"id\": 2, \"x\": 8, \"y\": 2}, ...];\n```\n\nYour task is now to evaluate which of the school locations would be best to minimize the distance for all potential students to the school.\n\nThe desired output should consist of a string indicating the ID of the best suitable location and the x and y coordinates in the following form:\n\n```\n\"The best location is number 1 with the coordinates x = 3 and y = 4\"\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef optimum_location(students, locations):\n","entry_point":"optimum_location","test":"def check(candidate):\n    assert candidate([[3, 7], [2, 2], [14, 1]],[{'id': 1, 'x': 3, 'y': 4}, {'id': 2, 'x': 8, 'y': 2}]) == 'The best location is number 1 with the coordinates x = 3 and y = 4'\n    assert candidate([[54, 7], [1, 211], [14, 44], [12, 5], [14, 7]],[{'id': 1, 'x': 44, 'y': 55}, {'id': 2, 'x': 12, 'y': 57}, {'id': 3, 'x': 23, 'y': 66}]) == 'The best location is number 2 with the coordinates x = 12 and y = 57'\n    assert candidate([[152, 7], [1, 211], [14, 56], [12, 4], [142, 7]],[{'id': 1, 'x': 63, 'y': 55}, {'id': 2, 'x': 55, 'y': 21}, {'id': 3, 'x': 144, 'y': 12}]) == 'The best location is number 2 with the coordinates x = 55 and y = 21'\n    assert candidate([[152, 742], [466, 2211], [1412, 564], [142, 444], [142, 744]],[{'id': 1, 'x': 1263, 'y': 525}, {'id': 2, 'x': 55, 'y': 21}, {'id': 3, 'x': 537, 'y': 1244}]) == 'The best location is number 3 with the coordinates x = 537 and y = 1244'\n    assert candidate([[7, 66], [71, 7], [0, 94], [16, 93], [33, 49], [49, 81], [17, 2], [95, 71], [32, 14], [31, 41], [92, 72], [12, 79]],[{'y': 38, 'x': 32, 'id': 1}, {'y': 49, 'x': 73, 'id': 2}, {'y': 85, 'x': 50, 'id': 3}, {'y': 2, 'x': 79, 'id': 4}, {'y': 20, 'x': 44, 'id': 5}, {'y': 56, 'x': 17, 'id': 6}, {'y': 43, 'x': 26, 'id': 7}, {'y': 61, 'x': 89, 'id': 8}, {'y': 18, 'x': 15, 'id': 9}, {'y': 34, 'x': 41, 'id': 10}, {'y': 27, 'x': 99, 'id': 11}]) == 'The best location is number 6 with the coordinates x = 17 and y = 56'\n\n","canonical_solution":"def optimum_location(students, locations):\n    m = min(locations, key = lambda loc: sum(abs(loc['x'] - s[0]) + abs(loc['y'] - s[1]) for s in students))\n    return \"The best location is number %d with the coordinates x = %d and y = %d\" % (m['id'], m['x'], m['y'])\n"}
{"task_id":4037,"prompt":"\"\"\"\n=====Problem statement====\n\nWhen a warrior wants to talk with another one about peace or war he uses a smartphone.  In one distinct  country warriors who spent all time in training kata not always have enough money. So if they call some number they want to know which operator serves  this number. \n\nWrite a function which **accepts number and return name of operator or string \"no info\"**, if operator can't be defined. number always looks like 8yyyxxxxxxx, where yyy corresponds to operator.\n\nHere is short list of operators:\n\n* 039 xxx xx xx - Golden Telecom\n* 050 xxx xx xx - MTS\n* 063 xxx xx xx - Life:)\n* 066 xxx xx xx - MTS\n* 067 xxx xx xx - Kyivstar\n* 068 xxx xx xx - Beeline\n* 093 xxx xx xx - Life:)\n* 095 xxx xx xx - MTS\n* 096 xxx xx xx - Kyivstar\n* 097 xxx xx xx - Kyivstar\n* 098 xxx xx xx - Kyivstar\n* 099 xxx xx xx - MTS Test [Just return \"MTS\"]\n\"\"\"\n\n# ====== Solution ======\n\nOPERATORS = {\n    '039': 'Golden Telecom', '050': 'MTS', '063': 'Life:)', '066': 'MTS',\n    '067': 'Kyivstar', '068': 'Beeline', '093': 'Life:)', '095': 'MTS',\n    '096': 'Kyivstar', '097': 'Kyivstar', '098': 'Kyivstar', '099': 'MTS'}\n\n\ndef detect_operator(num):\n","entry_point":"detect_operator","test":"def check(candidate):\n    assert candidate('80661111841') == 'MTS'\n    assert candidate('80671991111') == 'Kyivstar'\n    assert candidate('80631551111') == 'Life:)'\n    assert candidate('80931551111') == 'Life:)'\n    assert candidate('80111551111') == 'no info'\n\n","canonical_solution":"OPERATORS = {\n    '039': 'Golden Telecom', '050': 'MTS', '063': 'Life:)', '066': 'MTS',\n    '067': 'Kyivstar', '068': 'Beeline', '093': 'Life:)', '095': 'MTS',\n    '096': 'Kyivstar', '097': 'Kyivstar', '098': 'Kyivstar', '099': 'MTS'}\n\n\ndef detect_operator(num):\n    return OPERATORS.get(str(num)[1:4], 'no info')\n"}
{"task_id":4041,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a string S.\nYou have to return another string such that even-indexed and odd-indexed characters of S are grouped and groups are space-separated (see sample below)\n\nNote: \n0 is considered to be an even index. \nAll input strings are valid with no spaces\n\n\ninput:\n'CodeWars'\n\noutput\n'CdWr oeas'\n\nS[0] = 'C'\nS[1] = 'o'\nS[2] = 'd'\nS[3] = 'e'\nS[4] = 'W'\nS[5] = 'a'\nS[6] = 'r'\nS[7] = 's'\n\n\nEven indices 0, 2, 4, 6, so we have 'CdWr' as the first group\nodd ones are 1, 3, 5, 7, so the second group is 'oeas'\nAnd the final string to return is 'Cdwr oeas'\n\nEnjoy.\n\"\"\"\n\n# ====== Solution ======\n\ndef sort_my_string(s):\n","entry_point":"sort_my_string","test":"def check(candidate):\n    assert candidate('Wolfeschlegelsteinhausenbergerdorff') == 'Wleclgltihuebredrf ofsheesenasnegrof'\n    assert candidate('METHIONYLTHREONYLTHREONYGLUTAMINYLARGINYL') == 'MTINLHENLHENGUAIYAGNL EHOYTROYTROYLTMNLRIY'\n    assert candidate('PNEUMONOULTRAMICROSCOPICSILICOVOLCANOCONIOSIS') == 'PEMNUTAIRSOISLCVLAOOISS NUOOLRMCOCPCIIOOCNCNOI'\n    assert candidate('PSEUDOPSEUDOHYPOPARATHYROIDISM') == 'PEDPEDHPPRTYODS SUOSUOYOAAHRIIM'\n    assert candidate('FLOCCINAUCINIHILIPILIFICATION') == 'FOCNUIIIIIIIAIN LCIACNHLPLFCTO'\n    assert candidate('SUBDERMATOGLYPHIC') == 'SBEMTGYHC UDRAOLPI'\n\n","canonical_solution":"def sort_my_string(s):\n    return '{} {}'.format(s[::2], s[1::2])"}
{"task_id":4061,"prompt":"\"\"\"\n=====Problem statement====\n\nConsider the sequence `a(1) = 7, a(n) = a(n-1) + gcd(n, a(n-1)) for n >= 2`: \n\n`7, 8, 9, 10, 15, 18, 19, 20, 21, 22, 33, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 69, 72, 73...`.\n\nLet us take the differences between successive elements of the sequence and\nget a second sequence `g: 1, 1, 1, 5, 3, 1, 1, 1, 1, 11, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 3, 1...`.\n\nFor the sake of uniformity of the lengths of sequences **we add** a `1` at the head of g:\n\n`g: 1, 1, 1, 1, 5, 3, 1, 1, 1, 1, 11, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 23, 3, 1...`\n\nRemoving the 1s gives a third sequence:\n`p: 5, 3, 11, 3, 23, 3...`\nwhere you can see prime numbers.\n\n#Task:\nWrite functions:\n```\n1: an(n) with parameter n: returns the first n terms of the series a(n) (not tested)\n\n2: gn(n) with parameter n: returns the first n terms of the series g(n) (not tested)\n\n3: countOnes(n) with parameter n: returns the number of 1 in g(n) \n    (don't forget to add a `1` at the head) # (tested)\n    \n4: p(n) with parameter n: returns an array of n unique prime numbers (not tested)\n\n5: maxp(n) with parameter n: returns the biggest prime number of the sequence pn(n) # (tested)\n\n6: anOver(n) with parameter n: returns an array (n terms) of the a(i)\/i for every i such g(i) != 1 (not tested but interesting result)\n\n7: anOverAverage(n) with parameter n: returns as an *integer* the average of anOver(n)  (tested)\n```\n\n#Note:\nYou can write directly functions `3:`, `5:` and `7:`. There is no need to write functions `1:`, `2:`, `4:` `6:`\nexcept out of pure curiosity.\n\"\"\"\n\n# ====== Solution ======\n\ndef count_ones(n):\n","entry_point":"count_ones","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(10) == 8\n    assert candidate(100) == 90\n    assert candidate(200) == 184\n    assert candidate(1000) == 975\n    assert candidate(10000) == 9968\n    assert candidate(100000) == 99955\n\n","canonical_solution":"def count_ones(n):\n    a, ones = 7, 1\n    for i in range(2, n+1):\n        b = a + gcd(i, a)\n        if b == a + 1: ones += 1\n        a = b\n\n    return ones\n\ndef max_pn(n):\n    a, p, i = 7, {1}, 1\n    \n    while len(p) < n + 1:\n        i += 1\n        b = a + gcd(i, a)\n        p.add(b - a)\n        a = b\n    return max(p)\n\ndef an_over_average(n):\n    return 3\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a"}
{"task_id":4063,"prompt":"\"\"\"\n=====Problem statement====\n\nMr. E Ven only likes even length words.\nPlease create a translator so that he doesn't have to hear those pesky odd length words.\nFor some reason he also hates punctuation, he likes his sentences to flow.\n\nYour translator should take in a string and output it with all odd length words having an extra letter (the last letter in the word). It should also remove all punctuation (.,?!) as well as any underscores (_).\n\n\"How did we end up here? We go?\"\ntranslated becomes-> \n\"Howw didd we endd up here We go\"\n\"\"\"\n\n# ====== Solution ======\n\ndef evenize_word(w):\n    return w + w[-1] if len(w) % 2 else w\n\ndef evenator(s):\n","entry_point":"evenator","test":"def check(candidate):\n    assert candidate('I got a hole in 1!') == 'II gott aa hole in 11'\n    assert candidate('tHiS sEnTeNcE iS eVeN.') == 'tHiS sEnTeNcE iS eVeN'\n    assert candidate('underscore is not considered a word..in this case,') == 'underscore is nott considered aa wordin this case'\n    assert candidate('hi. how are you? Bye!!') == 'hi howw aree youu Byee'\n    assert candidate('lorem is so ipsum. why bother?') == 'loremm is so ipsumm whyy bother'\n    assert candidate('_under the seA!') == 'underr thee seAA'\n\n","canonical_solution":"def evenize_word(w):\n    return w + w[-1] if len(w) % 2 else w\n\ndef evenator(s):\n    s = \"\".join(c for c in s if c.isspace() or c.isalnum())\n    return \" \".join(evenize_word(w) for w in s.split())"}
{"task_id":4079,"prompt":"\"\"\"\n=====Problem statement====\n\nThis is a follow up from my kata The old switcheroo\n\nWrite\n```python\ndef encode(str)\n```\nthat takes in a string ```str``` and replaces all the letters with their respective positions in the English alphabet.\n\n```python\nencode('abc') == '123'   # a is 1st in English alpabet, b is 2nd and c is 3rd\nencode('codewars') == '315452311819'\nencode('abc-#@5') == '123-#@5'\n```\nString are case sensitive.\n\"\"\"\n\n# ====== Solution ======\n\ndef encode(string):\n","entry_point":"encode","test":"def check(candidate):\n    assert candidate('abc') == '123'\n    assert candidate('ABCD') == '1234'\n    assert candidate('ZzzzZ') == '2626262626'\n    assert candidate('abc-#@5') == '123-#@5'\n    assert candidate('this is a long string!! Please [encode] @C0RrEctly') == '208919 919 1 1215147 1920189147!! 161251195 [51431545] @30181853201225'\n\n","canonical_solution":"def encode(string):\n    return ''.join(str(ord(c.upper())-64) if c.isalpha() else c for c in string)"}
{"task_id":4081,"prompt":"\"\"\"\n=====Problem statement====\n\nBaby is getting his frst tooth. This means more sleepless nights, but with the fun of feeling round his gums and trying to guess which will be first out! \n\nProbably best have a sweepstake with your friends - because you have the best chance of knowing. You can feel the gums and see where the raised bits are - most raised, most likely tooth to come through first!\n\nGiven an array of numbers (t) to represent baby's gums, you need to return the index of the lump that is most pronounced. \n\nThe most pronounced lump is the one that has the biggest differential to its surrounding values. e.g.:\n\n```\n[1, 2, 4] = 2\n\nindex 0 has a differential of -1 to its right (it is lower so the figure is negative)\n\nindex 1 has a differential of +1 to its left, and -2 to its right. Total is -1.\n\nindex 2 has a differential of +2 to its left, and nothing to its right, \n```\n\nIf there is no distinct highest value (more than one occurence of the largest differential), return -1.\n\"\"\"\n\n# ====== Solution ======\n\ndef first_tooth(lst):\n","entry_point":"first_tooth","test":"def check(candidate):\n    assert candidate([1, 2, 3, 4]) == 3\n    assert candidate([1, 2, 6, 4]) == 2\n    assert candidate([1, 2, 5, 7, 1, 0, 9]) == 6\n    assert candidate([9, 2, 8, 1]) == 2\n    assert candidate([1, 1, 1, 1]) == -1\n    assert candidate([20, 9, 16, 19]) == 0\n    assert candidate([15]) == 0\n\n","canonical_solution":"def first_tooth(lst):\n    gums = lst[:1] + lst + lst[-1:]\n    diff = [gums[i+1]*2 - gums[i] - gums[i+2] for i in range(len(lst))]\n    m = max(diff)\n    return diff.index(m) if diff.count(m) == 1 else -1\n"}
{"task_id":4084,"prompt":"\"\"\"\n=====Problem statement====\n\nAlex is transitioning from website design to coding and wants to sharpen his skills with CodeWars.  \nHe can do ten kata in an hour, but when he makes a mistake, he must do pushups. These pushups really tire poor Alex out, so every time he does them they take twice as long. His first set of redemption pushups takes 5 minutes. Create a function, `alexMistakes`, that takes two arguments: the number of kata he needs to complete, and the time in minutes he has to complete them. Your function should return how many mistakes Alex can afford to make.\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import log\n\ndef alex_mistakes(n, time):\n","entry_point":"alex_mistakes","test":"def check(candidate):\n    assert candidate(10,120) == 3\n    assert candidate(11,120) == 3\n    assert candidate(3,45) == 2\n    assert candidate(8,120) == 3\n    assert candidate(6,60) == 2\n    assert candidate(9,180) == 4\n    assert candidate(20,120) == 0\n    assert candidate(20,125) == 1\n    assert candidate(20,130) == 1\n    assert candidate(20,135) == 2\n\n","canonical_solution":"from math import log\n\ndef alex_mistakes(n, time):\n    return int(log((time - n * 6) \/ 5 +1, 2))\n"}
{"task_id":4089,"prompt":"\"\"\"\n=====Problem statement====\n\nThe number 45 is the first integer in having this interesting property:\nthe sum of the number with its reversed is divisible by the difference between them(absolute Value).\n```\n45 + 54 = 99 \nabs(45 - 54) = 9\n99 is divisible by 9.\n```\nThe first terms of this special sequence are :\n```\nn               a(n)\n1               45\n2               54\n3               495\n4               594\n```\nMake the function ```sum_dif_rev()```(`sumDivRef` in JavaScript and CoffeeScript), that receives ```n```, the ordinal number of the term and may give us, the value of the term of the sequence.\n```python\nsum_dif_rev(n) -----> a(n)\n```\nLet's see some cases:\n```python\nsum_dif_rev(1) -----> 45\nsum_dif_rev(3) -----> 495\n```\n\"Important: Do not include numbers which, when reversed, have a leading zero, e.g.: 1890 reversed is 0981, so 1890 should not be included.\"\n\nYour code will be tested up to the first 65 terms, so you should think to optimize it as much as you can.\n\n(Hint: I memoize, you memoize, he memoizes, ......they (of course) memoize)\n\nHappy coding!!\n\"\"\"\n\n# ====== Solution ======\n\nMEMO = []\n\ndef sum_dif_rev(n):\n","entry_point":"sum_dif_rev","test":"def check(candidate):\n    assert candidate(1) == 45\n    assert candidate(3) == 495\n    assert candidate(4) == 594\n    assert candidate(5) == 4356\n    assert candidate(6) == 4545\n\n","canonical_solution":"MEMO = []\n\ndef sum_dif_rev(n):\n    i = MEMO[-1] if MEMO else 0\n    \n    while len(MEMO) < n:\n        i += 1\n        r = int(str(i)[::-1])\n        if i % 10 and r != i and (i + r) % abs(r - i) == 0:\n            MEMO.append(i)\n\n    return MEMO[n-1]"}
{"task_id":4093,"prompt":"\"\"\"\n=====Problem statement====\n\nIn an infinite array with two rows, the numbers in the top row are denoted\n\n`. . . , A[\u22122], A[\u22121], A[0], A[1], A[2], . . .`\n\nand the numbers in the bottom row are denoted\n\n`. . . , B[\u22122], B[\u22121], B[0], B[1], B[2], . . .`\n\nFor each integer `k`, the entry `A[k]` is directly above\nthe entry `B[k]` in the array, as shown:\n\n\n...|A[-2]|A[-1]|A[0]|A[1]|A[2]|...\n...|B[-2]|B[-1]|B[0]|B[1]|B[2]|...\n\n\n\nFor each integer `k`, `A[k]` is the average of the entry to its left, the entry to its right,\nand the entry below it; similarly, each entry `B[k]` is the average of the entry to its\nleft, the entry to its right, and the entry above it.\n\n\nGiven `A[0], A[1], A[2] and A[3]`, determine the value of `A[n]`. (Where range of n is -1000 Inputs and Outputs in BigInt!** \n\nAdapted from 2018 Euclid Mathematics Contest.\nhttps:\/\/www.cemc.uwaterloo.ca\/contests\/past_contests\/2018\/2018EuclidContest.pdf\n\"\"\"\n\n# ====== Solution ======\n\ndef find_a(lst,n):\n","entry_point":"find_a","test":"def check(candidate):\n    assert candidate([1, 2, 3, 4],2) == 3\n    assert candidate([38, 200, -18, 45],1) == 200\n    assert candidate([1, 0, 0, 1],5) == 20\n    assert candidate([0, 2, 0, 3],-2) == -126\n    assert candidate([-20, 1, -3, 14],-5) == -44402\n    assert candidate([1, 2, 3, 5],100) == 60560100487003612846322657690093088848428068520476594299\n    assert candidate([0, 4, 6, 13],100) == 335254562473098582210532865941148591672699700764231400858\n\n","canonical_solution":"def find_a(lst,n):\n    if n<0: return find_a(lst[::-1], 3-n)\n    if n<4: return lst[n]\n    a,b,c,d = lst\n    for _ in range(n-3):\n        a,b,c,d = b, c, d, 6*d-10*c+6*b-a\n    return d"}
{"task_id":4100,"prompt":"\"\"\"\n=====Problem statement====\n\nReverse every other word in a given string, then return the string. Throw away any leading or trailing whitespace, while ensuring there is exactly one space between each word. Punctuation marks should be treated as if they are a part of the word in this kata.\n\"\"\"\n\n# ====== Solution ======\n\ndef reverse_alternate(string):\n","entry_point":"reverse_alternate","test":"def check(candidate):\n    assert candidate('Did it work?') == 'Did ti work?'\n    assert candidate('I really hope it works this time...') == 'I yllaer hope ti works siht time...'\n    assert candidate('Reverse this string, please!') == 'Reverse siht string, !esaelp'\n    assert candidate('Have a beer') == 'Have a beer'\n    assert candidate('   ') == ''\n    assert candidate('This is not a test ') == 'This si not a test'\n    assert candidate('This       is a  test ') == 'This si a tset'\n\n","canonical_solution":"def reverse_alternate(string):\n    return \" \".join(y[::-1] if x%2 else y for x,y in enumerate(string.split()))"}
{"task_id":4107,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n\nGiven the birthdates of two people, find the date when the younger one is exactly half the age of the other.\n\n# Notes\n\n* The dates are given in the format YYYY-MM-DD and are not sorted in any particular order\n* Round **down** to the nearest day\n* Return the result as a string, like the input dates\n\"\"\"\n\n# ====== Solution ======\n\nfrom dateutil.parser import parse\n\ndef half_life(*persons):\n","entry_point":"half_life","test":"def check(candidate):\n    assert candidate('1990-12-06','2000-02-29') == '2009-05-24'\n    assert candidate('2012-03-31','1990-06-09') == '2034-01-21'\n    assert candidate('1984-08-14','1990-04-17') == '1995-12-19'\n    assert candidate('2000-06-30','1978-03-17') == '2022-10-14'\n    assert candidate('1969-12-20','2000-10-07') == '2031-07-26'\n\n","canonical_solution":"from dateutil.parser import parse\n\ndef half_life(*persons):\n    p1,p2 = sorted(map(parse, persons))\n    return str( p2+(p2-p1) )[:10]"}
{"task_id":4111,"prompt":"\"\"\"\n=====Problem statement====\n\nLearning to code around your full time job is taking over your life. You realise that in order to make significant steps quickly, it would help to go to a coding bootcamp in London.\n\nProblem is, many of them cost a fortune, and those that don't still involve a significant amount of time off work - who will pay your mortgage?!\n\nTo offset this risk, you decide that rather than leaving work totally, you will request a sabbatical so that you can go back to work post bootcamp and be paid while you look for your next role.\n\nYou need to approach your boss. Her decision will be based on three parameters:\n\nval=your value to the organisation\nhappiness=her happiness level at the time of asking and finally\nThe numbers of letters from 'sabbatical' that are present in string `s`.\n\nNote that if `s` contains three instances of the letter 'l', that still scores three points, even though there is only one in the word sabbatical.\n\nIf the sum of the three parameters (as described above) is > 22, return 'Sabbatical! Boom!', else return 'Back to your desk, boy.'.\n\n~~~if:c\nNOTE: For the C translation you should return a string literal.\n~~~\n\"\"\"\n\n# ====== Solution ======\n\ndef sabb(stg, value, happiness):\n","entry_point":"sabb","test":"def check(candidate):\n    assert candidate('Can I have a sabbatical?',5,5) == 'Sabbatical! Boom!'\n    assert candidate('Why are you shouting?',7,2) == 'Back to your desk, boy.'\n    assert candidate('What do you mean I cant learn to code??',8,9) == 'Sabbatical! Boom!'\n    assert candidate('Please calm down',9,1) == 'Back to your desk, boy.'\n    assert candidate('I can?! Nice. FaC..Im coming :D',9,9) == 'Sabbatical! Boom!'\n\n","canonical_solution":"def sabb(stg, value, happiness):\n    sabbatical = (value + happiness + sum(1 for c in stg if c in \"sabbatical\")) > 22\n    return \"Sabbatical! Boom!\" if sabbatical else \"Back to your desk, boy.\""}
{"task_id":4116,"prompt":"\"\"\"\n=====Problem statement====\n\n*Are you a file extension master? Let's find out by checking if Bill's files are images or audio files. Please use regex if available natively for your language.*\n\nYou will create 2 string methods:\n\n- **isAudio\/is_audio**, matching 1 or + uppercase\/lowercase letter(s) (combination possible), with the extension .mp3, .flac, .alac, or .aac.\n\n- **isImage\/is_image**, matching 1 or + uppercase\/lowercase letter(s) (combination possible), with the extension .jpg, .jpeg, .png, .bmp, or .gif. \n\n\n*Note that this is not a generic image\/audio files checker. It's meant to be a test for Bill's files only. Bill doesn't like punctuation. He doesn't like numbers, neither. Thus, his filenames are letter-only*\n\n**Rules**\n\n1. It should return true or false, simply.\n2. File extensions should consist of lowercase letters and numbers only.\n3. File names should consist of letters only (uppercase, lowercase, or both)\n\nGood luck!\n\"\"\"\n\n# ====== Solution ======\n\ndef is_audio(filename):\n","entry_point":"is_audio","test":"def check(candidate):\n    assert candidate('Nothing Else Matters.mp3') == False\n    assert candidate('NothingElseMatters.mp3') == True\n    assert candidate('DaftPunk.FLAC') == False\n    assert candidate('DaftPunk.flac') == True\n    assert candidate('AmonTobin.aac') == True\n    assert candidate(' Amon Tobin.alac') == False\n    assert candidate('tobin.alac') == True\n\n","canonical_solution":"def is_audio(filename):\n    name, ext = filename.split('.')\n    return name.isalpha() and ext in {'mp3', 'flac', 'alac', 'aac'}\n\n\ndef is_img(filename):\n    name, ext = filename.split('.')\n    return name.isalpha() and ext in {'jpg', 'jpeg', 'png', 'bmp', 'gif'}"}
{"task_id":4128,"prompt":"\"\"\"\n=====Problem statement====\n\nIn order to prove it's success and gain funding, the wilderness zoo needs to prove to environmentalists that it has x number of mating pairs of bears. \n\nYou must check within string (s) to find all of the mating pairs, and return a string containing only them. Line them up for inspection.\n\nRules:\nBears are either 'B' (male) or '8' (female),\nBears must be together in male\/female pairs 'B8' or '8B',\nMating pairs must involve two distinct bears each ('B8B' may look fun, but does not count as two pairs).\n\nReturn an array containing a string of only the mating pairs available. e.g:\n\n'EvHB8KN8ik8BiyxfeyKBmiCMj' ---> 'B88B'    (empty string if there are no pairs)\n\nand true if the number is more than or equal to x, false if not:\n\n(6, 'EvHB8KN8ik8BiyxfeyKBmiCMj') ---> ['B88B', false];\n\nx will always be a positive integer, and s will never be empty\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\ndef bears(n, s):\n","entry_point":"bears","test":"def check(candidate):\n    assert candidate(7,'8j8mBliB8gimjB8B8jlB') == ['B8B8B8', False]\n    assert candidate(3,'88Bifk8hB8BB8BBBB888chl8BhBfd') == ['8BB8B8B88B', True]\n    assert candidate(8,'8') == ['', False]\n    assert candidate(1,'j8BmB88B88gkBBlf8hg8888lbe88') == ['8BB88B', True]\n    assert candidate(0,'8j888aam') == ['', True]\n\n","canonical_solution":"import re\n\ndef bears(n, s):\n    a = re.findall(r\"B8|8B\", s)\n    return [\"\".join(a), len(a) >= n]"}
{"task_id":4132,"prompt":"\"\"\"\n=====Problem statement====\n\nSome new animals have arrived at the zoo. The zoo keeper is concerned that perhaps the animals do not have the right tails. To help her, you must correct the broken function to make sure that the second argument (tail), is the same as the last letter of the first argument (body) - otherwise the tail wouldn't fit!\n\nIf the tail is right return true, else return false.\n\nThe arguments will always be strings, and normal letters.\n\"\"\"\n\n# ====== Solution ======\n\ndef correct_tail(body, tail):\n","entry_point":"correct_tail","test":"def check(candidate):\n    assert candidate('Fox','x') == True\n    assert candidate('Rhino','o') == True\n    assert candidate('Meerkat','t') == True\n    assert candidate('Emu','t') == False\n    assert candidate('Badger','s') == False\n    assert candidate('Giraffe','d') == False\n\n","canonical_solution":"def correct_tail(body, tail):\n    return body.endswith(tail)\n"}
{"task_id":4139,"prompt":"\"\"\"\n=====Problem statement====\n\nAfter a hard quarter in the office you decide to get some rest on a vacation. So you will book a flight for you and your girlfriend and try to leave all the mess behind you.\n\nYou will need a rental car in order for you to get around in your vacation. The manager of the car rental makes you some good offers.\n\nEvery day you rent the car costs $40. If you rent the car for 7 or more days, you get $50 off your total. Alternatively, if you rent the car for 3 or more days, you get $20 off your total.\n\nWrite a code that gives out the total amount for different days(d).\n\"\"\"\n\n# ====== Solution ======\n\ndef rental_car_cost(d):\n","entry_point":"rental_car_cost","test":"def check(candidate):\n    assert candidate(1) == 40\n    assert candidate(2) == 80\n    assert candidate(3) == 100\n    assert candidate(4) == 140\n    assert candidate(5) == 180\n    assert candidate(6) == 220\n    assert candidate(7) == 230\n    assert candidate(8) == 270\n    assert candidate(9) == 310\n    assert candidate(10) == 350\n\n","canonical_solution":"def rental_car_cost(d):\n    result = d * 40\n    if d >= 7:\n        result -= 50\n    elif d >= 3:\n        result -= 20\n    return result"}
{"task_id":4140,"prompt":"\"\"\"\n=====Problem statement====\n\n# Bubblesort Algorithm\n\n## Overview\n\nThe Bubblesort Algorithm is one of many algorithms used to sort a list of similar items (e.g. all numbers or all letters) into either ascending order or descending order.  Given a list (e.g.):\n\n```python\n[9, 7, 5, 3, 1, 2, 4, 6, 8]\n```\n\nTo sort this list in ascending order using Bubblesort, you first have to compare the first two terms of the list.  If the first term is larger than the second term, you perform a swap.  The list then becomes:\n\n```python\n[7, 9, 5, 3, 1, 2, 4, 6, 8] # The \"9\" and \"7\" have been swapped because 9 is larger than 7 and thus 9 should be after 7\n```\n\nYou then proceed by comparing the 2nd and 3rd terms, performing a swap *when necessary*, and then the 3rd and 4th term, then the 4th and 5th term, etc. etc.  When you reach the end of the list, it is said that you have completed **1 complete pass**.\n\n## Task\n\nGiven an array of integers, your function `bubblesortOnce`\/`bubblesort_once`\/`BubblesortOnce` (or equivalent, depending on your language's naming conventions) should return a *new* array equivalent to performing exactly **1 complete pass** on the original array.  Your function should be pure, i.e. it should **not** mutate the input array.\n\"\"\"\n\n# ====== Solution ======\n\ndef bubblesort_once(l):\n","entry_point":"bubblesort_once","test":"def check(candidate):\n    assert candidate([9, 7, 5, 3, 1, 2, 4, 6, 8]) == [7, 5, 3, 1, 2, 4, 6, 8, 9]\n    assert candidate([1, 2]) == [1, 2]\n    assert candidate([2, 1]) == [1, 2]\n    assert candidate([1, 3]) == [1, 3]\n    assert candidate([3, 1]) == [1, 3]\n    assert candidate([24, 57]) == [24, 57]\n    assert candidate([89, 36]) == [36, 89]\n    assert candidate([1, 2, 3]) == [1, 2, 3]\n    assert candidate([2, 4, 1]) == [2, 1, 4]\n    assert candidate([17, 5, 11]) == [5, 11, 17]\n    assert candidate([25, 16, 9]) == [16, 9, 25]\n    assert candidate([103, 87, 113]) == [87, 103, 113]\n    assert candidate([1032, 3192, 2864]) == [1032, 2864, 3192]\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([2, 3, 4, 1]) == [2, 3, 1, 4]\n    assert candidate([3, 4, 1, 2]) == [3, 1, 2, 4]\n    assert candidate([4, 1, 2, 3]) == [1, 2, 3, 4]\n    assert candidate([7, 5, 3, 1]) == [5, 3, 1, 7]\n    assert candidate([5, 3, 7, 7]) == [3, 5, 7, 7]\n    assert candidate([3, 1, 8, 5]) == [1, 3, 5, 8]\n    assert candidate([1, 9, 5, 5]) == [1, 5, 5, 9]\n    assert candidate([6, 3, 4, 9, 1, 2, 7, 8, 5]) == [3, 4, 6, 1, 2, 7, 8, 5, 9]\n    assert candidate([6, 3, 4, 15, 14, 9, 1, 2, 7, 8, 5, 14, 11, 15, 17, 19]) == [3, 4, 6, 14, 9, 1, 2, 7, 8, 5, 14, 11, 15, 15, 17, 19]\n    assert candidate([42]) == [42]\n    assert candidate([]) == []\n\n","canonical_solution":"def bubblesort_once(l):\n    l = l[:]\n    for i in range(len(l)-1):\n        if l[i] > l[i+1]:\n            l[i], l[i+1] = l[i+1], l[i]\n    return l"}
{"task_id":4152,"prompt":"\"\"\"\n=====Problem statement====\n\nFind the greatest common divisor of two positive integers. The integers can be large, so you need to find a clever solution. \n\nThe inputs `x` and `y` are always greater or equal to 1, so the greatest common divisor will always be an integer that is also greater or equal to 1.\n\"\"\"\n\n# ====== Solution ======\n\n#Try to make your own gcd method without importing stuff\ndef mygcd(x,y):\n","entry_point":"mygcd","test":"def check(candidate):\n    assert candidate(1,3) == 1\n    assert candidate(60,12) == 12\n    assert candidate(2672,5678) == 334\n    assert candidate(10927782,6902514) == 846\n    assert candidate(1590771464,1590771620) == 4\n\n","canonical_solution":"#Try to make your own gcd method without importing stuff\ndef mygcd(x,y):\n    #GOOD LUCK\n    while y:\n        x,y=y,x%y\n    return x"}
{"task_id":4154,"prompt":"\"\"\"\n=====Problem statement====\n\nImplement a method that accepts 3 integer values a, b, c. The method should return true if a triangle can be built with the sides of given length and false in any other case.\n\n(In this case, all triangles must have surface greater than 0 to be accepted).\n\"\"\"\n\n# ====== Solution ======\n\ndef is_triangle(a, b, c):\n","entry_point":"is_triangle","test":"def check(candidate):\n    assert candidate(1,2,2) == True\n    assert candidate(7,2,2) == False\n    assert candidate(1,2,3) == False\n    assert candidate(1,3,2) == False\n    assert candidate(3,1,2) == False\n    assert candidate(5,1,2) == False\n    assert candidate(1,2,5) == False\n    assert candidate(2,5,1) == False\n    assert candidate(4,2,3) == True\n    assert candidate(5,1,5) == True\n    assert candidate(2,2,2) == True\n    assert candidate(-1,2,3) == False\n    assert candidate(1,-2,3) == False\n    assert candidate(1,2,-3) == False\n    assert candidate(0,2,3) == False\n\n","canonical_solution":"def is_triangle(a, b, c):\n    return (a<b+c) and (b<a+c) and (c<a+b)\n"}
{"task_id":4157,"prompt":"\"\"\"\n=====Problem statement====\n\nIn English and programming, groups can be made using symbols such as `()` and `{}` that change meaning. However, these groups must be closed in the correct order to maintain correct syntax.\n\nYour job in this kata will be to make a program that checks a string for correct grouping. For instance, the following groups are done correctly:\n\n```\n({})\n[[]()]\n[{()}]\n```\n\nThe next are done incorrectly:\n```\n{(})\n([]\n[])\n```\n\nA correct string cannot close groups in the wrong order, open a group but fail to close it, or close a group before it is opened.\n\nYour function will take an input string that may contain any of the symbols `()`, `{}` or `[]` to create groups.\n\nIt should return `True` if the string is empty or otherwise grouped correctly, or `False` if it is grouped incorrectly.\n\"\"\"\n\n# ====== Solution ======\n\nBRACES = { '(': ')', '[': ']', '{': '}' }\n\ndef group_check(s):\n","entry_point":"group_check","test":"def check(candidate):\n    assert candidate('({})') == True\n    assert candidate('[[]()]') == True\n    assert candidate('[{()}]') == True\n    assert candidate('()') == True\n    assert candidate('([])') == True\n    assert candidate('{}([])') == True\n    assert candidate('{[{}[]()[]{}{}{}{}{}{}()()()()()()()()]{{{[[[((()))]]]}}}}(())[[]]{{}}[][][][][][][]({[]})') == True\n    assert candidate('') == True\n    assert candidate('{(})') == False\n    assert candidate('[{}{}())') == False\n    assert candidate('{)[}') == False\n    assert candidate('[[[]])') == False\n    assert candidate('()[]{]') == False\n    assert candidate('{([]})') == False\n    assert candidate('([]') == False\n    assert candidate('[])') == False\n    assert candidate('([]))') == False\n    assert candidate('{{{{{{{{{{{((((((([])))))))}}}}}}}}}}') == False\n\n","canonical_solution":"BRACES = { '(': ')', '[': ']', '{': '}' }\n\ndef group_check(s):\n    stack = []\n    for b in s:\n        c = BRACES.get(b)\n        if c:\n            stack.append(c)\n        elif not stack or stack.pop() != b:\n            return False\n    return not stack"}
{"task_id":4171,"prompt":"\"\"\"\n=====Problem statement====\n\n**This Kata is intended as a small challenge for my students**\n\nAll Star Code Challenge #16\n\nCreate a function called noRepeat() that takes a string argument and returns a single letter string of the **first** not repeated character in the entire string.\n\n``` haskell\nnoRepeat \"aabbccdde\" `shouldBe` 'e'\nnoRepeat \"wxyz\"      `shouldBe` 'w'\nnoRepeat \"testing\"   `shouldBe` 'e'\n```\n\nNote:\nONLY letters from the english alphabet will be used as input\nThere will ALWAYS be at least one non-repeating letter in the input string\n\"\"\"\n\n# ====== Solution ======\n\ndef no_repeat(s):\n","entry_point":"no_repeat","test":"def check(candidate):\n    assert candidate('aabbccdde') == 'e'\n    assert candidate('wxyz') == 'w'\n    assert candidate('testing') == 'e'\n    assert candidate('codewars') == 'c'\n    assert candidate('Testing') == 'T'\n\n","canonical_solution":"def no_repeat(s):\n    return next(c for c in s if s.count(c) == 1)"}
{"task_id":4174,"prompt":"\"\"\"\n=====Problem statement====\n\n2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.\nTask:\nWrite\n```\nsmallest(n)\n```\nthat will find the smallest positive number that is evenly divisible by all of the numbers from 1 to n (n <= 40). \nE.g\n```python\nsmallest(5) == 60 # 1 to 5 can all divide evenly into 60\nsmallest(10) == 2520\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef smallest(n):\n","entry_point":"smallest","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 2\n    assert candidate(3) == 6\n    assert candidate(4) == 12\n    assert candidate(5) == 60\n    assert candidate(6) == 60\n    assert candidate(7) == 420\n    assert candidate(8) == 840\n    assert candidate(9) == 2520\n    assert candidate(10) == 2520\n    assert candidate(11) == 27720\n    assert candidate(12) == 27720\n    assert candidate(13) == 360360\n    assert candidate(14) == 360360\n    assert candidate(15) == 360360\n    assert candidate(16) == 720720\n    assert candidate(17) == 12252240\n    assert candidate(18) == 12252240\n    assert candidate(19) == 232792560\n    assert candidate(20) == 232792560\n\n","canonical_solution":"def smallest(n):\n    x, y, m = 1, 1, 1\n    while m <= n:\n        if x % m == 0:\n            m += 1\n            y = int(x)\n        else:\n            x += y\n    return x\n"}
{"task_id":4181,"prompt":"\"\"\"\n=====Problem statement====\n\nFailed Filter - Bug Fixing #3\nOh no, Timmy's filter doesn't seem to be working? Your task is to fix the FilterNumber function to remove all the numbers from the string.\n\"\"\"\n\n# ====== Solution ======\n\ndef filter_numbers(string):\n","entry_point":"filter_numbers","test":"def check(candidate):\n    assert candidate('test123') == 'test'\n    assert candidate('a1b2c3') == 'abc'\n    assert candidate('aa1bb2cc3dd') == 'aabbccdd'\n    assert candidate('CodeWars') == 'CodeWars'\n    assert candidate('99234') == ''\n\n","canonical_solution":"def filter_numbers(string):\n    return \"\".join(x for x in string if not x.isdigit())"}
{"task_id":4182,"prompt":"\"\"\"\n=====Problem statement====\n\n# Task\n Changu and Mangu are great buddies. Once they found an infinite paper which had 1,2,3,4,5,6,7,8,......... till infinity, written on it.\n\n Both of them did not like the sequence and started deleting some numbers in the following way.\n ```\nFirst they deleted every 2nd number.\nSo remaining numbers on the paper: 1,3,5,7,9,11..........till infinity.\nThen they deleted every 3rd number.\nSo remaining numbers on the paper: 1,3,7,9,13,15..........till infinity..\nThen they deleted every 4th number.\nSo remaining numbers on the paper: 1,3,7,13,15..........till infinity.```\nThen kept on doing this (deleting every 5th, then every 6th ...) untill they got old and died.\n\n It is obvious that some of the numbers will never get deleted(E.g. 1,3,7,13..) and hence are know to us as survivor numbers.\n\n Given a number `n`, check whether its a survivor number or not.\n\n# Input\/Output\n\n\n - `[input]` integer `n`\n\n  `0 < n <= 10^8`\n\n \n - `[output]` a boolean value\n\n  `true` if the number is a survivor else `false`.\n\"\"\"\n\n# ====== Solution ======\n\ndef survivor(n):\n","entry_point":"survivor","test":"def check(candidate):\n    assert candidate(1) == True\n    assert candidate(5) == False\n    assert candidate(8) == False\n    assert candidate(9) == False\n    assert candidate(13) == True\n    assert candidate(15) == False\n    assert candidate(134) == False\n    assert candidate(289) == True\n\n","canonical_solution":"def survivor(n):\n    k = 2\n    while n >= k and n % k:\n        n -= n \/\/ k\n        k += 1\n    return n % k > 0"}
{"task_id":4188,"prompt":"\"\"\"\n=====Problem statement====\n\nSpin-off of this kata, here you will have to figure out an efficient strategy to solve the problem of finding the sole duplicate number among an unsorted array\/list of numbers starting from 1 up to n.\n\nHints: a solution in linear time can be found; using the most intuitive ones to search for duplicates that can run in O(n\u00b2) time won't work.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_dup(arr):\n","entry_point":"find_dup","test":"def check(candidate):\n    assert candidate([1, 1, 2, 3]) == 1\n    assert candidate([1, 2, 2, 3]) == 2\n    assert candidate([5, 4, 3, 2, 1, 1]) == 1\n    assert candidate([1, 3, 2, 5, 4, 5, 7, 6]) == 5\n    assert candidate([8, 2, 6, 3, 7, 2, 5, 1, 4]) == 2\n\n","canonical_solution":"def find_dup(arr):\n    return sum(arr) - sum(range(1, max(arr)+1))"}
{"task_id":4190,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function `isAlt()` that accepts a string as an argument and validates whether the vowels (a, e, i, o, u) and consonants are in alternate order.\n\n```python\nis_alt(\"amazon\")\n\/\/ true\nis_alt(\"apple\")\n\/\/ false\nis_alt(\"banana\")\n\/\/ true\n```\n\nArguments consist of only lowercase letters.\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\ndef is_alt(s):\n","entry_point":"is_alt","test":"def check(candidate):\n    assert candidate('amazon') == True\n    assert candidate('apple') == False\n    assert candidate('banana') == True\n    assert candidate('orange') == False\n    assert candidate('helipad') == True\n    assert candidate('yay') == True\n\n","canonical_solution":"import re\n\ndef is_alt(s):\n    return not re.search('[aeiou]{2}|[^aeiou]{2}',s)"}
{"task_id":4196,"prompt":"\"\"\"\n=====Problem statement====\n\n# Summation Of Primes\n\nThe sum of the primes below or equal to 10 is **2 + 3 + 5 + 7 = 17**. Find the sum of all the primes **_below or equal to the number passed in_**.\n\nFrom Project Euler's [Problem #10](https:\/\/projecteuler.net\/problem=10 \"Project Euler - Problem 10\").\n\"\"\"\n\n# ====== Solution ======\n\nfrom bisect import bisect\n\ndef sieve(n):\n    sieve, primes = [0]*(n+1), []\n    for i in range(2, n+1):\n        if not sieve[i]:\n            primes.append(i) \n            for j in range(i**2, n+1, i): sieve[j] = 1\n    return primes\n\nPRIMES = sieve(1000000)\n\ndef summationOfPrimes(n):\n","entry_point":"summationOfPrimes","test":"def check(candidate):\n    assert candidate(5) == 10\n    assert candidate(6) == 10\n    assert candidate(7) == 17\n    assert candidate(8) == 17\n    assert candidate(9) == 17\n    assert candidate(10) == 17\n    assert candidate(20) == 77\n    assert candidate(30) == 129\n    assert candidate(40) == 197\n    assert candidate(50) == 328\n    assert candidate(100) == 1060\n    assert candidate(200) == 4227\n    assert candidate(300) == 8275\n    assert candidate(400) == 13887\n    assert candidate(500) == 21536\n    assert candidate(1000) == 76127\n    assert candidate(2000) == 277050\n    assert candidate(3000) == 593823\n    assert candidate(4000) == 1013507\n    assert candidate(5000) == 1548136\n    assert candidate(25000) == 32405717\n\n","canonical_solution":"from bisect import bisect\n\ndef sieve(n):\n    sieve, primes = [0]*(n+1), []\n    for i in range(2, n+1):\n        if not sieve[i]:\n            primes.append(i) \n            for j in range(i**2, n+1, i): sieve[j] = 1\n    return primes\n\nPRIMES = sieve(1000000)\n\ndef summationOfPrimes(n):\n    return sum(PRIMES[:bisect(PRIMES, n)])"}
{"task_id":4219,"prompt":"\"\"\"\n=====Problem statement====\n\nImagine that you are given two sticks. You want to end up with three sticks of equal length. You are allowed to cut either or both of the sticks to accomplish this, and can throw away leftover pieces.\n\nWrite a function, maxlen, that takes the lengths of the two sticks (L1 and L2, both positive values), that will return the maximum length you can make the three sticks.\n\"\"\"\n\n# ====== Solution ======\n\ndef maxlen(s1, s2):\n","entry_point":"maxlen","test":"def check(candidate):\n    assert candidate(5,12) == 5\n    assert candidate(12,5) == 5\n    assert candidate(5,17) == 5.666666666666667\n    assert candidate(17,5) == 5.666666666666667\n    assert candidate(7,12) == 6.0\n    assert candidate(12,7) == 6.0\n\n","canonical_solution":"def maxlen(s1, s2):\n    sm, lg = sorted((s1, s2))\n    return min(max(lg \/ 3, sm), lg \/ 2)"}
{"task_id":4220,"prompt":"\"\"\"\n=====Problem statement====\n\nA triangle is called an equable triangle if its area equals its perimeter. Return `true`, if it is an equable triangle, else return `false`. You will be provided with the length of sides of the triangle. Happy Coding!\n\"\"\"\n\n# ====== Solution ======\n\ndef equable_triangle(a, b, c):\n","entry_point":"equable_triangle","test":"def check(candidate):\n    assert candidate(5,12,13) == True\n    assert candidate(2,3,4) == False\n    assert candidate(6,8,10) == True\n    assert candidate(7,15,20) == True\n    assert candidate(17,17,30) == False\n    assert candidate(7,10,12) == False\n    assert candidate(6,11,12) == False\n    assert candidate(25,25,45) == False\n    assert candidate(13,37,30) == False\n    assert candidate(6,25,29) == True\n    assert candidate(10,11,18) == False\n    assert candidate(73,9,80) == False\n    assert candidate(12,35,37) == False\n    assert candidate(120,109,13) == False\n    assert candidate(9,10,17) == True\n\n","canonical_solution":"def equable_triangle(a, b, c):\n    p = a + b + c\n    ph = p \/ 2\n    return p * p == ph * (ph - a) * (ph - b) * (ph - c)"}
{"task_id":4221,"prompt":"\"\"\"\n=====Problem statement====\n\nFrom Wikipedia : \"The n-back task is a continuous performance task that is commonly used as an assessment in cognitive neuroscience to measure a part of working memory and working memory capacity. [...] The subject is presented with a sequence of stimuli, and the task consists of indicating when the current stimulus matches the one from n steps earlier in the sequence. The load factor n can be adjusted to make the task more or less difficult.\"\n\nIn this kata, your task is to \"teach\" your computer to do the n-back task. Specifically, you will be implementing a function that counts the number of \"targets\" (stimuli that match the one from n steps earlier) in a sequence of digits. Your function will take two parameters :\n\nn, a positive integer equal to the number of steps to look back to find a match\nsequence, a sequence of digits containing 0 or more targets\n\nA few hints :\n\nThe first digit in a sequence can never be a target\nTargets can be \"chained\" together (e.g., for n = 1 and sequence = [1, 1, 1], there are 2 targets)\n\"\"\"\n\n# ====== Solution ======\n\ndef count_targets(n, sequence):\n","entry_point":"count_targets","test":"def check(candidate):\n    assert candidate(1,[1, 1, 1, 1, 1]) == 4\n    assert candidate(2,[1, 1, 1, 1, 1]) == 3\n    assert candidate(1,[1, 2, 1, 2, 1]) == 0\n    assert candidate(2,[1, 2, 1, 2, 1]) == 3\n    assert candidate(9,[1, 2, 3, 4, 5, 6, 7, 8, 9, 1]) == 1\n    assert candidate(1,[]) == 0\n    assert candidate(1,[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1000\n    assert candidate(1000,[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) == 1\n\n","canonical_solution":"def count_targets(n, sequence):\n    return sum(a == b for a, b in zip(sequence, sequence[n:]))"}
{"task_id":4222,"prompt":"\"\"\"\n=====Problem statement====\n\n```if-not:julia,racket\nWrite a function that returns the total surface area and volume of a box as an array: `[area, volume]`\n```\n```if:julia\nWrite a function that returns the total surface area and volume of a box as a tuple: `(area, volume)`\n```\n```if:racket\nWrite a function that returns the total surface area and volume of a box as a list: `'(area, volume)`\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef get_size(w, h, d):\n","entry_point":"get_size","test":"def check(candidate):\n    assert candidate(4,2,6) == [88, 48]\n    assert candidate(1,1,1) == [6, 1]\n    assert candidate(1,2,1) == [10, 2]\n    assert candidate(1,2,2) == [16, 4]\n    assert candidate(10,10,10) == [600, 1000]\n\n","canonical_solution":"def get_size(w, h, d):\n    area = 2*(w*h + h*d + w*d)\n    volume = w*h*d\n    return [area, volume]"}
{"task_id":4237,"prompt":"\"\"\"\n=====Problem statement====\n\nConverting a 24-hour time like \"0830\" or \"2030\" to a 12-hour time (like \"8:30 am\" or \"8:30 pm\") sounds easy enough, right?  Well, let's see if you can do it!\n\nYou will have to define a function named \"to12hourtime\", and you will be given a four digit time string (in \"hhmm\" format) as input.\n\nYour task is to return a 12-hour time string in the form of \"h:mm am\" or \"h:mm pm\".  (Of course, the \"h\" part will be two digits if the hour is greater than 9.)\n\nIf you like this kata, try converting 12-hour time to 24-hour time:\n\nhttps:\/\/www.codewars.com\/kata\/converting-12-hour-time-to-24-hour-time\/train\/python\n\"\"\"\n\n# ====== Solution ======\n\nfrom datetime import datetime\n\ndef to12hourtime(t):\n","entry_point":"to12hourtime","test":"def check(candidate):\n    assert candidate('0000') == '12:00 am'\n    assert candidate('0001') == '12:01 am'\n    assert candidate('0002') == '12:02 am'\n    assert candidate('0003') == '12:03 am'\n    assert candidate('0004') == '12:04 am'\n    assert candidate('0005') == '12:05 am'\n    assert candidate('0006') == '12:06 am'\n    assert candidate('0007') == '12:07 am'\n    assert candidate('0008') == '12:08 am'\n    assert candidate('0009') == '12:09 am'\n    assert candidate('0010') == '12:10 am'\n    assert candidate('0011') == '12:11 am'\n    assert candidate('0012') == '12:12 am'\n    assert candidate('0013') == '12:13 am'\n    assert candidate('0014') == '12:14 am'\n    assert candidate('0015') == '12:15 am'\n    assert candidate('0016') == '12:16 am'\n    assert candidate('0017') == '12:17 am'\n    assert candidate('0018') == '12:18 am'\n    assert candidate('0019') == '12:19 am'\n    assert candidate('0020') == '12:20 am'\n    assert candidate('0021') == '12:21 am'\n    assert candidate('0022') == '12:22 am'\n    assert candidate('0023') == '12:23 am'\n    assert candidate('0024') == '12:24 am'\n    assert candidate('0025') == '12:25 am'\n    assert candidate('0026') == '12:26 am'\n    assert candidate('0027') == '12:27 am'\n    assert candidate('0028') == '12:28 am'\n    assert candidate('0029') == '12:29 am'\n    assert candidate('0030') == '12:30 am'\n    assert candidate('0031') == '12:31 am'\n    assert candidate('0032') == '12:32 am'\n    assert candidate('0033') == '12:33 am'\n    assert candidate('0034') == '12:34 am'\n    assert candidate('0035') == '12:35 am'\n    assert candidate('0036') == '12:36 am'\n    assert candidate('0037') == '12:37 am'\n    assert candidate('0038') == '12:38 am'\n    assert candidate('0039') == '12:39 am'\n    assert candidate('0040') == '12:40 am'\n    assert candidate('0041') == '12:41 am'\n    assert candidate('0042') == '12:42 am'\n    assert candidate('0043') == '12:43 am'\n    assert candidate('0044') == '12:44 am'\n    assert candidate('0045') == '12:45 am'\n    assert candidate('0046') == '12:46 am'\n    assert candidate('0047') == '12:47 am'\n    assert candidate('0048') == '12:48 am'\n    assert candidate('0049') == '12:49 am'\n    assert candidate('0050') == '12:50 am'\n    assert candidate('0051') == '12:51 am'\n    assert candidate('0052') == '12:52 am'\n    assert candidate('0053') == '12:53 am'\n    assert candidate('0054') == '12:54 am'\n    assert candidate('0055') == '12:55 am'\n    assert candidate('0056') == '12:56 am'\n    assert candidate('0057') == '12:57 am'\n    assert candidate('0058') == '12:58 am'\n    assert candidate('0059') == '12:59 am'\n    assert candidate('0100') == '1:00 am'\n    assert candidate('0101') == '1:01 am'\n    assert candidate('0102') == '1:02 am'\n    assert candidate('0103') == '1:03 am'\n    assert candidate('0104') == '1:04 am'\n    assert candidate('0105') == '1:05 am'\n    assert candidate('0106') == '1:06 am'\n    assert candidate('0107') == '1:07 am'\n    assert candidate('0108') == '1:08 am'\n    assert candidate('0109') == '1:09 am'\n    assert candidate('0110') == '1:10 am'\n    assert candidate('0111') == '1:11 am'\n    assert candidate('0112') == '1:12 am'\n    assert candidate('0113') == '1:13 am'\n    assert candidate('0114') == '1:14 am'\n    assert candidate('0115') == '1:15 am'\n    assert candidate('0116') == '1:16 am'\n    assert candidate('0117') == '1:17 am'\n    assert candidate('0118') == '1:18 am'\n    assert candidate('0119') == '1:19 am'\n    assert candidate('0120') == '1:20 am'\n    assert candidate('0121') == '1:21 am'\n    assert candidate('0122') == '1:22 am'\n    assert candidate('0123') == '1:23 am'\n    assert candidate('0124') == '1:24 am'\n    assert candidate('0125') == '1:25 am'\n    assert candidate('0126') == '1:26 am'\n    assert candidate('0127') == '1:27 am'\n    assert candidate('0128') == '1:28 am'\n    assert candidate('0129') == '1:29 am'\n    assert candidate('0130') == '1:30 am'\n    assert candidate('0131') == '1:31 am'\n    assert candidate('0132') == '1:32 am'\n    assert candidate('0133') == '1:33 am'\n    assert candidate('0134') == '1:34 am'\n    assert candidate('0135') == '1:35 am'\n    assert candidate('0136') == '1:36 am'\n    assert candidate('0137') == '1:37 am'\n    assert candidate('0138') == '1:38 am'\n    assert candidate('0139') == '1:39 am'\n    assert candidate('0140') == '1:40 am'\n    assert candidate('0141') == '1:41 am'\n    assert candidate('0142') == '1:42 am'\n    assert candidate('0143') == '1:43 am'\n    assert candidate('0144') == '1:44 am'\n    assert candidate('0145') == '1:45 am'\n    assert candidate('0146') == '1:46 am'\n    assert candidate('0147') == '1:47 am'\n    assert candidate('0148') == '1:48 am'\n    assert candidate('0149') == '1:49 am'\n    assert candidate('0150') == '1:50 am'\n    assert candidate('0151') == '1:51 am'\n    assert candidate('0152') == '1:52 am'\n    assert candidate('0153') == '1:53 am'\n    assert candidate('0154') == '1:54 am'\n    assert candidate('0155') == '1:55 am'\n    assert candidate('0156') == '1:56 am'\n    assert candidate('0157') == '1:57 am'\n    assert candidate('0158') == '1:58 am'\n    assert candidate('0159') == '1:59 am'\n    assert candidate('0200') == '2:00 am'\n    assert candidate('0201') == '2:01 am'\n    assert candidate('0202') == '2:02 am'\n    assert candidate('0203') == '2:03 am'\n    assert candidate('0204') == '2:04 am'\n    assert candidate('0205') == '2:05 am'\n    assert candidate('0206') == '2:06 am'\n    assert candidate('0207') == '2:07 am'\n    assert candidate('0208') == '2:08 am'\n    assert candidate('0209') == '2:09 am'\n    assert candidate('0210') == '2:10 am'\n    assert candidate('0211') == '2:11 am'\n    assert candidate('0212') == '2:12 am'\n    assert candidate('0213') == '2:13 am'\n    assert candidate('0214') == '2:14 am'\n    assert candidate('0215') == '2:15 am'\n    assert candidate('0216') == '2:16 am'\n    assert candidate('0217') == '2:17 am'\n    assert candidate('0218') == '2:18 am'\n    assert candidate('0219') == '2:19 am'\n    assert candidate('0220') == '2:20 am'\n    assert candidate('0221') == '2:21 am'\n    assert candidate('0222') == '2:22 am'\n    assert candidate('0223') == '2:23 am'\n    assert candidate('0224') == '2:24 am'\n    assert candidate('0225') == '2:25 am'\n    assert candidate('0226') == '2:26 am'\n    assert candidate('0227') == '2:27 am'\n    assert candidate('0228') == '2:28 am'\n    assert candidate('0229') == '2:29 am'\n    assert candidate('0230') == '2:30 am'\n    assert candidate('0231') == '2:31 am'\n    assert candidate('0232') == '2:32 am'\n    assert candidate('0233') == '2:33 am'\n    assert candidate('0234') == '2:34 am'\n    assert candidate('0235') == '2:35 am'\n    assert candidate('0236') == '2:36 am'\n    assert candidate('0237') == '2:37 am'\n    assert candidate('0238') == '2:38 am'\n    assert candidate('0239') == '2:39 am'\n    assert candidate('0240') == '2:40 am'\n    assert candidate('0241') == '2:41 am'\n    assert candidate('0242') == '2:42 am'\n    assert candidate('0243') == '2:43 am'\n    assert candidate('0244') == '2:44 am'\n    assert candidate('0245') == '2:45 am'\n    assert candidate('0246') == '2:46 am'\n    assert candidate('0247') == '2:47 am'\n    assert candidate('0248') == '2:48 am'\n    assert candidate('0249') == '2:49 am'\n    assert candidate('0250') == '2:50 am'\n    assert candidate('0251') == '2:51 am'\n    assert candidate('0252') == '2:52 am'\n    assert candidate('0253') == '2:53 am'\n    assert candidate('0254') == '2:54 am'\n    assert candidate('0255') == '2:55 am'\n    assert candidate('0256') == '2:56 am'\n    assert candidate('0257') == '2:57 am'\n    assert candidate('0258') == '2:58 am'\n    assert candidate('0259') == '2:59 am'\n    assert candidate('0300') == '3:00 am'\n    assert candidate('0301') == '3:01 am'\n    assert candidate('0302') == '3:02 am'\n    assert candidate('0303') == '3:03 am'\n    assert candidate('0304') == '3:04 am'\n    assert candidate('0305') == '3:05 am'\n    assert candidate('0306') == '3:06 am'\n    assert candidate('0307') == '3:07 am'\n    assert candidate('0308') == '3:08 am'\n    assert candidate('0309') == '3:09 am'\n    assert candidate('0310') == '3:10 am'\n    assert candidate('0311') == '3:11 am'\n    assert candidate('0312') == '3:12 am'\n    assert candidate('0313') == '3:13 am'\n    assert candidate('0314') == '3:14 am'\n    assert candidate('0315') == '3:15 am'\n    assert candidate('0316') == '3:16 am'\n    assert candidate('0317') == '3:17 am'\n    assert candidate('0318') == '3:18 am'\n    assert candidate('0319') == '3:19 am'\n    assert candidate('0320') == '3:20 am'\n    assert candidate('0321') == '3:21 am'\n    assert candidate('0322') == '3:22 am'\n    assert candidate('0323') == '3:23 am'\n    assert candidate('0324') == '3:24 am'\n    assert candidate('0325') == '3:25 am'\n    assert candidate('0326') == '3:26 am'\n    assert candidate('0327') == '3:27 am'\n    assert candidate('0328') == '3:28 am'\n    assert candidate('0329') == '3:29 am'\n    assert candidate('0330') == '3:30 am'\n    assert candidate('0331') == '3:31 am'\n    assert candidate('0332') == '3:32 am'\n    assert candidate('0333') == '3:33 am'\n    assert candidate('0334') == '3:34 am'\n    assert candidate('0335') == '3:35 am'\n    assert candidate('0336') == '3:36 am'\n    assert candidate('0337') == '3:37 am'\n    assert candidate('0338') == '3:38 am'\n    assert candidate('0339') == '3:39 am'\n    assert candidate('0340') == '3:40 am'\n    assert candidate('0341') == '3:41 am'\n    assert candidate('0342') == '3:42 am'\n    assert candidate('0343') == '3:43 am'\n    assert candidate('0344') == '3:44 am'\n    assert candidate('0345') == '3:45 am'\n    assert candidate('0346') == '3:46 am'\n    assert candidate('0347') == '3:47 am'\n    assert candidate('0348') == '3:48 am'\n    assert candidate('0349') == '3:49 am'\n    assert candidate('0350') == '3:50 am'\n    assert candidate('0351') == '3:51 am'\n    assert candidate('0352') == '3:52 am'\n    assert candidate('0353') == '3:53 am'\n    assert candidate('0354') == '3:54 am'\n    assert candidate('0355') == '3:55 am'\n    assert candidate('0356') == '3:56 am'\n    assert candidate('0357') == '3:57 am'\n    assert candidate('0358') == '3:58 am'\n    assert candidate('0359') == '3:59 am'\n    assert candidate('0400') == '4:00 am'\n    assert candidate('0401') == '4:01 am'\n    assert candidate('0402') == '4:02 am'\n    assert candidate('0403') == '4:03 am'\n    assert candidate('0404') == '4:04 am'\n    assert candidate('0405') == '4:05 am'\n    assert candidate('0406') == '4:06 am'\n    assert candidate('0407') == '4:07 am'\n    assert candidate('0408') == '4:08 am'\n    assert candidate('0409') == '4:09 am'\n    assert candidate('0410') == '4:10 am'\n    assert candidate('0411') == '4:11 am'\n    assert candidate('0412') == '4:12 am'\n    assert candidate('0413') == '4:13 am'\n    assert candidate('0414') == '4:14 am'\n    assert candidate('0415') == '4:15 am'\n    assert candidate('0416') == '4:16 am'\n    assert candidate('0417') == '4:17 am'\n    assert candidate('0418') == '4:18 am'\n    assert candidate('0419') == '4:19 am'\n    assert candidate('0420') == '4:20 am'\n    assert candidate('0421') == '4:21 am'\n    assert candidate('0422') == '4:22 am'\n    assert candidate('0423') == '4:23 am'\n    assert candidate('0424') == '4:24 am'\n    assert candidate('0425') == '4:25 am'\n    assert candidate('0426') == '4:26 am'\n    assert candidate('0427') == '4:27 am'\n    assert candidate('0428') == '4:28 am'\n    assert candidate('0429') == '4:29 am'\n    assert candidate('0430') == '4:30 am'\n    assert candidate('0431') == '4:31 am'\n    assert candidate('0432') == '4:32 am'\n    assert candidate('0433') == '4:33 am'\n    assert candidate('0434') == '4:34 am'\n    assert candidate('0435') == '4:35 am'\n    assert candidate('0436') == '4:36 am'\n    assert candidate('0437') == '4:37 am'\n    assert candidate('0438') == '4:38 am'\n    assert candidate('0439') == '4:39 am'\n    assert candidate('0440') == '4:40 am'\n    assert candidate('0441') == '4:41 am'\n    assert candidate('0442') == '4:42 am'\n    assert candidate('0443') == '4:43 am'\n    assert candidate('0444') == '4:44 am'\n    assert candidate('0445') == '4:45 am'\n    assert candidate('0446') == '4:46 am'\n    assert candidate('0447') == '4:47 am'\n    assert candidate('0448') == '4:48 am'\n    assert candidate('0449') == '4:49 am'\n    assert candidate('0450') == '4:50 am'\n    assert candidate('0451') == '4:51 am'\n    assert candidate('0452') == '4:52 am'\n    assert candidate('0453') == '4:53 am'\n    assert candidate('0454') == '4:54 am'\n    assert candidate('0455') == '4:55 am'\n    assert candidate('0456') == '4:56 am'\n    assert candidate('0457') == '4:57 am'\n    assert candidate('0458') == '4:58 am'\n    assert candidate('0459') == '4:59 am'\n    assert candidate('0500') == '5:00 am'\n    assert candidate('0501') == '5:01 am'\n    assert candidate('0502') == '5:02 am'\n    assert candidate('0503') == '5:03 am'\n    assert candidate('0504') == '5:04 am'\n    assert candidate('0505') == '5:05 am'\n    assert candidate('0506') == '5:06 am'\n    assert candidate('0507') == '5:07 am'\n    assert candidate('0508') == '5:08 am'\n    assert candidate('0509') == '5:09 am'\n    assert candidate('0510') == '5:10 am'\n    assert candidate('0511') == '5:11 am'\n    assert candidate('0512') == '5:12 am'\n    assert candidate('0513') == '5:13 am'\n    assert candidate('0514') == '5:14 am'\n    assert candidate('0515') == '5:15 am'\n    assert candidate('0516') == '5:16 am'\n    assert candidate('0517') == '5:17 am'\n    assert candidate('0518') == '5:18 am'\n    assert candidate('0519') == '5:19 am'\n    assert candidate('0520') == '5:20 am'\n    assert candidate('0521') == '5:21 am'\n    assert candidate('0522') == '5:22 am'\n    assert candidate('0523') == '5:23 am'\n    assert candidate('0524') == '5:24 am'\n    assert candidate('0525') == '5:25 am'\n    assert candidate('0526') == '5:26 am'\n    assert candidate('0527') == '5:27 am'\n    assert candidate('0528') == '5:28 am'\n    assert candidate('0529') == '5:29 am'\n    assert candidate('0530') == '5:30 am'\n    assert candidate('0531') == '5:31 am'\n    assert candidate('0532') == '5:32 am'\n    assert candidate('0533') == '5:33 am'\n    assert candidate('0534') == '5:34 am'\n    assert candidate('0535') == '5:35 am'\n    assert candidate('0536') == '5:36 am'\n    assert candidate('0537') == '5:37 am'\n    assert candidate('0538') == '5:38 am'\n    assert candidate('0539') == '5:39 am'\n    assert candidate('0540') == '5:40 am'\n    assert candidate('0541') == '5:41 am'\n    assert candidate('0542') == '5:42 am'\n    assert candidate('0543') == '5:43 am'\n    assert candidate('0544') == '5:44 am'\n    assert candidate('0545') == '5:45 am'\n    assert candidate('0546') == '5:46 am'\n    assert candidate('0547') == '5:47 am'\n    assert candidate('0548') == '5:48 am'\n    assert candidate('0549') == '5:49 am'\n    assert candidate('0550') == '5:50 am'\n    assert candidate('0551') == '5:51 am'\n    assert candidate('0552') == '5:52 am'\n    assert candidate('0553') == '5:53 am'\n    assert candidate('0554') == '5:54 am'\n    assert candidate('0555') == '5:55 am'\n    assert candidate('0556') == '5:56 am'\n    assert candidate('0557') == '5:57 am'\n    assert candidate('0558') == '5:58 am'\n    assert candidate('0559') == '5:59 am'\n    assert candidate('0600') == '6:00 am'\n    assert candidate('0601') == '6:01 am'\n    assert candidate('0602') == '6:02 am'\n    assert candidate('0603') == '6:03 am'\n    assert candidate('0604') == '6:04 am'\n    assert candidate('0605') == '6:05 am'\n    assert candidate('0606') == '6:06 am'\n    assert candidate('0607') == '6:07 am'\n    assert candidate('0608') == '6:08 am'\n    assert candidate('0609') == '6:09 am'\n    assert candidate('0610') == '6:10 am'\n    assert candidate('0611') == '6:11 am'\n    assert candidate('0612') == '6:12 am'\n    assert candidate('0613') == '6:13 am'\n    assert candidate('0614') == '6:14 am'\n    assert candidate('0615') == '6:15 am'\n    assert candidate('0616') == '6:16 am'\n    assert candidate('0617') == '6:17 am'\n    assert candidate('0618') == '6:18 am'\n    assert candidate('0619') == '6:19 am'\n    assert candidate('0620') == '6:20 am'\n    assert candidate('0621') == '6:21 am'\n    assert candidate('0622') == '6:22 am'\n    assert candidate('0623') == '6:23 am'\n    assert candidate('0624') == '6:24 am'\n    assert candidate('0625') == '6:25 am'\n    assert candidate('0626') == '6:26 am'\n    assert candidate('0627') == '6:27 am'\n    assert candidate('0628') == '6:28 am'\n    assert candidate('0629') == '6:29 am'\n    assert candidate('0630') == '6:30 am'\n    assert candidate('0631') == '6:31 am'\n    assert candidate('0632') == '6:32 am'\n    assert candidate('0633') == '6:33 am'\n    assert candidate('0634') == '6:34 am'\n    assert candidate('0635') == '6:35 am'\n    assert candidate('0636') == '6:36 am'\n    assert candidate('0637') == '6:37 am'\n    assert candidate('0638') == '6:38 am'\n    assert candidate('0639') == '6:39 am'\n    assert candidate('0640') == '6:40 am'\n    assert candidate('0641') == '6:41 am'\n    assert candidate('0642') == '6:42 am'\n    assert candidate('0643') == '6:43 am'\n    assert candidate('0644') == '6:44 am'\n    assert candidate('0645') == '6:45 am'\n    assert candidate('0646') == '6:46 am'\n    assert candidate('0647') == '6:47 am'\n    assert candidate('0648') == '6:48 am'\n    assert candidate('0649') == '6:49 am'\n    assert candidate('0650') == '6:50 am'\n    assert candidate('0651') == '6:51 am'\n    assert candidate('0652') == '6:52 am'\n    assert candidate('0653') == '6:53 am'\n    assert candidate('0654') == '6:54 am'\n    assert candidate('0655') == '6:55 am'\n    assert candidate('0656') == '6:56 am'\n    assert candidate('0657') == '6:57 am'\n    assert candidate('0658') == '6:58 am'\n    assert candidate('0659') == '6:59 am'\n    assert candidate('0700') == '7:00 am'\n    assert candidate('0701') == '7:01 am'\n    assert candidate('0702') == '7:02 am'\n    assert candidate('0703') == '7:03 am'\n    assert candidate('0704') == '7:04 am'\n    assert candidate('0705') == '7:05 am'\n    assert candidate('0706') == '7:06 am'\n    assert candidate('0707') == '7:07 am'\n    assert candidate('0708') == '7:08 am'\n    assert candidate('0709') == '7:09 am'\n    assert candidate('0710') == '7:10 am'\n    assert candidate('0711') == '7:11 am'\n    assert candidate('0712') == '7:12 am'\n    assert candidate('0713') == '7:13 am'\n    assert candidate('0714') == '7:14 am'\n    assert candidate('0715') == '7:15 am'\n    assert candidate('0716') == '7:16 am'\n    assert candidate('0717') == '7:17 am'\n    assert candidate('0718') == '7:18 am'\n    assert candidate('0719') == '7:19 am'\n    assert candidate('0720') == '7:20 am'\n    assert candidate('0721') == '7:21 am'\n    assert candidate('0722') == '7:22 am'\n    assert candidate('0723') == '7:23 am'\n    assert candidate('0724') == '7:24 am'\n    assert candidate('0725') == '7:25 am'\n    assert candidate('0726') == '7:26 am'\n    assert candidate('0727') == '7:27 am'\n    assert candidate('0728') == '7:28 am'\n    assert candidate('0729') == '7:29 am'\n    assert candidate('0730') == '7:30 am'\n    assert candidate('0731') == '7:31 am'\n    assert candidate('0732') == '7:32 am'\n    assert candidate('0733') == '7:33 am'\n    assert candidate('0734') == '7:34 am'\n    assert candidate('0735') == '7:35 am'\n    assert candidate('0736') == '7:36 am'\n    assert candidate('0737') == '7:37 am'\n    assert candidate('0738') == '7:38 am'\n    assert candidate('0739') == '7:39 am'\n    assert candidate('0740') == '7:40 am'\n    assert candidate('0741') == '7:41 am'\n    assert candidate('0742') == '7:42 am'\n    assert candidate('0743') == '7:43 am'\n    assert candidate('0744') == '7:44 am'\n    assert candidate('0745') == '7:45 am'\n    assert candidate('0746') == '7:46 am'\n    assert candidate('0747') == '7:47 am'\n    assert candidate('0748') == '7:48 am'\n    assert candidate('0749') == '7:49 am'\n    assert candidate('0750') == '7:50 am'\n    assert candidate('0751') == '7:51 am'\n    assert candidate('0752') == '7:52 am'\n    assert candidate('0753') == '7:53 am'\n    assert candidate('0754') == '7:54 am'\n    assert candidate('0755') == '7:55 am'\n    assert candidate('0756') == '7:56 am'\n    assert candidate('0757') == '7:57 am'\n    assert candidate('0758') == '7:58 am'\n    assert candidate('0759') == '7:59 am'\n    assert candidate('0800') == '8:00 am'\n    assert candidate('0801') == '8:01 am'\n    assert candidate('0802') == '8:02 am'\n    assert candidate('0803') == '8:03 am'\n    assert candidate('0804') == '8:04 am'\n    assert candidate('0805') == '8:05 am'\n    assert candidate('0806') == '8:06 am'\n    assert candidate('0807') == '8:07 am'\n    assert candidate('0808') == '8:08 am'\n    assert candidate('0809') == '8:09 am'\n    assert candidate('0810') == '8:10 am'\n    assert candidate('0811') == '8:11 am'\n    assert candidate('0812') == '8:12 am'\n    assert candidate('0813') == '8:13 am'\n    assert candidate('0814') == '8:14 am'\n    assert candidate('0815') == '8:15 am'\n    assert candidate('0816') == '8:16 am'\n    assert candidate('0817') == '8:17 am'\n    assert candidate('0818') == '8:18 am'\n    assert candidate('0819') == '8:19 am'\n    assert candidate('0820') == '8:20 am'\n    assert candidate('0821') == '8:21 am'\n    assert candidate('0822') == '8:22 am'\n    assert candidate('0823') == '8:23 am'\n    assert candidate('0824') == '8:24 am'\n    assert candidate('0825') == '8:25 am'\n    assert candidate('0826') == '8:26 am'\n    assert candidate('0827') == '8:27 am'\n    assert candidate('0828') == '8:28 am'\n    assert candidate('0829') == '8:29 am'\n    assert candidate('0830') == '8:30 am'\n    assert candidate('0831') == '8:31 am'\n    assert candidate('0832') == '8:32 am'\n    assert candidate('0833') == '8:33 am'\n    assert candidate('0834') == '8:34 am'\n    assert candidate('0835') == '8:35 am'\n    assert candidate('0836') == '8:36 am'\n    assert candidate('0837') == '8:37 am'\n    assert candidate('0838') == '8:38 am'\n    assert candidate('0839') == '8:39 am'\n    assert candidate('0840') == '8:40 am'\n    assert candidate('0841') == '8:41 am'\n    assert candidate('0842') == '8:42 am'\n    assert candidate('0843') == '8:43 am'\n    assert candidate('0844') == '8:44 am'\n    assert candidate('0845') == '8:45 am'\n    assert candidate('0846') == '8:46 am'\n    assert candidate('0847') == '8:47 am'\n    assert candidate('0848') == '8:48 am'\n    assert candidate('0849') == '8:49 am'\n    assert candidate('0850') == '8:50 am'\n    assert candidate('0851') == '8:51 am'\n    assert candidate('0852') == '8:52 am'\n    assert candidate('0853') == '8:53 am'\n    assert candidate('0854') == '8:54 am'\n    assert candidate('0855') == '8:55 am'\n    assert candidate('0856') == '8:56 am'\n    assert candidate('0857') == '8:57 am'\n    assert candidate('0858') == '8:58 am'\n    assert candidate('0859') == '8:59 am'\n    assert candidate('0900') == '9:00 am'\n    assert candidate('0901') == '9:01 am'\n    assert candidate('0902') == '9:02 am'\n    assert candidate('0903') == '9:03 am'\n    assert candidate('0904') == '9:04 am'\n    assert candidate('0905') == '9:05 am'\n    assert candidate('0906') == '9:06 am'\n    assert candidate('0907') == '9:07 am'\n    assert candidate('0908') == '9:08 am'\n    assert candidate('0909') == '9:09 am'\n    assert candidate('0910') == '9:10 am'\n    assert candidate('0911') == '9:11 am'\n    assert candidate('0912') == '9:12 am'\n    assert candidate('0913') == '9:13 am'\n    assert candidate('0914') == '9:14 am'\n    assert candidate('0915') == '9:15 am'\n    assert candidate('0916') == '9:16 am'\n    assert candidate('0917') == '9:17 am'\n    assert candidate('0918') == '9:18 am'\n    assert candidate('0919') == '9:19 am'\n    assert candidate('0920') == '9:20 am'\n    assert candidate('0921') == '9:21 am'\n    assert candidate('0922') == '9:22 am'\n    assert candidate('0923') == '9:23 am'\n    assert candidate('0924') == '9:24 am'\n    assert candidate('0925') == '9:25 am'\n    assert candidate('0926') == '9:26 am'\n    assert candidate('0927') == '9:27 am'\n    assert candidate('0928') == '9:28 am'\n    assert candidate('0929') == '9:29 am'\n    assert candidate('0930') == '9:30 am'\n    assert candidate('0931') == '9:31 am'\n    assert candidate('0932') == '9:32 am'\n    assert candidate('0933') == '9:33 am'\n    assert candidate('0934') == '9:34 am'\n    assert candidate('0935') == '9:35 am'\n    assert candidate('0936') == '9:36 am'\n    assert candidate('0937') == '9:37 am'\n    assert candidate('0938') == '9:38 am'\n    assert candidate('0939') == '9:39 am'\n    assert candidate('0940') == '9:40 am'\n    assert candidate('0941') == '9:41 am'\n    assert candidate('0942') == '9:42 am'\n    assert candidate('0943') == '9:43 am'\n    assert candidate('0944') == '9:44 am'\n    assert candidate('0945') == '9:45 am'\n    assert candidate('0946') == '9:46 am'\n    assert candidate('0947') == '9:47 am'\n    assert candidate('0948') == '9:48 am'\n    assert candidate('0949') == '9:49 am'\n    assert candidate('0950') == '9:50 am'\n    assert candidate('0951') == '9:51 am'\n    assert candidate('0952') == '9:52 am'\n    assert candidate('0953') == '9:53 am'\n    assert candidate('0954') == '9:54 am'\n    assert candidate('0955') == '9:55 am'\n    assert candidate('0956') == '9:56 am'\n    assert candidate('0957') == '9:57 am'\n    assert candidate('0958') == '9:58 am'\n    assert candidate('0959') == '9:59 am'\n    assert candidate('1000') == '10:00 am'\n    assert candidate('1001') == '10:01 am'\n    assert candidate('1002') == '10:02 am'\n    assert candidate('1003') == '10:03 am'\n    assert candidate('1004') == '10:04 am'\n    assert candidate('1005') == '10:05 am'\n    assert candidate('1006') == '10:06 am'\n    assert candidate('1007') == '10:07 am'\n    assert candidate('1008') == '10:08 am'\n    assert candidate('1009') == '10:09 am'\n    assert candidate('1010') == '10:10 am'\n    assert candidate('1011') == '10:11 am'\n    assert candidate('1012') == '10:12 am'\n    assert candidate('1013') == '10:13 am'\n    assert candidate('1014') == '10:14 am'\n    assert candidate('1015') == '10:15 am'\n    assert candidate('1016') == '10:16 am'\n    assert candidate('1017') == '10:17 am'\n    assert candidate('1018') == '10:18 am'\n    assert candidate('1019') == '10:19 am'\n    assert candidate('1020') == '10:20 am'\n    assert candidate('1021') == '10:21 am'\n    assert candidate('1022') == '10:22 am'\n    assert candidate('1023') == '10:23 am'\n    assert candidate('1024') == '10:24 am'\n    assert candidate('1025') == '10:25 am'\n    assert candidate('1026') == '10:26 am'\n    assert candidate('1027') == '10:27 am'\n    assert candidate('1028') == '10:28 am'\n    assert candidate('1029') == '10:29 am'\n    assert candidate('1030') == '10:30 am'\n    assert candidate('1031') == '10:31 am'\n    assert candidate('1032') == '10:32 am'\n    assert candidate('1033') == '10:33 am'\n    assert candidate('1034') == '10:34 am'\n    assert candidate('1035') == '10:35 am'\n    assert candidate('1036') == '10:36 am'\n    assert candidate('1037') == '10:37 am'\n    assert candidate('1038') == '10:38 am'\n    assert candidate('1039') == '10:39 am'\n    assert candidate('1040') == '10:40 am'\n    assert candidate('1041') == '10:41 am'\n    assert candidate('1042') == '10:42 am'\n    assert candidate('1043') == '10:43 am'\n    assert candidate('1044') == '10:44 am'\n    assert candidate('1045') == '10:45 am'\n    assert candidate('1046') == '10:46 am'\n    assert candidate('1047') == '10:47 am'\n    assert candidate('1048') == '10:48 am'\n    assert candidate('1049') == '10:49 am'\n    assert candidate('1050') == '10:50 am'\n    assert candidate('1051') == '10:51 am'\n    assert candidate('1052') == '10:52 am'\n    assert candidate('1053') == '10:53 am'\n    assert candidate('1054') == '10:54 am'\n    assert candidate('1055') == '10:55 am'\n    assert candidate('1056') == '10:56 am'\n    assert candidate('1057') == '10:57 am'\n    assert candidate('1058') == '10:58 am'\n    assert candidate('1059') == '10:59 am'\n    assert candidate('1100') == '11:00 am'\n    assert candidate('1101') == '11:01 am'\n    assert candidate('1102') == '11:02 am'\n    assert candidate('1103') == '11:03 am'\n    assert candidate('1104') == '11:04 am'\n    assert candidate('1105') == '11:05 am'\n    assert candidate('1106') == '11:06 am'\n    assert candidate('1107') == '11:07 am'\n    assert candidate('1108') == '11:08 am'\n    assert candidate('1109') == '11:09 am'\n    assert candidate('1110') == '11:10 am'\n    assert candidate('1111') == '11:11 am'\n    assert candidate('1112') == '11:12 am'\n    assert candidate('1113') == '11:13 am'\n    assert candidate('1114') == '11:14 am'\n    assert candidate('1115') == '11:15 am'\n    assert candidate('1116') == '11:16 am'\n    assert candidate('1117') == '11:17 am'\n    assert candidate('1118') == '11:18 am'\n    assert candidate('1119') == '11:19 am'\n    assert candidate('1120') == '11:20 am'\n    assert candidate('1121') == '11:21 am'\n    assert candidate('1122') == '11:22 am'\n    assert candidate('1123') == '11:23 am'\n    assert candidate('1124') == '11:24 am'\n    assert candidate('1125') == '11:25 am'\n    assert candidate('1126') == '11:26 am'\n    assert candidate('1127') == '11:27 am'\n    assert candidate('1128') == '11:28 am'\n    assert candidate('1129') == '11:29 am'\n    assert candidate('1130') == '11:30 am'\n    assert candidate('1131') == '11:31 am'\n    assert candidate('1132') == '11:32 am'\n    assert candidate('1133') == '11:33 am'\n    assert candidate('1134') == '11:34 am'\n    assert candidate('1135') == '11:35 am'\n    assert candidate('1136') == '11:36 am'\n    assert candidate('1137') == '11:37 am'\n    assert candidate('1138') == '11:38 am'\n    assert candidate('1139') == '11:39 am'\n    assert candidate('1140') == '11:40 am'\n    assert candidate('1141') == '11:41 am'\n    assert candidate('1142') == '11:42 am'\n    assert candidate('1143') == '11:43 am'\n    assert candidate('1144') == '11:44 am'\n    assert candidate('1145') == '11:45 am'\n    assert candidate('1146') == '11:46 am'\n    assert candidate('1147') == '11:47 am'\n    assert candidate('1148') == '11:48 am'\n    assert candidate('1149') == '11:49 am'\n    assert candidate('1150') == '11:50 am'\n    assert candidate('1151') == '11:51 am'\n    assert candidate('1152') == '11:52 am'\n    assert candidate('1153') == '11:53 am'\n    assert candidate('1154') == '11:54 am'\n    assert candidate('1155') == '11:55 am'\n    assert candidate('1156') == '11:56 am'\n    assert candidate('1157') == '11:57 am'\n    assert candidate('1158') == '11:58 am'\n    assert candidate('1159') == '11:59 am'\n    assert candidate('1200') == '12:00 pm'\n    assert candidate('1201') == '12:01 pm'\n    assert candidate('1202') == '12:02 pm'\n    assert candidate('1203') == '12:03 pm'\n    assert candidate('1204') == '12:04 pm'\n    assert candidate('1205') == '12:05 pm'\n    assert candidate('1206') == '12:06 pm'\n    assert candidate('1207') == '12:07 pm'\n    assert candidate('1208') == '12:08 pm'\n    assert candidate('1209') == '12:09 pm'\n    assert candidate('1210') == '12:10 pm'\n    assert candidate('1211') == '12:11 pm'\n    assert candidate('1212') == '12:12 pm'\n    assert candidate('1213') == '12:13 pm'\n    assert candidate('1214') == '12:14 pm'\n    assert candidate('1215') == '12:15 pm'\n    assert candidate('1216') == '12:16 pm'\n    assert candidate('1217') == '12:17 pm'\n    assert candidate('1218') == '12:18 pm'\n    assert candidate('1219') == '12:19 pm'\n    assert candidate('1220') == '12:20 pm'\n    assert candidate('1221') == '12:21 pm'\n    assert candidate('1222') == '12:22 pm'\n    assert candidate('1223') == '12:23 pm'\n    assert candidate('1224') == '12:24 pm'\n    assert candidate('1225') == '12:25 pm'\n    assert candidate('1226') == '12:26 pm'\n    assert candidate('1227') == '12:27 pm'\n    assert candidate('1228') == '12:28 pm'\n    assert candidate('1229') == '12:29 pm'\n    assert candidate('1230') == '12:30 pm'\n    assert candidate('1231') == '12:31 pm'\n    assert candidate('1232') == '12:32 pm'\n    assert candidate('1233') == '12:33 pm'\n    assert candidate('1234') == '12:34 pm'\n    assert candidate('1235') == '12:35 pm'\n    assert candidate('1236') == '12:36 pm'\n    assert candidate('1237') == '12:37 pm'\n    assert candidate('1238') == '12:38 pm'\n    assert candidate('1239') == '12:39 pm'\n    assert candidate('1240') == '12:40 pm'\n    assert candidate('1241') == '12:41 pm'\n    assert candidate('1242') == '12:42 pm'\n    assert candidate('1243') == '12:43 pm'\n    assert candidate('1244') == '12:44 pm'\n    assert candidate('1245') == '12:45 pm'\n    assert candidate('1246') == '12:46 pm'\n    assert candidate('1247') == '12:47 pm'\n    assert candidate('1248') == '12:48 pm'\n    assert candidate('1249') == '12:49 pm'\n    assert candidate('1250') == '12:50 pm'\n    assert candidate('1251') == '12:51 pm'\n    assert candidate('1252') == '12:52 pm'\n    assert candidate('1253') == '12:53 pm'\n    assert candidate('1254') == '12:54 pm'\n    assert candidate('1255') == '12:55 pm'\n    assert candidate('1256') == '12:56 pm'\n    assert candidate('1257') == '12:57 pm'\n    assert candidate('1258') == '12:58 pm'\n    assert candidate('1259') == '12:59 pm'\n    assert candidate('1300') == '1:00 pm'\n    assert candidate('1301') == '1:01 pm'\n    assert candidate('1302') == '1:02 pm'\n    assert candidate('1303') == '1:03 pm'\n    assert candidate('1304') == '1:04 pm'\n    assert candidate('1305') == '1:05 pm'\n    assert candidate('1306') == '1:06 pm'\n    assert candidate('1307') == '1:07 pm'\n    assert candidate('1308') == '1:08 pm'\n    assert candidate('1309') == '1:09 pm'\n    assert candidate('1310') == '1:10 pm'\n    assert candidate('1311') == '1:11 pm'\n    assert candidate('1312') == '1:12 pm'\n    assert candidate('1313') == '1:13 pm'\n    assert candidate('1314') == '1:14 pm'\n    assert candidate('1315') == '1:15 pm'\n    assert candidate('1316') == '1:16 pm'\n    assert candidate('1317') == '1:17 pm'\n    assert candidate('1318') == '1:18 pm'\n    assert candidate('1319') == '1:19 pm'\n    assert candidate('1320') == '1:20 pm'\n    assert candidate('1321') == '1:21 pm'\n    assert candidate('1322') == '1:22 pm'\n    assert candidate('1323') == '1:23 pm'\n    assert candidate('1324') == '1:24 pm'\n    assert candidate('1325') == '1:25 pm'\n    assert candidate('1326') == '1:26 pm'\n    assert candidate('1327') == '1:27 pm'\n    assert candidate('1328') == '1:28 pm'\n    assert candidate('1329') == '1:29 pm'\n    assert candidate('1330') == '1:30 pm'\n    assert candidate('1331') == '1:31 pm'\n    assert candidate('1332') == '1:32 pm'\n    assert candidate('1333') == '1:33 pm'\n    assert candidate('1334') == '1:34 pm'\n    assert candidate('1335') == '1:35 pm'\n    assert candidate('1336') == '1:36 pm'\n    assert candidate('1337') == '1:37 pm'\n    assert candidate('1338') == '1:38 pm'\n    assert candidate('1339') == '1:39 pm'\n    assert candidate('1340') == '1:40 pm'\n    assert candidate('1341') == '1:41 pm'\n    assert candidate('1342') == '1:42 pm'\n    assert candidate('1343') == '1:43 pm'\n    assert candidate('1344') == '1:44 pm'\n    assert candidate('1345') == '1:45 pm'\n    assert candidate('1346') == '1:46 pm'\n    assert candidate('1347') == '1:47 pm'\n    assert candidate('1348') == '1:48 pm'\n    assert candidate('1349') == '1:49 pm'\n    assert candidate('1350') == '1:50 pm'\n    assert candidate('1351') == '1:51 pm'\n    assert candidate('1352') == '1:52 pm'\n    assert candidate('1353') == '1:53 pm'\n    assert candidate('1354') == '1:54 pm'\n    assert candidate('1355') == '1:55 pm'\n    assert candidate('1356') == '1:56 pm'\n    assert candidate('1357') == '1:57 pm'\n    assert candidate('1358') == '1:58 pm'\n    assert candidate('1359') == '1:59 pm'\n    assert candidate('1400') == '2:00 pm'\n    assert candidate('1401') == '2:01 pm'\n    assert candidate('1402') == '2:02 pm'\n    assert candidate('1403') == '2:03 pm'\n    assert candidate('1404') == '2:04 pm'\n    assert candidate('1405') == '2:05 pm'\n    assert candidate('1406') == '2:06 pm'\n    assert candidate('1407') == '2:07 pm'\n    assert candidate('1408') == '2:08 pm'\n    assert candidate('1409') == '2:09 pm'\n    assert candidate('1410') == '2:10 pm'\n    assert candidate('1411') == '2:11 pm'\n    assert candidate('1412') == '2:12 pm'\n    assert candidate('1413') == '2:13 pm'\n    assert candidate('1414') == '2:14 pm'\n    assert candidate('1415') == '2:15 pm'\n    assert candidate('1416') == '2:16 pm'\n    assert candidate('1417') == '2:17 pm'\n    assert candidate('1418') == '2:18 pm'\n    assert candidate('1419') == '2:19 pm'\n    assert candidate('1420') == '2:20 pm'\n    assert candidate('1421') == '2:21 pm'\n    assert candidate('1422') == '2:22 pm'\n    assert candidate('1423') == '2:23 pm'\n    assert candidate('1424') == '2:24 pm'\n    assert candidate('1425') == '2:25 pm'\n    assert candidate('1426') == '2:26 pm'\n    assert candidate('1427') == '2:27 pm'\n    assert candidate('1428') == '2:28 pm'\n    assert candidate('1429') == '2:29 pm'\n    assert candidate('1430') == '2:30 pm'\n    assert candidate('1431') == '2:31 pm'\n    assert candidate('1432') == '2:32 pm'\n    assert candidate('1433') == '2:33 pm'\n    assert candidate('1434') == '2:34 pm'\n    assert candidate('1435') == '2:35 pm'\n    assert candidate('1436') == '2:36 pm'\n    assert candidate('1437') == '2:37 pm'\n    assert candidate('1438') == '2:38 pm'\n    assert candidate('1439') == '2:39 pm'\n    assert candidate('1440') == '2:40 pm'\n    assert candidate('1441') == '2:41 pm'\n    assert candidate('1442') == '2:42 pm'\n    assert candidate('1443') == '2:43 pm'\n    assert candidate('1444') == '2:44 pm'\n    assert candidate('1445') == '2:45 pm'\n    assert candidate('1446') == '2:46 pm'\n    assert candidate('1447') == '2:47 pm'\n    assert candidate('1448') == '2:48 pm'\n    assert candidate('1449') == '2:49 pm'\n    assert candidate('1450') == '2:50 pm'\n    assert candidate('1451') == '2:51 pm'\n    assert candidate('1452') == '2:52 pm'\n    assert candidate('1453') == '2:53 pm'\n    assert candidate('1454') == '2:54 pm'\n    assert candidate('1455') == '2:55 pm'\n    assert candidate('1456') == '2:56 pm'\n    assert candidate('1457') == '2:57 pm'\n    assert candidate('1458') == '2:58 pm'\n    assert candidate('1459') == '2:59 pm'\n    assert candidate('1500') == '3:00 pm'\n    assert candidate('1501') == '3:01 pm'\n    assert candidate('1502') == '3:02 pm'\n    assert candidate('1503') == '3:03 pm'\n    assert candidate('1504') == '3:04 pm'\n    assert candidate('1505') == '3:05 pm'\n    assert candidate('1506') == '3:06 pm'\n    assert candidate('1507') == '3:07 pm'\n    assert candidate('1508') == '3:08 pm'\n    assert candidate('1509') == '3:09 pm'\n    assert candidate('1510') == '3:10 pm'\n    assert candidate('1511') == '3:11 pm'\n    assert candidate('1512') == '3:12 pm'\n    assert candidate('1513') == '3:13 pm'\n    assert candidate('1514') == '3:14 pm'\n    assert candidate('1515') == '3:15 pm'\n    assert candidate('1516') == '3:16 pm'\n    assert candidate('1517') == '3:17 pm'\n    assert candidate('1518') == '3:18 pm'\n    assert candidate('1519') == '3:19 pm'\n    assert candidate('1520') == '3:20 pm'\n    assert candidate('1521') == '3:21 pm'\n    assert candidate('1522') == '3:22 pm'\n    assert candidate('1523') == '3:23 pm'\n    assert candidate('1524') == '3:24 pm'\n    assert candidate('1525') == '3:25 pm'\n    assert candidate('1526') == '3:26 pm'\n    assert candidate('1527') == '3:27 pm'\n    assert candidate('1528') == '3:28 pm'\n    assert candidate('1529') == '3:29 pm'\n    assert candidate('1530') == '3:30 pm'\n    assert candidate('1531') == '3:31 pm'\n    assert candidate('1532') == '3:32 pm'\n    assert candidate('1533') == '3:33 pm'\n    assert candidate('1534') == '3:34 pm'\n    assert candidate('1535') == '3:35 pm'\n    assert candidate('1536') == '3:36 pm'\n    assert candidate('1537') == '3:37 pm'\n    assert candidate('1538') == '3:38 pm'\n    assert candidate('1539') == '3:39 pm'\n    assert candidate('1540') == '3:40 pm'\n    assert candidate('1541') == '3:41 pm'\n    assert candidate('1542') == '3:42 pm'\n    assert candidate('1543') == '3:43 pm'\n    assert candidate('1544') == '3:44 pm'\n    assert candidate('1545') == '3:45 pm'\n    assert candidate('1546') == '3:46 pm'\n    assert candidate('1547') == '3:47 pm'\n    assert candidate('1548') == '3:48 pm'\n    assert candidate('1549') == '3:49 pm'\n    assert candidate('1550') == '3:50 pm'\n    assert candidate('1551') == '3:51 pm'\n    assert candidate('1552') == '3:52 pm'\n    assert candidate('1553') == '3:53 pm'\n    assert candidate('1554') == '3:54 pm'\n    assert candidate('1555') == '3:55 pm'\n    assert candidate('1556') == '3:56 pm'\n    assert candidate('1557') == '3:57 pm'\n    assert candidate('1558') == '3:58 pm'\n    assert candidate('1559') == '3:59 pm'\n    assert candidate('1600') == '4:00 pm'\n    assert candidate('1601') == '4:01 pm'\n    assert candidate('1602') == '4:02 pm'\n    assert candidate('1603') == '4:03 pm'\n    assert candidate('1604') == '4:04 pm'\n    assert candidate('1605') == '4:05 pm'\n    assert candidate('1606') == '4:06 pm'\n    assert candidate('1607') == '4:07 pm'\n    assert candidate('1608') == '4:08 pm'\n    assert candidate('1609') == '4:09 pm'\n    assert candidate('1610') == '4:10 pm'\n    assert candidate('1611') == '4:11 pm'\n    assert candidate('1612') == '4:12 pm'\n    assert candidate('1613') == '4:13 pm'\n    assert candidate('1614') == '4:14 pm'\n    assert candidate('1615') == '4:15 pm'\n    assert candidate('1616') == '4:16 pm'\n    assert candidate('1617') == '4:17 pm'\n    assert candidate('1618') == '4:18 pm'\n    assert candidate('1619') == '4:19 pm'\n    assert candidate('1620') == '4:20 pm'\n    assert candidate('1621') == '4:21 pm'\n    assert candidate('1622') == '4:22 pm'\n    assert candidate('1623') == '4:23 pm'\n    assert candidate('1624') == '4:24 pm'\n    assert candidate('1625') == '4:25 pm'\n    assert candidate('1626') == '4:26 pm'\n    assert candidate('1627') == '4:27 pm'\n    assert candidate('1628') == '4:28 pm'\n    assert candidate('1629') == '4:29 pm'\n    assert candidate('1630') == '4:30 pm'\n    assert candidate('1631') == '4:31 pm'\n    assert candidate('1632') == '4:32 pm'\n    assert candidate('1633') == '4:33 pm'\n    assert candidate('1634') == '4:34 pm'\n    assert candidate('1635') == '4:35 pm'\n    assert candidate('1636') == '4:36 pm'\n    assert candidate('1637') == '4:37 pm'\n    assert candidate('1638') == '4:38 pm'\n    assert candidate('1639') == '4:39 pm'\n    assert candidate('1640') == '4:40 pm'\n    assert candidate('1641') == '4:41 pm'\n    assert candidate('1642') == '4:42 pm'\n    assert candidate('1643') == '4:43 pm'\n    assert candidate('1644') == '4:44 pm'\n    assert candidate('1645') == '4:45 pm'\n    assert candidate('1646') == '4:46 pm'\n    assert candidate('1647') == '4:47 pm'\n    assert candidate('1648') == '4:48 pm'\n    assert candidate('1649') == '4:49 pm'\n    assert candidate('1650') == '4:50 pm'\n    assert candidate('1651') == '4:51 pm'\n    assert candidate('1652') == '4:52 pm'\n    assert candidate('1653') == '4:53 pm'\n    assert candidate('1654') == '4:54 pm'\n    assert candidate('1655') == '4:55 pm'\n    assert candidate('1656') == '4:56 pm'\n    assert candidate('1657') == '4:57 pm'\n    assert candidate('1658') == '4:58 pm'\n    assert candidate('1659') == '4:59 pm'\n    assert candidate('1700') == '5:00 pm'\n    assert candidate('1701') == '5:01 pm'\n    assert candidate('1702') == '5:02 pm'\n    assert candidate('1703') == '5:03 pm'\n    assert candidate('1704') == '5:04 pm'\n    assert candidate('1705') == '5:05 pm'\n    assert candidate('1706') == '5:06 pm'\n    assert candidate('1707') == '5:07 pm'\n    assert candidate('1708') == '5:08 pm'\n    assert candidate('1709') == '5:09 pm'\n    assert candidate('1710') == '5:10 pm'\n    assert candidate('1711') == '5:11 pm'\n    assert candidate('1712') == '5:12 pm'\n    assert candidate('1713') == '5:13 pm'\n    assert candidate('1714') == '5:14 pm'\n    assert candidate('1715') == '5:15 pm'\n    assert candidate('1716') == '5:16 pm'\n    assert candidate('1717') == '5:17 pm'\n    assert candidate('1718') == '5:18 pm'\n    assert candidate('1719') == '5:19 pm'\n    assert candidate('1720') == '5:20 pm'\n    assert candidate('1721') == '5:21 pm'\n    assert candidate('1722') == '5:22 pm'\n    assert candidate('1723') == '5:23 pm'\n    assert candidate('1724') == '5:24 pm'\n    assert candidate('1725') == '5:25 pm'\n    assert candidate('1726') == '5:26 pm'\n    assert candidate('1727') == '5:27 pm'\n    assert candidate('1728') == '5:28 pm'\n    assert candidate('1729') == '5:29 pm'\n    assert candidate('1730') == '5:30 pm'\n    assert candidate('1731') == '5:31 pm'\n    assert candidate('1732') == '5:32 pm'\n    assert candidate('1733') == '5:33 pm'\n    assert candidate('1734') == '5:34 pm'\n    assert candidate('1735') == '5:35 pm'\n    assert candidate('1736') == '5:36 pm'\n    assert candidate('1737') == '5:37 pm'\n    assert candidate('1738') == '5:38 pm'\n    assert candidate('1739') == '5:39 pm'\n    assert candidate('1740') == '5:40 pm'\n    assert candidate('1741') == '5:41 pm'\n    assert candidate('1742') == '5:42 pm'\n    assert candidate('1743') == '5:43 pm'\n    assert candidate('1744') == '5:44 pm'\n    assert candidate('1745') == '5:45 pm'\n    assert candidate('1746') == '5:46 pm'\n    assert candidate('1747') == '5:47 pm'\n    assert candidate('1748') == '5:48 pm'\n    assert candidate('1749') == '5:49 pm'\n    assert candidate('1750') == '5:50 pm'\n    assert candidate('1751') == '5:51 pm'\n    assert candidate('1752') == '5:52 pm'\n    assert candidate('1753') == '5:53 pm'\n    assert candidate('1754') == '5:54 pm'\n    assert candidate('1755') == '5:55 pm'\n    assert candidate('1756') == '5:56 pm'\n    assert candidate('1757') == '5:57 pm'\n    assert candidate('1758') == '5:58 pm'\n    assert candidate('1759') == '5:59 pm'\n    assert candidate('1800') == '6:00 pm'\n    assert candidate('1801') == '6:01 pm'\n    assert candidate('1802') == '6:02 pm'\n    assert candidate('1803') == '6:03 pm'\n    assert candidate('1804') == '6:04 pm'\n    assert candidate('1805') == '6:05 pm'\n    assert candidate('1806') == '6:06 pm'\n    assert candidate('1807') == '6:07 pm'\n    assert candidate('1808') == '6:08 pm'\n    assert candidate('1809') == '6:09 pm'\n    assert candidate('1810') == '6:10 pm'\n    assert candidate('1811') == '6:11 pm'\n    assert candidate('1812') == '6:12 pm'\n    assert candidate('1813') == '6:13 pm'\n    assert candidate('1814') == '6:14 pm'\n    assert candidate('1815') == '6:15 pm'\n    assert candidate('1816') == '6:16 pm'\n    assert candidate('1817') == '6:17 pm'\n    assert candidate('1818') == '6:18 pm'\n    assert candidate('1819') == '6:19 pm'\n    assert candidate('1820') == '6:20 pm'\n    assert candidate('1821') == '6:21 pm'\n    assert candidate('1822') == '6:22 pm'\n    assert candidate('1823') == '6:23 pm'\n    assert candidate('1824') == '6:24 pm'\n    assert candidate('1825') == '6:25 pm'\n    assert candidate('1826') == '6:26 pm'\n    assert candidate('1827') == '6:27 pm'\n    assert candidate('1828') == '6:28 pm'\n    assert candidate('1829') == '6:29 pm'\n    assert candidate('1830') == '6:30 pm'\n    assert candidate('1831') == '6:31 pm'\n    assert candidate('1832') == '6:32 pm'\n    assert candidate('1833') == '6:33 pm'\n    assert candidate('1834') == '6:34 pm'\n    assert candidate('1835') == '6:35 pm'\n    assert candidate('1836') == '6:36 pm'\n    assert candidate('1837') == '6:37 pm'\n    assert candidate('1838') == '6:38 pm'\n    assert candidate('1839') == '6:39 pm'\n    assert candidate('1840') == '6:40 pm'\n    assert candidate('1841') == '6:41 pm'\n    assert candidate('1842') == '6:42 pm'\n    assert candidate('1843') == '6:43 pm'\n    assert candidate('1844') == '6:44 pm'\n    assert candidate('1845') == '6:45 pm'\n    assert candidate('1846') == '6:46 pm'\n    assert candidate('1847') == '6:47 pm'\n    assert candidate('1848') == '6:48 pm'\n    assert candidate('1849') == '6:49 pm'\n    assert candidate('1850') == '6:50 pm'\n    assert candidate('1851') == '6:51 pm'\n    assert candidate('1852') == '6:52 pm'\n    assert candidate('1853') == '6:53 pm'\n    assert candidate('1854') == '6:54 pm'\n    assert candidate('1855') == '6:55 pm'\n    assert candidate('1856') == '6:56 pm'\n    assert candidate('1857') == '6:57 pm'\n    assert candidate('1858') == '6:58 pm'\n    assert candidate('1859') == '6:59 pm'\n    assert candidate('1900') == '7:00 pm'\n    assert candidate('1901') == '7:01 pm'\n    assert candidate('1902') == '7:02 pm'\n    assert candidate('1903') == '7:03 pm'\n    assert candidate('1904') == '7:04 pm'\n    assert candidate('1905') == '7:05 pm'\n    assert candidate('1906') == '7:06 pm'\n    assert candidate('1907') == '7:07 pm'\n    assert candidate('1908') == '7:08 pm'\n    assert candidate('1909') == '7:09 pm'\n    assert candidate('1910') == '7:10 pm'\n    assert candidate('1911') == '7:11 pm'\n    assert candidate('1912') == '7:12 pm'\n    assert candidate('1913') == '7:13 pm'\n    assert candidate('1914') == '7:14 pm'\n    assert candidate('1915') == '7:15 pm'\n    assert candidate('1916') == '7:16 pm'\n    assert candidate('1917') == '7:17 pm'\n    assert candidate('1918') == '7:18 pm'\n    assert candidate('1919') == '7:19 pm'\n    assert candidate('1920') == '7:20 pm'\n    assert candidate('1921') == '7:21 pm'\n    assert candidate('1922') == '7:22 pm'\n    assert candidate('1923') == '7:23 pm'\n    assert candidate('1924') == '7:24 pm'\n    assert candidate('1925') == '7:25 pm'\n    assert candidate('1926') == '7:26 pm'\n    assert candidate('1927') == '7:27 pm'\n    assert candidate('1928') == '7:28 pm'\n    assert candidate('1929') == '7:29 pm'\n    assert candidate('1930') == '7:30 pm'\n    assert candidate('1931') == '7:31 pm'\n    assert candidate('1932') == '7:32 pm'\n    assert candidate('1933') == '7:33 pm'\n    assert candidate('1934') == '7:34 pm'\n    assert candidate('1935') == '7:35 pm'\n    assert candidate('1936') == '7:36 pm'\n    assert candidate('1937') == '7:37 pm'\n    assert candidate('1938') == '7:38 pm'\n    assert candidate('1939') == '7:39 pm'\n    assert candidate('1940') == '7:40 pm'\n    assert candidate('1941') == '7:41 pm'\n    assert candidate('1942') == '7:42 pm'\n    assert candidate('1943') == '7:43 pm'\n    assert candidate('1944') == '7:44 pm'\n    assert candidate('1945') == '7:45 pm'\n    assert candidate('1946') == '7:46 pm'\n    assert candidate('1947') == '7:47 pm'\n    assert candidate('1948') == '7:48 pm'\n    assert candidate('1949') == '7:49 pm'\n    assert candidate('1950') == '7:50 pm'\n    assert candidate('1951') == '7:51 pm'\n    assert candidate('1952') == '7:52 pm'\n    assert candidate('1953') == '7:53 pm'\n    assert candidate('1954') == '7:54 pm'\n    assert candidate('1955') == '7:55 pm'\n    assert candidate('1956') == '7:56 pm'\n    assert candidate('1957') == '7:57 pm'\n    assert candidate('1958') == '7:58 pm'\n    assert candidate('1959') == '7:59 pm'\n    assert candidate('2000') == '8:00 pm'\n    assert candidate('2001') == '8:01 pm'\n    assert candidate('2002') == '8:02 pm'\n    assert candidate('2003') == '8:03 pm'\n    assert candidate('2004') == '8:04 pm'\n    assert candidate('2005') == '8:05 pm'\n    assert candidate('2006') == '8:06 pm'\n    assert candidate('2007') == '8:07 pm'\n    assert candidate('2008') == '8:08 pm'\n    assert candidate('2009') == '8:09 pm'\n    assert candidate('2010') == '8:10 pm'\n    assert candidate('2011') == '8:11 pm'\n    assert candidate('2012') == '8:12 pm'\n    assert candidate('2013') == '8:13 pm'\n    assert candidate('2014') == '8:14 pm'\n    assert candidate('2015') == '8:15 pm'\n    assert candidate('2016') == '8:16 pm'\n    assert candidate('2017') == '8:17 pm'\n    assert candidate('2018') == '8:18 pm'\n    assert candidate('2019') == '8:19 pm'\n    assert candidate('2020') == '8:20 pm'\n    assert candidate('2021') == '8:21 pm'\n    assert candidate('2022') == '8:22 pm'\n    assert candidate('2023') == '8:23 pm'\n    assert candidate('2024') == '8:24 pm'\n    assert candidate('2025') == '8:25 pm'\n    assert candidate('2026') == '8:26 pm'\n    assert candidate('2027') == '8:27 pm'\n    assert candidate('2028') == '8:28 pm'\n    assert candidate('2029') == '8:29 pm'\n    assert candidate('2030') == '8:30 pm'\n    assert candidate('2031') == '8:31 pm'\n    assert candidate('2032') == '8:32 pm'\n    assert candidate('2033') == '8:33 pm'\n    assert candidate('2034') == '8:34 pm'\n    assert candidate('2035') == '8:35 pm'\n    assert candidate('2036') == '8:36 pm'\n    assert candidate('2037') == '8:37 pm'\n    assert candidate('2038') == '8:38 pm'\n    assert candidate('2039') == '8:39 pm'\n    assert candidate('2040') == '8:40 pm'\n    assert candidate('2041') == '8:41 pm'\n    assert candidate('2042') == '8:42 pm'\n    assert candidate('2043') == '8:43 pm'\n    assert candidate('2044') == '8:44 pm'\n    assert candidate('2045') == '8:45 pm'\n    assert candidate('2046') == '8:46 pm'\n    assert candidate('2047') == '8:47 pm'\n    assert candidate('2048') == '8:48 pm'\n    assert candidate('2049') == '8:49 pm'\n    assert candidate('2050') == '8:50 pm'\n    assert candidate('2051') == '8:51 pm'\n    assert candidate('2052') == '8:52 pm'\n    assert candidate('2053') == '8:53 pm'\n    assert candidate('2054') == '8:54 pm'\n    assert candidate('2055') == '8:55 pm'\n    assert candidate('2056') == '8:56 pm'\n    assert candidate('2057') == '8:57 pm'\n    assert candidate('2058') == '8:58 pm'\n    assert candidate('2059') == '8:59 pm'\n    assert candidate('2100') == '9:00 pm'\n    assert candidate('2101') == '9:01 pm'\n    assert candidate('2102') == '9:02 pm'\n    assert candidate('2103') == '9:03 pm'\n    assert candidate('2104') == '9:04 pm'\n    assert candidate('2105') == '9:05 pm'\n    assert candidate('2106') == '9:06 pm'\n    assert candidate('2107') == '9:07 pm'\n    assert candidate('2108') == '9:08 pm'\n    assert candidate('2109') == '9:09 pm'\n    assert candidate('2110') == '9:10 pm'\n    assert candidate('2111') == '9:11 pm'\n    assert candidate('2112') == '9:12 pm'\n    assert candidate('2113') == '9:13 pm'\n    assert candidate('2114') == '9:14 pm'\n    assert candidate('2115') == '9:15 pm'\n    assert candidate('2116') == '9:16 pm'\n    assert candidate('2117') == '9:17 pm'\n    assert candidate('2118') == '9:18 pm'\n    assert candidate('2119') == '9:19 pm'\n    assert candidate('2120') == '9:20 pm'\n    assert candidate('2121') == '9:21 pm'\n    assert candidate('2122') == '9:22 pm'\n    assert candidate('2123') == '9:23 pm'\n    assert candidate('2124') == '9:24 pm'\n    assert candidate('2125') == '9:25 pm'\n    assert candidate('2126') == '9:26 pm'\n    assert candidate('2127') == '9:27 pm'\n    assert candidate('2128') == '9:28 pm'\n    assert candidate('2129') == '9:29 pm'\n    assert candidate('2130') == '9:30 pm'\n    assert candidate('2131') == '9:31 pm'\n    assert candidate('2132') == '9:32 pm'\n    assert candidate('2133') == '9:33 pm'\n    assert candidate('2134') == '9:34 pm'\n    assert candidate('2135') == '9:35 pm'\n    assert candidate('2136') == '9:36 pm'\n    assert candidate('2137') == '9:37 pm'\n    assert candidate('2138') == '9:38 pm'\n    assert candidate('2139') == '9:39 pm'\n    assert candidate('2140') == '9:40 pm'\n    assert candidate('2141') == '9:41 pm'\n    assert candidate('2142') == '9:42 pm'\n    assert candidate('2143') == '9:43 pm'\n    assert candidate('2144') == '9:44 pm'\n    assert candidate('2145') == '9:45 pm'\n    assert candidate('2146') == '9:46 pm'\n    assert candidate('2147') == '9:47 pm'\n    assert candidate('2148') == '9:48 pm'\n    assert candidate('2149') == '9:49 pm'\n    assert candidate('2150') == '9:50 pm'\n    assert candidate('2151') == '9:51 pm'\n    assert candidate('2152') == '9:52 pm'\n    assert candidate('2153') == '9:53 pm'\n    assert candidate('2154') == '9:54 pm'\n    assert candidate('2155') == '9:55 pm'\n    assert candidate('2156') == '9:56 pm'\n    assert candidate('2157') == '9:57 pm'\n    assert candidate('2158') == '9:58 pm'\n    assert candidate('2159') == '9:59 pm'\n    assert candidate('2200') == '10:00 pm'\n    assert candidate('2201') == '10:01 pm'\n    assert candidate('2202') == '10:02 pm'\n    assert candidate('2203') == '10:03 pm'\n    assert candidate('2204') == '10:04 pm'\n    assert candidate('2205') == '10:05 pm'\n    assert candidate('2206') == '10:06 pm'\n    assert candidate('2207') == '10:07 pm'\n    assert candidate('2208') == '10:08 pm'\n    assert candidate('2209') == '10:09 pm'\n    assert candidate('2210') == '10:10 pm'\n    assert candidate('2211') == '10:11 pm'\n    assert candidate('2212') == '10:12 pm'\n    assert candidate('2213') == '10:13 pm'\n    assert candidate('2214') == '10:14 pm'\n    assert candidate('2215') == '10:15 pm'\n    assert candidate('2216') == '10:16 pm'\n    assert candidate('2217') == '10:17 pm'\n    assert candidate('2218') == '10:18 pm'\n    assert candidate('2219') == '10:19 pm'\n    assert candidate('2220') == '10:20 pm'\n    assert candidate('2221') == '10:21 pm'\n    assert candidate('2222') == '10:22 pm'\n    assert candidate('2223') == '10:23 pm'\n    assert candidate('2224') == '10:24 pm'\n    assert candidate('2225') == '10:25 pm'\n    assert candidate('2226') == '10:26 pm'\n    assert candidate('2227') == '10:27 pm'\n    assert candidate('2228') == '10:28 pm'\n    assert candidate('2229') == '10:29 pm'\n    assert candidate('2230') == '10:30 pm'\n    assert candidate('2231') == '10:31 pm'\n    assert candidate('2232') == '10:32 pm'\n    assert candidate('2233') == '10:33 pm'\n    assert candidate('2234') == '10:34 pm'\n    assert candidate('2235') == '10:35 pm'\n    assert candidate('2236') == '10:36 pm'\n    assert candidate('2237') == '10:37 pm'\n    assert candidate('2238') == '10:38 pm'\n    assert candidate('2239') == '10:39 pm'\n    assert candidate('2240') == '10:40 pm'\n    assert candidate('2241') == '10:41 pm'\n    assert candidate('2242') == '10:42 pm'\n    assert candidate('2243') == '10:43 pm'\n    assert candidate('2244') == '10:44 pm'\n    assert candidate('2245') == '10:45 pm'\n    assert candidate('2246') == '10:46 pm'\n    assert candidate('2247') == '10:47 pm'\n    assert candidate('2248') == '10:48 pm'\n    assert candidate('2249') == '10:49 pm'\n    assert candidate('2250') == '10:50 pm'\n    assert candidate('2251') == '10:51 pm'\n    assert candidate('2252') == '10:52 pm'\n    assert candidate('2253') == '10:53 pm'\n    assert candidate('2254') == '10:54 pm'\n    assert candidate('2255') == '10:55 pm'\n    assert candidate('2256') == '10:56 pm'\n    assert candidate('2257') == '10:57 pm'\n    assert candidate('2258') == '10:58 pm'\n    assert candidate('2259') == '10:59 pm'\n    assert candidate('2300') == '11:00 pm'\n    assert candidate('2301') == '11:01 pm'\n    assert candidate('2302') == '11:02 pm'\n    assert candidate('2303') == '11:03 pm'\n    assert candidate('2304') == '11:04 pm'\n    assert candidate('2305') == '11:05 pm'\n    assert candidate('2306') == '11:06 pm'\n    assert candidate('2307') == '11:07 pm'\n    assert candidate('2308') == '11:08 pm'\n    assert candidate('2309') == '11:09 pm'\n    assert candidate('2310') == '11:10 pm'\n    assert candidate('2311') == '11:11 pm'\n    assert candidate('2312') == '11:12 pm'\n    assert candidate('2313') == '11:13 pm'\n    assert candidate('2314') == '11:14 pm'\n    assert candidate('2315') == '11:15 pm'\n    assert candidate('2316') == '11:16 pm'\n    assert candidate('2317') == '11:17 pm'\n    assert candidate('2318') == '11:18 pm'\n    assert candidate('2319') == '11:19 pm'\n    assert candidate('2320') == '11:20 pm'\n    assert candidate('2321') == '11:21 pm'\n    assert candidate('2322') == '11:22 pm'\n    assert candidate('2323') == '11:23 pm'\n    assert candidate('2324') == '11:24 pm'\n    assert candidate('2325') == '11:25 pm'\n    assert candidate('2326') == '11:26 pm'\n    assert candidate('2327') == '11:27 pm'\n    assert candidate('2328') == '11:28 pm'\n    assert candidate('2329') == '11:29 pm'\n    assert candidate('2330') == '11:30 pm'\n    assert candidate('2331') == '11:31 pm'\n    assert candidate('2332') == '11:32 pm'\n    assert candidate('2333') == '11:33 pm'\n    assert candidate('2334') == '11:34 pm'\n    assert candidate('2335') == '11:35 pm'\n    assert candidate('2336') == '11:36 pm'\n    assert candidate('2337') == '11:37 pm'\n    assert candidate('2338') == '11:38 pm'\n    assert candidate('2339') == '11:39 pm'\n    assert candidate('2340') == '11:40 pm'\n    assert candidate('2341') == '11:41 pm'\n    assert candidate('2342') == '11:42 pm'\n    assert candidate('2343') == '11:43 pm'\n    assert candidate('2344') == '11:44 pm'\n    assert candidate('2345') == '11:45 pm'\n    assert candidate('2346') == '11:46 pm'\n    assert candidate('2347') == '11:47 pm'\n    assert candidate('2348') == '11:48 pm'\n    assert candidate('2349') == '11:49 pm'\n    assert candidate('2350') == '11:50 pm'\n    assert candidate('2351') == '11:51 pm'\n    assert candidate('2352') == '11:52 pm'\n    assert candidate('2353') == '11:53 pm'\n    assert candidate('2354') == '11:54 pm'\n    assert candidate('2355') == '11:55 pm'\n    assert candidate('2356') == '11:56 pm'\n    assert candidate('2357') == '11:57 pm'\n    assert candidate('2358') == '11:58 pm'\n    assert candidate('2359') == '11:59 pm'\n\n","canonical_solution":"from datetime import datetime\n\ndef to12hourtime(t):\n    return datetime.strptime(t, '%H%M').strftime('%I:%M %p').lstrip('0').lower()"}
{"task_id":4240,"prompt":"\"\"\"\n=====Problem statement====\n\n### Tongues\n\nGandalf's writings have long been available for study, but no one has yet figured out what language they are written in. Recently, due to programming work by a hacker known only by the code name ROT13, it has been discovered that Gandalf used nothing but a simple letter substitution scheme, and further, that it is its own inverse|the same operation scrambles the message as unscrambles it. \n\nThis operation is performed by replacing vowels in the sequence `'a' 'i' 'y' 'e' 'o' 'u'` with the vowel three advanced, cyclicly, while preserving case (i.e., lower or upper). \n\nSimilarly, consonants are replaced from the sequence `'b' 'k' 'x' 'z' 'n' 'h' 'd' 'c' 'w' 'g' 'p' 'v' 'j' 'q' 't' 's' 'r' 'l' 'm' 'f'` by advancing ten letters.\n\nSo for instance the phrase `'One ring to rule them all.'` translates to `'Ita dotf ni dyca nsaw ecc.'`\n\nThe fascinating thing about this transformation is that the resulting language yields pronounceable words.  For this problem, you will write code to translate Gandalf's manuscripts into plain text.\n\nYour job is to write a function that decodes Gandalf's writings.\n\n### Input\n\nThe function will be passed a string for the function to decode.  Each string will contain up to 100 characters, representing some text written by Gandalf. All characters will be plain ASCII, in the range space (32) to tilde (126).\n\n### Output\n\nFor each string passed to the decode function return its translation.\n\"\"\"\n\n# ====== Solution ======\n\ndef tongues(code):\n","entry_point":"tongues","test":"def check(candidate):\n    assert candidate('Ita dotf ni dyca nsaw ecc.') == 'One ring to rule them all.'\n    assert candidate('Tim oh nsa nowa gid ecc fiir wat ni liwa ni nsa eor ig nsaod liytndu.') == 'Now is the time for all good men to come to the aid of their country.'\n    assert candidate('Giydhlida etr hakat uaedh efi iyd gidagensadh pdiyfsn ytni nsoh') == 'Fourscore and seven years ago our forefathers brought unto this'\n    assert candidate('litnotatn e tam tenoit.') == 'continent a new nation.'\n    assert candidate('Nsa zyolv pdimt gij xywbar ikad nsa cequ rifh.') == 'The quick brown fox jumped over the lazy dogs.'\n    assert candidate('Tywpadh (1234567890) etr bytlnyenoit, nsau hsiycr pins pa ytlsetfar!') == 'Numbers (1234567890) and punctuation, they should both be unchanged!'\n    assert candidate(' ') == ' '\n    assert candidate('Nsoh oh tin Vcotfit pyn on liycr pa e roggadatn gidaoft cetfyefa.') == 'This is not Klingon but it could be a different foreign language.'\n    assert candidate('0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789') == '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'\n    assert candidate('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa') == 'eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'\n    assert candidate('mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm') == 'wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww'\n    assert candidate('z') == 'q'\n    assert candidate('') == ''\n    assert candidate('****************************************************************************************************') == '****************************************************************************************************'\n    assert candidate('q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1q1') == 'z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1z1'\n\n","canonical_solution":"def tongues(code):\n    AsT = \"\"\n    for i in code:\n        if i == \"i\":\n            AsT = AsT + \"o\"\n        elif i == \"t\":\n            AsT = AsT + \"n\"\n        elif i == \"a\":\n            AsT = AsT + \"e\"\n        elif i == \"d\":\n            AsT = AsT + \"r\"\n        elif i == \"f\":\n            AsT = AsT + \"g\"\n        elif i == \"y\":\n            AsT = AsT + \"u\"\n        elif i == \"c\":\n            AsT = AsT + \"l\"\n        elif i == \"s\":\n            AsT = AsT + \"h\"\n        elif i == \"w\":\n            AsT = AsT + \"m\"\n        elif i == \"v\":\n            AsT = AsT + \"k\"\n        elif i == \"q\":\n            AsT = AsT + \"z\"\n        elif i == \"p\":\n            AsT = AsT + \"b\"\n        elif i == \"j\":\n            AsT = AsT + \"x\"\n        elif i == \"o\":\n            AsT = AsT + \"i\"\n        elif i == \"n\":\n            AsT = AsT + \"t\"\n        elif i == \"e\":\n            AsT = AsT + \"a\"\n        elif i == \"r\":\n            AsT = AsT + \"d\"\n        elif i == \"g\":\n            AsT = AsT + \"f\"\n        elif i == \"u\":\n            AsT = AsT + \"y\"\n        elif i == \"l\":\n            AsT = AsT + \"c\"\n        elif i == \"h\":\n            AsT = AsT + \"s\"\n        elif i == \"m\":\n            AsT = AsT + \"w\"\n        elif i == \"k\":\n            AsT = AsT + \"v\"\n        elif i == \"z\":\n            AsT = AsT + \"q\"\n        elif i == \"b\":\n            AsT = AsT + \"p\"\n        elif i == \"x\":\n            AsT = AsT + \"j\"\n        elif i == \"I\":\n            AsT = AsT + \"O\"\n        elif i == \"T\":\n            AsT = AsT + \"N\"\n        elif i == \"A\":\n            AsT = AsT + \"E\"\n        elif i == \"D\":\n            AsT = AsT + \"R\"\n        elif i == \"F\":\n            AsT = AsT + \"G\"\n        elif i == \"Y\":\n            AsT = AsT + \"U\"\n        elif i == \"C\":\n            AsT = AsT + \"L\"\n        elif i == \"S\":\n            AsT = AsT + \"H\"\n        elif i == \"W\":\n            AsT = AsT + \"M\"\n        elif i == \"V\":\n            AsT = AsT + \"K\"\n        elif i == \"Q\":\n            AsT = AsT + \"Z\"\n        elif i == \"P\":\n            AsT = AsT + \"B\"\n        elif i == \"J\":\n            AsT = AsT + \"X\"\n        elif i == \"O\":\n            AsT = AsT + \"I\"\n        elif i == \"N\":\n            AsT = AsT + \"T\"\n        elif i == \"E\":\n            AsT = AsT + \"A\"\n        elif i == \"R\":\n            AsT = AsT + \"D\"\n        elif i == \"G\":\n            AsT = AsT + \"F\"\n        elif i == \"U\":\n            AsT = AsT + \"Y\"\n        elif i == \"L\":\n            AsT = AsT + \"C\"\n        elif i == \"H\":\n            AsT = AsT + \"S\"\n        elif i == \"M\":\n            AsT = AsT + \"W\"\n        elif i == \"K\":\n            AsT = AsT + \"V\"\n        elif i == \"Z\":\n            AsT = AsT + \"Q\"\n        elif i == \"B\":\n            AsT = AsT + \"P\"\n        elif i == \"X\":\n            AsT = AsT + \"J\"\n        else:\n            AsT = AsT + i    \n    return AsT"}
{"task_id":4246,"prompt":"\"\"\"\n=====Problem statement====\n\n# Covfefe\n\n\nYour are given a string. You must replace the word(s) `coverage` by `covfefe`, however, if you don't find the word `coverage` in the string, you must add `covfefe` at the end of the string with a leading space.\n\nFor the languages where the string is not immutable (such as ruby), don't modify the given string, otherwise this will break the test cases.\n\"\"\"\n\n# ====== Solution ======\n\ndef covfefe(s):\n","entry_point":"covfefe","test":"def check(candidate):\n    assert candidate('coverage') == 'covfefe'\n    assert candidate('coverage coverage') == 'covfefe covfefe'\n    assert candidate('nothing') == 'nothing covfefe'\n    assert candidate('double space ') == 'double space  covfefe'\n    assert candidate('covfefe') == 'covfefe covfefe'\n\n","canonical_solution":"def covfefe(s):\n    return s.replace(\"coverage\",\"covfefe\") if \"coverage\" in s else s+\" covfefe\""}
{"task_id":4255,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function which converts the input string to uppercase.\n\n~~~if:bf\nFor BF all inputs end with \\0, all inputs are lowercases and there is no space between. \n~~~\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"make_upper_case","test":"def check(candidate):\n    assert candidate('hello') == 'HELLO'\n    assert candidate('hello world') == 'HELLO WORLD'\n    assert candidate('hello world !') == 'HELLO WORLD !'\n    assert candidate('heLlO wORLd !') == 'HELLO WORLD !'\n    assert candidate('1,2,3 hello world!') == '1,2,3 HELLO WORLD!'\n\n","canonical_solution":"def make_upper_case(s): return s.upper()"}
{"task_id":4257,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven n number of people in a room, calculate the probability that any two people in that room have the same birthday (assume 365 days every year = ignore leap year). Answers should be two decimals unless whole (0 or 1) eg 0.05\n\"\"\"\n\n# ====== Solution ======\n\ndef calculate_probability(n):\n","entry_point":"calculate_probability","test":"def check(candidate):\n    assert candidate(5) == 0.03\n    assert candidate(15) == 0.25\n    assert candidate(1) == 0\n    assert candidate(365) == 1\n    assert candidate(366) == 1\n\n","canonical_solution":"def calculate_probability(n):\n    return round(1 - (364 \/ 365) ** (n * (n - 1) \/ 2), 2)"}
{"task_id":4262,"prompt":"\"\"\"\n=====Problem statement====\n\nDee is lazy but she's kind and she likes to eat out at all the nice restaurants and gastropubs in town. To make paying quick and easy she uses a simple mental algorithm she's called The Fair %20 Rule. She's gotten so good she can do this in a few seconds and it always impresses her dates but she's perplexingly still single. Like you probably. \n\nThis is how she does it:\n\n - She rounds the price `P` at the tens place e.g:\n   - 25 becomes 30\n   - 24 becomes 20\n   - 5 becomes 10\n   - 4 becomes 0\n - She figures out the base tip `T` by dropping the singles place digit e.g:\n   - when `P = 24` she rounds to 20 drops 0 `T = 2`\n   - `P = 115` rounds to 120 drops 0 `T = 12`\n   - `P = 25` rounds to 30 drops 0 `T = 3`\n   - `P = 5` rounds to 10 drops 0 `T = 1`\n   - `P = 4` rounds to 0 `T = 0`\n - She then applies a 3 point satisfaction rating `R` to `T` i.e:\n   - When she's satisfied: `R = 1` and she'll add 1 to `T`\n   - Unsatisfied: `R = 0` and she'll subtract 1 from `T`\n   - Appalled: `R = -1` she'll divide `T` by 2, **rounds down** and subtracts 1\n \n## Your Task\n\nImplement a method `calc_tip` that takes two integer arguments for price `p` \n\nwhere `1 <= p <= 1000` and a rating `r` which is one of `-1, 0, 1`.\n\nThe return value `T` should be a non negative integer.\n\n*Note: each step should be done in the order listed.*\n\nDee always politely smiles and says \"Thank you\" on her way out. Dee is nice. Be like Dee.\n\"\"\"\n\n# ====== Solution ======\n\ndef calc_tip(p, r):\n","entry_point":"calc_tip","test":"def check(candidate):\n    assert candidate(4,1) == 1\n    assert candidate(4,0) == 0\n    assert candidate(4,-1) == 0\n    assert candidate(5,1) == 2\n    assert candidate(5,0) == 0\n    assert candidate(5,-1) == 0\n    assert candidate(14,1) == 2\n    assert candidate(14,0) == 0\n    assert candidate(14,-1) == 0\n    assert candidate(15,1) == 3\n    assert candidate(15,0) == 1\n    assert candidate(15,-1) == 0\n    assert candidate(24,1) == 3\n    assert candidate(24,0) == 1\n    assert candidate(24,-1) == 0\n    assert candidate(25,1) == 4\n    assert candidate(25,0) == 2\n    assert candidate(25,-1) == 0\n    assert candidate(125,1) == 14\n    assert candidate(125,0) == 12\n    assert candidate(125,-1) == 5\n    assert candidate(144,1) == 15\n    assert candidate(144,0) == 13\n    assert candidate(144,-1) == 6\n\n","canonical_solution":"def calc_tip(p, r):\n    if p % 10 < 5:\n        p \/\/= 10\n    else:\n        p = p \/\/ 10 + 1\n    if r == 1:\n        tip = p + 1\n    elif r == 0:\n        tip = p - 1\n    else:\n        tip = int(p\/2) - 1\n    return tip if tip >= 0 else 0"}
{"task_id":4267,"prompt":"\"\"\"\n=====Problem statement====\n\nIn Dark Souls, players level up trading souls for stats. 8 stats are upgradable this way: vitality, attunement, endurance, strength, dexterity, resistance, intelligence, and faith. Each level corresponds to adding one point to a stat of the player's choice. Also, there are 10 possible classes each having their own starting level and stats:\n\n```\nWarrior     (Level 4):  11, 8, 12, 13, 13, 11, 9, 9\nKnight      (Level 5):  14, 10, 10, 11, 11, 10, 9, 11\nWanderer    (Level 3):  10, 11, 10, 10, 14, 12, 11, 8\nThief       (Level 5):  9, 11, 9, 9, 15, 10, 12, 11\nBandit      (Level 4):  12, 8, 14, 14, 9, 11, 8, 10\nHunter      (Level 4):  11, 9, 11, 12, 14, 11, 9, 9\nSorcerer    (Level 3):  8, 15, 8, 9, 11, 8, 15, 8\nPyromancer  (Level 1):  10, 12, 11, 12, 9, 12, 10, 8\nCleric      (Level 2):  11, 11, 9, 12, 8, 11, 8, 14\nDeprived    (Level 6):  11, 11, 11, 11, 11, 11, 11, 11\n```\n\nFrom level 1, the necessary souls to level up each time up to 11 are `673`, `690`, `707`, `724`, `741`, `758`, `775`, `793`, `811`, and `829`. Then from 11 to 12 and onwards the amount is defined by the expression `round(pow(x, 3) * 0.02 + pow(x, 2) * 3.06 + 105.6 * x - 895)` where `x` is the number corresponding to the next level.\n\nYour function will receive a string with the character class and a list of stats. It should calculate which level is required to get the desired character build and the amount of souls needed to do so. The result should be a string in the format: `'Starting as a [CLASS], level [N] will require [M] souls.'` where `[CLASS]` is your starting class, `[N]` is the required level, and `[M]` is the amount of souls needed respectively.\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import accumulate\n\nCHARACTERS = {\n    \"warrior\": (4, [11, 8, 12, 13, 13, 11, 9, 9]),\n    \"knight\": (5, [14, 10, 10, 11, 11, 10, 9, 11]),\n    \"wanderer\": (3, [10, 11, 10, 10, 14, 12, 11, 8]),\n    \"thief\": (5, [9, 11, 9, 9, 15, 10, 12, 11]),\n    \"bandit\": (4, [12, 8, 14, 14, 9, 11, 8, 10]),\n    \"hunter\": (4, [11, 9, 11, 12, 14, 11, 9, 9]),\n    \"sorcerer\": (3, [8, 15, 8, 9, 11, 8, 15, 8]),\n    \"pyromancer\": (1, [10, 12, 11, 12, 9, 12, 10, 8]),\n    \"cleric\": (2, [11, 11, 9, 12, 8, 11, 8, 14]),\n    \"deprived\": (6, [11, 11, 11, 11, 11, 11, 11, 11]),\n}\nREQUIRED_SOULS = list(\n    accumulate(\n        [0, 0, 673, 690, 707, 724, 741, 758, 775, 793, 811, 829]\n        + [\n            round(pow(x, 3) * 0.02 + pow(x, 2) * 3.06 + 105.6 * x - 895)\n            for x in range(12, 1000)\n        ]\n    )\n)\n\ndef souls(character, build):\n","entry_point":"souls","test":"def check(candidate):\n    assert candidate('deprived',[11, 11, 11, 11, 11, 11, 11, 11]) == 'Starting as a deprived, level 6 will require 0 souls.'\n    assert candidate('pyromancer',[10, 12, 11, 12, 9, 12, 11, 8]) == 'Starting as a pyromancer, level 2 will require 673 souls.'\n    assert candidate('pyromancer',[16, 12, 11, 12, 9, 12, 10, 8]) == 'Starting as a pyromancer, level 7 will require 4293 souls.'\n    assert candidate('pyromancer',[16, 12, 11, 12, 9, 12, 13, 8]) == 'Starting as a pyromancer, level 10 will require 6672 souls.'\n    assert candidate('pyromancer',[16, 12, 11, 12, 9, 12, 13, 10]) == 'Starting as a pyromancer, level 12 will require 8348 souls.'\n\n","canonical_solution":"from itertools import accumulate\n\nCHARACTERS = {\n    \"warrior\": (4, [11, 8, 12, 13, 13, 11, 9, 9]),\n    \"knight\": (5, [14, 10, 10, 11, 11, 10, 9, 11]),\n    \"wanderer\": (3, [10, 11, 10, 10, 14, 12, 11, 8]),\n    \"thief\": (5, [9, 11, 9, 9, 15, 10, 12, 11]),\n    \"bandit\": (4, [12, 8, 14, 14, 9, 11, 8, 10]),\n    \"hunter\": (4, [11, 9, 11, 12, 14, 11, 9, 9]),\n    \"sorcerer\": (3, [8, 15, 8, 9, 11, 8, 15, 8]),\n    \"pyromancer\": (1, [10, 12, 11, 12, 9, 12, 10, 8]),\n    \"cleric\": (2, [11, 11, 9, 12, 8, 11, 8, 14]),\n    \"deprived\": (6, [11, 11, 11, 11, 11, 11, 11, 11]),\n}\nREQUIRED_SOULS = list(\n    accumulate(\n        [0, 0, 673, 690, 707, 724, 741, 758, 775, 793, 811, 829]\n        + [\n            round(pow(x, 3) * 0.02 + pow(x, 2) * 3.06 + 105.6 * x - 895)\n            for x in range(12, 1000)\n        ]\n    )\n)\n\ndef souls(character, build):\n    starting_level, stats = CHARACTERS[character]\n    delta = sum(b - s for b, s in zip(build, stats))\n    level = starting_level + delta\n    souls = REQUIRED_SOULS[level] - REQUIRED_SOULS[starting_level]\n    return f\"Starting as a {character}, level {level} will require {souls} souls.\""}
{"task_id":4268,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a non-negative number, return the next bigger polydivisible number, or an empty value like `null` or `Nothing`.\n\nA number is polydivisible if its first digit is cleanly divisible by `1`, its first two digits by `2`, its first three by `3`, and so on. There are finitely many polydivisible numbers.\n\"\"\"\n\n# ====== Solution ======\n\nd, polydivisible, arr = 1, [], list(range(1, 10))\nwhile arr:\n    d += 1\n    polydivisible.extend(arr)\n    arr = [n for x in arr for n in\n           range(-(-x*10 \/\/ d) * d, (x+1) * 10, d)]\n\ndef next_num(n):\n","entry_point":"next_num","test":"def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(10) == 12\n    assert candidate(11) == 12\n    assert candidate(1234) == 1236\n    assert candidate(123220) == 123252\n    assert candidate(998) == 1020\n    assert candidate(999) == 1020\n    assert candidate(1234567890) == 1236004020\n    assert candidate(3608528850368400786036724) == 3608528850368400786036725\n    assert candidate(3608528850368400786036725) == None\n\n","canonical_solution":"d, polydivisible, arr = 1, [], list(range(1, 10))\nwhile arr:\n    d += 1\n    polydivisible.extend(arr)\n    arr = [n for x in arr for n in\n           range(-(-x*10 \/\/ d) * d, (x+1) * 10, d)]\n\ndef next_num(n):\n    from bisect import bisect\n    idx = bisect(polydivisible, n)\n    if idx < len(polydivisible):\n        return polydivisible[idx]"}
{"task_id":4269,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are currently in the United States of America. The main currency here is known as the United States Dollar (USD). You are planning to travel to another country for vacation, so you make it today's goal to convert your USD (all bills, no cents) into the appropriate currency. This will help you be more prepared for when you arrive in the country you will be vacationing in.\n\nGiven an integer (`usd`) representing the amount of dollars you have and a string (`currency`) representing the name of the currency used in another country, it is your task to determine the amount of foreign currency you will receive when you exchange your United States Dollars.\n\nHowever, there is one minor issue to deal with first. The screens and monitors at the Exchange are messed up. Some conversion rates are correctly presented, but other conversion rates are incorrectly presented. For some countries, they are temporarily displaying the standard conversion rate in the form of a number's binary representation! \n\nYou make some observations. If a country's currency begins with a vowel, then the conversion rate is unaffected by the technical difficulties. If a country's currency begins with a consonant, then the conversion rate has been tampered with.\n\nNormally, the display would show 1 USD converting to 111 Japanese Yen. Instead, the display is showing 1 USD converts to 1101111 Japanese Yen. You take it upon yourself to sort this out. By doing so, your 250 USD rightfully becomes 27750 Japanese Yen.\n\n`\nfunction(250, \"Japanese Yen\") => \"You now have 27750 of Japanese Yen.\"\n`\n\nNormally, the display would show 1 USD converting to 21 Czech Koruna. Instead, the display is showing 1 USD converts to 10101 Czech Koruna. You take it upon yourself to sort this out. By doing so, your 325 USD rightfully becomes 6825 Czech Koruna.\n\n`\nfunction(325, \"Czech Koruna\") => \"You now have 6825 of Czech Koruna.\"\n`\n\nUsing your understanding of converting currencies in conjunction with the preloaded conversion-rates table, properly convert your dollars into the correct amount of foreign currency.\n\n```if:javascript,ruby\nNote: `CONVERSION_RATES` is frozen.\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef convert_my_dollars(usd, currency):\n","entry_point":"convert_my_dollars","test":"def check(candidate):\n    assert candidate(7,'Armenian Dram') == 'You now have 3346 of Armenian Dram.'\n    assert candidate(322,'Armenian Dram') == 'You now have 153916 of Armenian Dram.'\n    assert candidate(25,'Bangladeshi Taka') == 'You now have 2050 of Bangladeshi Taka.'\n    assert candidate(730,'Bangladeshi Taka') == 'You now have 59860 of Bangladeshi Taka.'\n    assert candidate(37,'Croatian Kuna') == 'You now have 222 of Croatian Kuna.'\n    assert candidate(40,'Croatian Kuna') == 'You now have 240 of Croatian Kuna.'\n    assert candidate(197,'Czech Koruna') == 'You now have 4137 of Czech Koruna.'\n    assert candidate(333,'Czech Koruna') == 'You now have 6993 of Czech Koruna.'\n    assert candidate(768,'Dominican Peso') == 'You now have 36864 of Dominican Peso.'\n    assert candidate(983,'Dominican Peso') == 'You now have 47184 of Dominican Peso.'\n\n","canonical_solution":"def convert_my_dollars(usd, currency):\n    curs = {\n        'Ar':478, 'Ba':82, 'Cr':6, 'Cz':21, 'Do':48, 'Ph':50,\n        'Uz':10000, 'Ha':64, 'Gu':7, 'Ta':32, 'Ro':4, 'Eg':18,\n        'Vi':22573, 'In':63, 'Ni':31, 'Ve':10, 'No':8, 'Ja':111,\n        'Sa':3, 'Th':32, 'Ke':102, 'So':1059}\n    return f\"You now have {usd*curs.get(currency[:2],0)} of {currency}.\""}
{"task_id":4273,"prompt":"\"\"\"\n=====Problem statement====\n\nYou're re-designing a blog and the blog's posts have the following format for showing the date and time a post was made: \n\n*Weekday* *Month* *Day*, *time*\ne.g., \nFriday May 2, 7pm\n\nYou're running out of screen real estate, and on some pages you want to display a shorter format, *Weekday* *Month* *Day* that omits the time.\n\nWrite a function, shortenToDate, that takes the Website date\/time in its original string format, and returns the shortened format.\n\nAssume shortenToDate's input will always be a string, e.g. \"Friday May 2, 7pm\". Assume shortenToDate's output will be the shortened string, e.g., \"Friday May 2\".\n\"\"\"\n\n# ====== Solution ======\n\ndef shorten_to_date(long_date):\n","entry_point":"shorten_to_date","test":"def check(candidate):\n    assert candidate('Monday February 2, 8pm') == 'Monday February 2'\n    assert candidate('Tuesday May 29, 8pm') == 'Tuesday May 29'\n    assert candidate('Wed September 1, 3am') == 'Wed September 1'\n    assert candidate('Friday May 2, 9am') == 'Friday May 2'\n    assert candidate('Tuesday January 29, 10pm') == 'Tuesday January 29'\n\n","canonical_solution":"def shorten_to_date(long_date):\n    return long_date.split(',')[0]"}
{"task_id":4276,"prompt":"\"\"\"\n=====Problem statement====\n\nRound any given number to the closest 0.5 step\n\nI.E.\n```\nsolution(4.2) = 4\nsolution(4.3) = 4.5\nsolution(4.6) = 4.5\nsolution(4.8) = 5\n```\n\nRound **up** if number is as close to previous and next 0.5 steps.\n\n```\nsolution(4.75) == 5\n```\n\"\"\"\n\n# ====== Solution ======\n\nimport math\ndef solution(n):\n","entry_point":"solution","test":"def check(candidate):\n    assert candidate(4.2) == 4\n    assert candidate(4.25) == 4.5\n    assert candidate(4.4) == 4.5\n    assert candidate(4.6) == 4.5\n    assert candidate(4.75) == 5\n    assert candidate(4.8) == 5\n    assert candidate(4.5) == 4.5\n    assert candidate(4.55) == 4.5\n    assert candidate(4.74) == 4.5\n    assert candidate(4.74999999999) == 4.5\n    assert candidate(4.74999999991) == 4.5\n\n","canonical_solution":"import math\ndef solution(n):\n    d=0\n    if n - 0.25< math.floor(n):\n        d=math.floor(n)\n    elif n - 0.75< math.floor(n):\n        d=math.floor(n)+0.5\n    else:\n        d=math.ceil(n)\n    return d"}
{"task_id":4285,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven an array of 4 integers  \n```[a,b,c,d]``` representing two points ```(a, b)``` and ```(c, d)```, return a string representation of the slope of the line joining these two points. \n\nFor an undefined slope (division by 0), return  ```undefined```  . Note that the \"undefined\" is case-sensitive.\n```\n   a:x1\n   b:y1\n   c:x2\n   d:y2\n```\n   \nAssume that ```[a,b,c,d]``` and the answer are all integers \n(no floating numbers!).\nSlope:\n\"\"\"\n\n# ====== Solution ======\n\ndef find_slope(points):\n","entry_point":"find_slope","test":"def check(candidate):\n    assert candidate([12, -18, -15, -18]) == '0'\n    assert candidate([3, -20, 5, 8]) == '14'\n    assert candidate([17, -3, 17, 8]) == 'undefined'\n    assert candidate([1, -19, -2, -7]) == '-4'\n    assert candidate([19, 3, 20, 3]) == '0'\n    assert candidate([6, -12, 15, -3]) == '1'\n    assert candidate([15, -3, 15, -3]) == 'undefined'\n    assert candidate([9, 3, 19, -17]) == '-2'\n    assert candidate([3, 6, 4, 10]) == '4'\n    assert candidate([2, 7, 4, -7]) == '-7'\n    assert candidate([1, 24, 2, 88]) == '64'\n    assert candidate([4, 384, 8, 768]) == '96'\n    assert candidate([4, 16, 4, 18]) == 'undefined'\n    assert candidate([7, 28, 9, 64]) == '18'\n    assert candidate([18, -36, 12, 36]) == '-12'\n    assert candidate([36, 580, 42, 40]) == '-90'\n    assert candidate([1, 2, 2, 6]) == '4'\n    assert candidate([-6, 57, -6, 84]) == 'undefined'\n    assert candidate([92, 12, 96, 64]) == '13'\n    assert candidate([90, 54, 90, 2]) == 'undefined'\n    assert candidate([3, 6, 4, 9]) == '3'\n    assert candidate([-2, -5, 2, 3]) == '2'\n    assert candidate([3, 3, 2, 0]) == '3'\n\n","canonical_solution":"def find_slope(points):\n    x1, y1, x2, y2 = points\n    if x2 - x1 == 0:\n        return \"undefined\"\n    return str((y2 - y1) \/\/ (x2 - x1))"}
{"task_id":4287,"prompt":"\"\"\"\n=====Problem statement====\n\nJohnny is a farmer and he annually holds a beet farmers convention \"Drop the beet\".\n\nEvery year he takes photos of farmers handshaking. Johnny knows that no two farmers handshake more than once. He also knows that some of the possible handshake combinations may not happen.\n\nHowever, Johnny would like to know the minimal amount of people that participated this year just by counting all the handshakes.\n\nHelp Johnny by writing a function, that takes the amount of handshakes and returns the minimal amount of people needed to perform these handshakes (a pair of farmers handshake only once).\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil\n\ndef get_participants(h):\n","entry_point":"get_participants","test":"def check(candidate):\n    assert candidate(0) == 1\n    assert candidate(1) == 2\n    assert candidate(3) == 3\n    assert candidate(6) == 4\n    assert candidate(7) == 5\n\n","canonical_solution":"from math import ceil\n\ndef get_participants(h):\n    return int(ceil(0.5 + (0.25 + 2 * h) ** 0.5))\n"}
{"task_id":4291,"prompt":"\"\"\"\n=====Problem statement====\n\n# Introduction\n\nThe first century spans from the **year 1** *up to* and **including the year 100**, **The second** - *from the year 101 up to and including the year 200*, etc.\n\n# Task : \nGiven a year, return the century it is in.\n\"\"\"\n\n# ====== Solution ======\n\ndef century(year):\n","entry_point":"century","test":"def check(candidate):\n    assert candidate(1705) == 18\n    assert candidate(1900) == 19\n    assert candidate(1601) == 17\n    assert candidate(2000) == 20\n    assert candidate(356) == 4\n    assert candidate(89) == 1\n\n","canonical_solution":"def century(year):\n    return (year + 99) \/\/ 100"}
{"task_id":4293,"prompt":"\"\"\"\n=====Problem statement====\n\nYou just got done with your set at the gym, and you are wondering how much weight you could lift if you did a single repetition. Thankfully, a few scholars have devised formulas for this purpose (from [Wikipedia](https:\/\/en.wikipedia.org\/wiki\/One-repetition_maximum)) :\n\n\n### Epley\n\n\n### McGlothin\n\n\n### Lombardi\n\n\nYour function will receive a weight `w` and a number of repetitions `r` and must return your projected one repetition maximum. Since you are not sure which formula to use and you are feeling confident, your function will return the largest value from the three formulas shown above, rounded to the nearest integer. However, if the number of repetitions passed in is `1` (i.e., it is already a one rep max), your function must return `w`. Also, if the number of repetitions passed in is `0` (i.e., no repetitions were completed), your function must return `0`.\n\"\"\"\n\n# ====== Solution ======\n\ndef calculate_1RM(w, r):\n","entry_point":"calculate_1RM","test":"def check(candidate):\n    assert candidate(135,20) == 282\n    assert candidate(200,8) == 253\n    assert candidate(270,2) == 289\n    assert candidate(360,1) == 360\n    assert candidate(400,0) == 0\n\n","canonical_solution":"def calculate_1RM(w, r):\n    if r == 0: return 0\n    if r == 1: return w\n    \n    return round(max([\n      w * (1 + r \/ 30),                 # Epley\n      100 * w \/ (101.3 - 2.67123 * r),  # McGlothin\n      w * r**0.10                       # Lombardi\n      ]))"}
{"task_id":4297,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function getMean that takes as parameters an array (arr) and 2 integers (x and y). The function should return the mean between the mean of the the first x elements of the array and the mean of the last y elements of the array.\n\nThe mean should be computed if both x and y have values higher than 1 but less or equal to the array's length. Otherwise the function should return -1.\n\ngetMean([1,3,2,4], 2, 3) should return 2.5 because: the mean of the the first 2 elements of the array is (1+3)\/2=2 and the mean of the last 3 elements of the array is (4+2+3)\/3=3 so the mean of those 2 means is (2+3)\/2=2.5.\n\ngetMean([1,3,2,4], 1, 2) should return -1 because x is not higher than 1.\n\ngetMean([1,3,2,4], 2, 8) should return -1 because 8 is higher than the array's length.\n\"\"\"\n\n# ====== Solution ======\n\ndef get_mean(arr,x,y):\n","entry_point":"get_mean","test":"def check(candidate):\n    assert candidate([1, 3, 2, 4],2,3) == 2.5\n    assert candidate([1, 3, 2],2,2) == 2.25\n    assert candidate([1, 3, 2, 4],1,2) == -1\n    assert candidate([1, 3, 2, 4],2,8) == -1\n    assert candidate([1, -1, 2, -1],2,3) == 0\n\n","canonical_solution":"def get_mean(arr,x,y):\n    if 1 < x <= len(arr) and 1 < y <= len(arr):\n       return (sum(arr[:x])\/x+sum(arr[-y:])\/y)\/2\n    return -1"}
{"task_id":4299,"prompt":"\"\"\"\n=====Problem statement====\n\nA number `n` is called `prime happy` if there is at least one prime less than `n` and the `sum of all primes less than n` is evenly divisible by `n`. Write `isPrimeHappy(n)` which returns `true` if `n` is `prime happy` else `false`.\n\"\"\"\n\n# ====== Solution ======\n\ndef is_prime_happy(n):\n","entry_point":"is_prime_happy","test":"def check(candidate):\n    assert candidate(5) == True\n    assert candidate(8) == False\n    assert candidate(25) == True\n    assert candidate(32) == True\n    assert candidate(2) == False\n    assert candidate(0) == False\n\n","canonical_solution":"def is_prime_happy(n):\n    return n in [5, 25, 32, 71, 2745, 10623, 63201, 85868]"}
{"task_id":4315,"prompt":"\"\"\"\n=====Problem statement====\n\nFor all x in the range of integers [0, 2 ** n), let y[x] be the binary exclusive-or of x and x \/\/ 2. Find the sum of all numbers in y.\n\nWrite a function sum_them that, given n, will return the value of the above sum.\n\nThis can be implemented a simple loop as shown in the initial code. But once n starts getting to higher numbers, such as 2000 (which will be tested), the loop is too slow.\n\nThere is a simple solution that can quickly find the sum. Find it!\n\nAssume that n is a nonnegative integer.\n\nHint: The complete solution can be written in two lines.\n\"\"\"\n\n# ====== Solution ======\n\ndef sum_them(n):\n","entry_point":"sum_them","test":"def check(candidate):\n    assert candidate(0) == 0\n    assert candidate(1) == 1\n    assert candidate(2) == 6\n    assert candidate(3) == 28\n    assert candidate(4) == 120\n\n","canonical_solution":"def sum_them(n):\n    return 2 ** (n - 1) * (2 ** n - 1)"}
{"task_id":4317,"prompt":"\"\"\"\n=====Problem statement====\n\nL\u0435t's create function to play cards. Our rules:\n\nWe have the preloaded `deck`:\n\n```\ndeck = ['joker','2\u2663','3\u2663','4\u2663','5\u2663','6\u2663','7\u2663','8\u2663','9\u2663','10\u2663','J\u2663','Q\u2663','K\u2663','A\u2663',\n                '2\u2666','3\u2666','4\u2666','5\u2666','6\u2666','7\u2666','8\u2666','9\u2666','10\u2666','J\u2666','Q\u2666','K\u2666','A\u2666',\n                '2\u2665','3\u2665','4\u2665','5\u2665','6\u2665','7\u2665','8\u2665','9\u2665','10\u2665','J\u2665','Q\u2665','K\u2665','A\u2665',\n                '2\u2660','3\u2660','4\u2660','5\u2660','6\u2660','7\u2660','8\u2660','9\u2660','10\u2660','J\u2660','Q\u2660','K\u2660','A\u2660']\n```\n\nWe have 3 arguments:\n\n`card1` and `card2` - any card of our deck.\n\n`trump` - the main suit of four ('\u2663', '\u2666', '\u2665', '\u2660').\n\nIf both cards have the same suit, the big one wins.\n\nIf the cards have different suits (and no one has trump) return 'Let's play again.'\n\nIf one card has `trump` unlike another, wins the first one.\n\nIf both cards have `trump`, the big one wins.\n\nIf `card1` wins, return 'The first card won.' and vice versa.\n\nIf the cards are equal, return 'Someone cheats.'\n\nA few games:\n\n```\n('3\u2663', 'Q\u2663', '\u2666') -> 'The second card won.'\n\n('5\u2665', 'A\u2663', '\u2666') -> 'Let us play again.'\n\n('8\u2660', '8\u2660', '\u2663') -> 'Someone cheats.'\n\n('2\u2666', 'A\u2660', '\u2666') -> 'The first card won.'\n\n('joker', 'joker', '\u2666') -> 'Someone cheats.'\n\n```\nP.S. As a card you can also get the string 'joker' - it means this card always wins.\n\"\"\"\n\n# ====== Solution ======\n\nvals='2345678910JQKA'\ndef card_game(card_1, card_2, trump):\n","entry_point":"card_game","test":"def check(candidate):\n    assert candidate('Q\u2663','3\u2663','\u2666') == 'The first card won.'\n    assert candidate('3\u2663','Q\u2663','\u2666') == 'The second card won.'\n    assert candidate('5\u2665','A\u2663','\u2666') == 'Let us play again.'\n    assert candidate('8\u2660','8\u2660','\u2663') == 'Someone cheats.'\n    assert candidate('2\u2666','A\u2660','\u2666') == 'The first card won.'\n    assert candidate('A\u2660','2\u2666','\u2666') == 'The second card won.'\n    assert candidate('joker','joker','\u2666') == 'Someone cheats.'\n    assert candidate('joker','10\u2663','\u2660') == 'The first card won.'\n    assert candidate('10\u2663','joker','\u2660') == 'The second card won.'\n\n","canonical_solution":"vals='2345678910JQKA'\ndef card_game(card_1, card_2, trump):\n    print((card_1, card_2, trump))\n    if card_1==card_2: return 'Someone cheats.'\n    elif 'joker' in [card_1,card_2]:\n        return ['The first card won.', 'The second card won.'][card_1!='joker']\n    elif card_1[-1]==card_2[-1]:\n        return ['The first card won.', 'The second card won.'][vals.index(card_2[0])>vals.index(card_1[0])]\n    elif card_1[-1]!=trump!=card_2[-1]:\n        return 'Let us play again.'\n    else:\n        return ['The first card won.', 'The second card won.'][card_1[-1]!=trump]"}
{"task_id":4318,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that takes two arguments, and returns a new array populated with the elements **that only appear once, in either one array or the other, taken only once**; display order should follow what appears in arr1 first, then arr2: \n\n```python\nhot_singles([1, 2, 3, 3], [3, 2, 1, 4, 5]) # [4, 5]\nhot_singles([\"tartar\", \"blanket\", \"cinnamon\"], [\"cinnamon\", \"blanket\", \"domino\"]) # [\"tartar\", \"domino\"]\nhot_singles([77, \"ciao\"], [78, 42, \"ciao\"]) # [77, 78, 42]\nhot_singles([1, 2, 3, 3], [3, 2, 1, 4, 5, 4]) # [4,5]\n```\n\nSPECIAL THANKS: @JulianKolbe !\n\"\"\"\n\n# ====== Solution ======\n\ndef hot_singles(arr1, arr2):\n","entry_point":"hot_singles","test":"def check(candidate):\n    assert candidate(['tartar', 'blanket', 'domino'],['blanket']) == ['tartar', 'domino']\n    assert candidate([77, 'basketweave'],[78, 42, 'basketweave']) == [77, 78, 42]\n    assert candidate([100, 45, 'ciao'],[100, 2, 3, 45, 5]) == ['ciao', 2, 3, 5]\n    assert candidate([10, 200, 30],[10, 20, 3, 4, 5, 5, 5, 200]) == [30, 20, 3, 4, 5]\n    assert candidate([1, 2, 3, 3],[3, 2, 1, 4, 5, 4]) == [4, 5]\n\n","canonical_solution":"def hot_singles(arr1, arr2):\n    a = []\n    for x in arr1 + arr2:\n        if x in set(arr1) ^ set(arr2) and x not in a: a.append(x)\n    return a"}
{"task_id":4319,"prompt":"\"\"\"\n=====Problem statement====\n\nGigi is a clever monkey, living in the zoo, his teacher (animal keeper) recently taught him some knowledge of \"0\".\n\nIn Gigi's eyes, \"0\" is a character contains some circle(maybe one, maybe two).\n\nSo, a is a \"0\",b is a \"0\",6 is also a \"0\"\uff0cand 8 have two \"0\" ,etc...\n\nNow, write some code to count how many \"0\"s in the text.\n\nLet us see who is smarter? You ? or monkey?\n\nInput always be a string(including words numbers and symbols)\uff0cYou don't need to verify it, but pay attention to the difference between uppercase and lowercase letters.\n\nHere is a table of characters\uff1a\n\none zeroabdegopq069DOPQR \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 () <-- A pair of braces as a zerotwo zero%&B8\n\nOutput will be a number of \"0\".\n\"\"\"\n\n# ====== Solution ======\n\ndef countzero(s):\n","entry_point":"countzero","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('0') == 1\n    assert candidate('0oO0oO') == 6\n    assert candidate('1234567890') == 5\n    assert candidate('abcdefghijklmnopqrstuvwxyz') == 8\n    assert candidate('()') == 1\n    assert candidate('E') == 0\n    assert candidate('aA') == 1\n    assert candidate('BRA') == 3\n    assert candidate('%%') == 4\n\n","canonical_solution":"def countzero(s):\n    return sum(1 if c in 'abdegopq069DOPQR' else 2 if c in '%&B8' else 0 for c in s.replace('()', '0'))"}
{"task_id":4326,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are given a sequence of a journey in London, UK. The sequence will contain bus **numbers** and TFL tube names as **strings** e.g.\n\n```python\n['Northern', 'Central', 243, 1, 'Victoria']\n```\nJourneys will always only contain a combination of tube names and bus numbers. Each tube journey costs `\u00a32.40` and each bus journey costs `\u00a31.50`. If there are `2` or more adjacent bus journeys, the bus fare is capped for sets of two adjacent buses and calculated as one bus fare for each set.\n\nYour task is to calculate the total cost of the journey and return the cost `rounded to 2 decimal places` in the format (where x is a number): `\u00a3x.xx`\n\"\"\"\n\n# ====== Solution ======\n\ndef london_city_hacker(journey): \n","entry_point":"london_city_hacker","test":"def check(candidate):\n    assert candidate([12, 'Central', 'Circle', 21]) == '\u00a37.80'\n    assert candidate(['Piccidilly', 56]) == '\u00a33.90'\n    assert candidate(['Northern', 'Central', 'Circle']) == '\u00a37.20'\n    assert candidate(['Piccidilly', 56, 93, 243]) == '\u00a35.40'\n    assert candidate([386, 56, 1, 876]) == '\u00a33.00'\n    assert candidate([]) == '\u00a30.00'\n\n","canonical_solution":"def london_city_hacker(journey): \n    # your code here\n    tube = 2.40\n    bus = 1.50\n    total_cost = 0.00\n    count = 0\n    for link in journey:\n        if isinstance(link, str):\n            total_cost += tube\n            count = 0\n        else:\n            if count == 0:\n                total_cost += bus\n                count +=1\n            else:\n                count = 0\n    return '\u00a3{:.2f}'.format(total_cost)\n"}
{"task_id":4332,"prompt":"\"\"\"\n=====Problem statement====\n\n*This kata is based on [Project Euler Problem #349](https:\/\/projecteuler.net\/problem=349). You may want to start with solving [this kata](https:\/\/www.codewars.com\/kata\/langtons-ant) first.*\n\n---\n\n[Langton's ant](https:\/\/en.wikipedia.org\/wiki\/Langton%27s_ant) moves on a regular grid of squares that are coloured either black or white.\nThe ant is always oriented in one of the cardinal directions (left, right, up or down) and moves  according to the following rules:\n- if it is on a black square, it flips the colour of the square to white, rotates 90 degrees counterclockwise and moves forward one square.\n- if it is on a white square, it flips the colour of the square to black, rotates 90 degrees clockwise and moves forward one square.\n\nStarting with a grid that is **entirely white**, how many squares are black after `n` moves of the ant?\n\n**Note:** `n` will go as high as 10^(20)\n\n---\n\n## My other katas\n\nIf you enjoyed this kata then please try [my other katas](https:\/\/www.codewars.com\/collections\/katas-created-by-anter69)! :-)\n\n#### *Translations are welcome!*\n\"\"\"\n\n# ====== Solution ======\n\nmove = [lambda p: (p[0]+1, p[1]), lambda p: (p[0], p[1]+1), lambda p: (p[0]-1, p[1]), lambda p: (p[0], p[1]-1)]\nstart, loop, size = 9977, 104, 12\n\ndef langtons_ant(n):\n","entry_point":"langtons_ant","test":"def check(candidate):\n    assert candidate(0) == 0\n    assert candidate(1) == 1\n    assert candidate(2) == 2\n    assert candidate(10) == 6\n    assert candidate(100) == 20\n    assert candidate(1000) == 118\n    assert candidate(10000) == 720\n    assert candidate(100000) == 11108\n    assert candidate(1000000) == 114952\n    assert candidate(10000000) == 1153412\n\n","canonical_solution":"move = [lambda p: (p[0]+1, p[1]), lambda p: (p[0], p[1]+1), lambda p: (p[0]-1, p[1]), lambda p: (p[0], p[1]-1)]\nstart, loop, size = 9977, 104, 12\n\ndef langtons_ant(n):\n    pos, d, black, res = (0, 0), 0, set(), 0\n    if n > start:\n        x = (n - start)%loop\n        res = size * (n-start-x)\/\/loop\n        n = start + x\n    for i in range(n):\n        if pos in black:\n            black.remove(pos)\n            d = (d+1)%4\n        else:\n            black.add(pos)\n            d = (d-1)%4\n        pos = move[d](pos)\n    return res + len(black)"}
{"task_id":4339,"prompt":"\"\"\"\n=====Problem statement====\n\nImplement function which will return sum of roots of a quadratic equation rounded to 2 decimal places, if there are any possible roots, else return **None\/null\/nil\/nothing**. If you use discriminant,when discriminant = 0, x1 = x2 = root => return sum of both roots. There will always be valid arguments. \n\nQuadratic equation - https:\/\/en.wikipedia.org\/wiki\/Quadratic_equation\n\"\"\"\n\n# ====== Solution ======\n\ndef roots(a,b,c):\n","entry_point":"roots","test":"def check(candidate):\n    assert candidate(1,-35,-23) == 35\n    assert candidate(6,0,-24) == 0\n    assert candidate(-5,21,0) == 4.2\n    assert candidate(6,4,8) == None\n    assert candidate(1,5,-24) == -5\n    assert candidate(3,11,6) == -3.67\n    assert candidate(2,2,9) == None\n    assert candidate(1,-1.6666666666666667,-26) == 1.67\n    assert candidate(1,6,10) == None\n    assert candidate(7,-2,-5) == 0.29\n    assert candidate(1,8,20) == None\n    assert candidate(2,3,-2) == -1.5\n    assert candidate(1,4,12) == None\n    assert candidate(3,-2,-5) == 0.67\n    assert candidate(3,4,9) == None\n    assert candidate(5,4,0) == -0.8\n    assert candidate(4,-5,0) == 1.25\n    assert candidate(1,4,9) == None\n    assert candidate(1,0,-49) == 0\n    assert candidate(2,8,8) == -4\n    assert candidate(1,0,-0.16) == 0\n    assert candidate(1,6,12) == None\n    assert candidate(1,0,-9) == 0\n    assert candidate(-3,0,12) == 0\n    assert candidate(1,3,9) == None\n    assert candidate(3,7,0) == -2.33\n    assert candidate(5,3,6) == None\n    assert candidate(1,4,4) == -4\n    assert candidate(-1,0,5.29) == 0\n    assert candidate(1,12,36) == -12\n    assert candidate(1,0,-0.09) == 0\n    assert candidate(2,5,11) == None\n    assert candidate(3,0,-15) == 0\n    assert candidate(1,-3,0) == 3\n    assert candidate(1,8,16) == -8\n    assert candidate(2,6,9) == None\n    assert candidate(-1,36,0) == 36\n    assert candidate(5,-8,0) == 1.6\n    assert candidate(1,5,12) == None\n    assert candidate(-14,0,0) == 0\n    assert candidate(1,7,20) == None\n    assert candidate(1,-6,0) == 6\n    assert candidate(1,-11,30) == 11\n    assert candidate(1,3,12) == None\n    assert candidate(1,6,9) == -6\n    assert candidate(8,47,41) == -5.88\n\n","canonical_solution":"def roots(a,b,c):\n    if b**2>=4*a*c:\n        return round(-b\/a,2)"}
{"task_id":4342,"prompt":"\"\"\"\n=====Problem statement====\n\nSimple, remove the spaces from the string, then return the resultant string.\n\n~~~if:c\nFor C, you must return a new dynamically allocated string.\n~~~\n\"\"\"\n\n# ====== Solution ======\n\ndef no_space(x):\n","entry_point":"no_space","test":"def check(candidate):\n    assert candidate('8 j 8   mBliB8g  imjB8B8  jl  B') == '8j8mBliB8gimjB8B8jlB'\n    assert candidate('8 8 Bi fk8h B 8 BB8B B B  B888 c hl8 BhB fd') == '88Bifk8hB8BB8BBBB888chl8BhBfd'\n    assert candidate('8aaaaa dddd r     ') == '8aaaaaddddr'\n    assert candidate('jfBm  gk lf8hg  88lbe8 ') == 'jfBmgklf8hg88lbe8'\n    assert candidate('8j aam') == '8jaam'\n\n","canonical_solution":"def no_space(x):\n    return x.replace(' ' ,'')"}
{"task_id":4345,"prompt":"\"\"\"\n=====Problem statement====\n\nYou will be given a fruit which a farmer has harvested, your job is to see if you should buy or sell.\n\nYou will be given 3 pairs of fruit. Your task is to trade your harvested fruit back into your harvested fruit via the intermediate pair, you should return a string of 3 actions.\n\nif you have harvested apples, you would buy this fruit pair: apple_orange, if you have harvested oranges, you would sell that fruit pair.\n\n(In other words, to go from left to right (apples to oranges) you buy, and to go from right to left you sell (oranges to apple))\n\ne.g. \napple_orange, orange_pear, apple_pear\n1. if you have harvested apples, you would buy this fruit pair: apple_orange\n2. Then you have oranges, so again you would buy this fruit pair: orange_pear\n3. After you have pear, but now this time you would sell this fruit pair: apple_pear\n4. Finally you are back with the apples\n\nSo your function would return a list: [\u201cbuy\u201d,\u201dbuy\u201d,\u201dsell\u201d]\n\nIf any invalid input is given, \"ERROR\" should be returned\n\"\"\"\n\n# ====== Solution ======\n\ndef buy_or_sell(pairs, harvested_fruit):\n","entry_point":"buy_or_sell","test":"def check(candidate):\n    assert candidate([['apple', 'orange'], ['orange', 'pear'], ['apple', 'pear']],'apple') == ['buy', 'buy', 'sell']\n    assert candidate([['orange', 'apple'], ['orange', 'pear'], ['pear', 'apple']],'apple') == ['sell', 'buy', 'buy']\n    assert candidate([['apple', 'orange'], ['pear', 'orange'], ['apple', 'pear']],'apple') == ['buy', 'sell', 'sell']\n    assert candidate([['orange', 'apple'], ['pear', 'orange'], ['pear', 'apple']],'apple') == ['sell', 'sell', 'buy']\n    assert candidate([['orange', 'apple'], ['orange', 'pear'], ['apple', 'pear']],'apple') == ['sell', 'buy', 'sell']\n    assert candidate([['apple', 'orange'], ['pear', 'orange'], ['pear', 'apple']],'apple') == ['buy', 'sell', 'buy']\n    assert candidate([['apple', 'orange'], ['orange', 'pear'], ['pear', 'apple']],'apple') == ['buy', 'buy', 'buy']\n    assert candidate([['orange', 'apple'], ['pear', 'orange'], ['apple', 'pear']],'apple') == ['sell', 'sell', 'sell']\n    assert candidate([['orange', 'apple'], ['pear', 'orange'], ['apple', 'paer']],'apple') == 'ERROR'\n\n","canonical_solution":"def buy_or_sell(pairs, harvested_fruit):\n    \n    currentFruit = harvested_fruit\n    actions = list()\n    \n    for pair in pairs:\n    \n        if currentFruit not in pair: return 'ERROR'\n    \n        if currentFruit == pair[0]:\n        \n            actions.append('buy')\n            currentFruit = pair[1]\n            \n        else:\n        \n            actions.append('sell')\n            currentFruit = pair[0]\n            \n    return actions"}
{"task_id":4346,"prompt":"\"\"\"\n=====Problem statement====\n\nMaya writes weekly articles to a well known magazine, but she is missing one word each time she is about to send the article to the editor. The article is not complete without this word. Maya has a friend, Dan, and he is very good with words, but he doesn't like to just give them away. He texts Maya a number and she needs to find out the hidden word. \nThe words can contain only the letter: \"a\", \"b\", \"d\", \"e\", \"i\", \"l\", \"m\", \"n\", \"o\", and \"t\".\n\nLuckily, Maya has the key:\n\n\"a\" - 6\n\"b\" - 1 \n\"d\" - 7\n\"e\" - 4\n\"i\" - 3\n\"l\" - 2\n\"m\" - 9\n\"n\" - 8\n\"o\" - 0\n\"t\" - 5\n\nYou can help Maya by writing a function that will take a number between 100 and 999999 and return a string with the word. \n\nThe input is always a number, contains only the numbers in the key. \nThe output should be always a string with one word, all lowercase.\n\nMaya won't forget to thank you at the end of her article :)\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"hidden","test":"def check(candidate):\n    assert candidate(637) == 'aid'\n    assert candidate(7468) == 'dean'\n    assert candidate(49632) == 'email'\n    assert candidate(1425) == 'belt'\n    assert candidate(6250) == 'alto'\n    assert candidate(12674) == 'blade'\n    assert candidate(4735) == 'edit'\n    assert candidate(7345) == 'diet'\n    assert candidate(3850) == 'into'\n    assert candidate(2394) == 'lime'\n    assert candidate(2068) == 'loan'\n    assert candidate(137) == 'bid'\n    assert candidate(1065) == 'boat'\n    assert candidate(6509) == 'atom'\n    assert candidate(3549) == 'item'\n    assert candidate(5394) == 'time'\n    assert candidate(56124) == 'table'\n    assert candidate(968) == 'man'\n    assert candidate(103247) == 'boiled'\n    assert candidate(67935) == 'admit'\n    assert candidate(7415) == 'debt'\n    assert candidate(2687) == 'land'\n    assert candidate(261) == 'lab'\n    assert candidate(8054) == 'note'\n    assert candidate(942547) == 'melted'\n\n","canonical_solution":"hidden=lambda n: \"\".join(\"oblietadnm\"[int(d)] for d in str(n))"}
{"task_id":4350,"prompt":"\"\"\"\n=====Problem statement====\n\nThis is the first step to understanding FizzBuzz.  \n\nYour inputs:\na positive integer, n, greater than or equal to one.\nn is provided, you have NO CONTROL over its value.\n\nYour expected output is an array of positive integers from 1 to n (inclusive).\n\nYour job is to write an algorithm that gets you from the input to the output.\n\"\"\"\n\n# ====== Solution ======\n\ndef pre_fizz(n):\n","entry_point":"pre_fizz","test":"def check(candidate):\n    assert candidate(1) == [1]\n    assert candidate(2) == [1, 2]\n    assert candidate(3) == [1, 2, 3]\n    assert candidate(4) == [1, 2, 3, 4]\n    assert candidate(5) == [1, 2, 3, 4, 5]\n\n","canonical_solution":"def pre_fizz(n):\n    #your code here\n    return list(range(1, n+1))"}
{"task_id":4353,"prompt":"\"\"\"\n=====Problem statement====\n\nThe objective is to disambiguate two given names: the original with another\n\nLet's start simple, and just work with plain ascii strings. \n\nThe function ```could_be``` is given the original name and another one to test\nagainst. \n\n```python\n# should return True if the other name could be the same person \n> could_be(\"Chuck Norris\", \"Chuck\")\nTrue\n\n# should False otherwise (whatever you may personnaly think)\n> could_be(\"Chuck Norris\", \"superman\")\nFalse\n``` \n\nLet's say your name is *Carlos Ray Norris*, your objective is to return True if\nthe other given name matches any combinaison of the original fullname:\n\n```python\ncould_be(\"Carlos Ray Norris\", \"Carlos Ray Norris\") : True\ncould_be(\"Carlos Ray Norris\", \"Carlos Ray\") : True\ncould_be(\"Carlos Ray Norris\", \"Norris\") : True\ncould_be(\"Carlos Ray Norris\", \"Norris Carlos\") : True\n```\n\nFor the sake of simplicity:\n\n * the function is case sensitive and accent sensitive for now\n * it is also punctuation sensitive\n * an empty other name should not match any original\n * an empty orginal name should not be matchable\n * the function is not symmetrical\n\nThe following matches should therefore fail:\n\n```python\ncould_be(\"Carlos Ray Norris\", \" \") : False\ncould_be(\"Carlos Ray Norris\", \"carlos\") : False\ncould_be(\"Carlos Ray Norris\", \"Norris!\") : False\ncould_be(\"Carlos Ray Norris\", \"Carlos-Ray Norris\") : False\ncould_be(\"Ray Norris\", \"Carlos Ray Norris\") : False\ncould_be(\"Carlos\", \"Carlos Ray Norris\") : False\n```\n\nToo easy ? Try the next steps: \n\n* [Author Disambiguation: a name is a Name!](https:\/\/www.codewars.com\/kata\/author-disambiguation-a-name-is-a-name)\n* or even harder: [Author Disambiguation: Signatures worth it](https:\/\/www.codewars.com\/kata\/author-disambiguation-signatures-worth-it)\n\"\"\"\n\n# ====== Solution ======\n\ndef could_be(original, another):\n","entry_point":"could_be","test":"def check(candidate):\n    assert candidate('Carlos Ray Norris','Carlos Ray Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos Ray') == True\n    assert candidate('Carlos Ray Norris','Ray Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos Norris') == True\n    assert candidate('Carlos Ray Norris','Norris') == True\n    assert candidate('Carlos Ray Norris','Carlos') == True\n    assert candidate('Carlos Ray Norris','Norris Carlos') == True\n    assert candidate('Carlos Ray Norris','Carlos Ray Norr') == False\n    assert candidate('Carlos Ray Norris','Ra Norris') == False\n    assert candidate('','C') == False\n    assert candidate('','') == False\n    assert candidate('Carlos Ray Norris',' ') == False\n    assert candidate('Carlos Ray Norris','carlos Ray Norris') == False\n    assert candidate('Carlos','carlos') == False\n    assert candidate('Carlos Ray Norris','Norris!') == False\n    assert candidate('Carlos Ray Norris','Carlos-Ray Norris') == False\n    assert candidate('Carlos Ray','Carlos Ray Norris') == False\n    assert candidate('Carlos','Carlos Ray Norris') == False\n\n","canonical_solution":"def could_be(original, another):\n    if not another.strip(): return False\n    return all(name in original.split() for name in another.split())"}
{"task_id":4360,"prompt":"\"\"\"\n=====Problem statement====\n\nHave a look at the following numbers.\n\n```\n n | score\n---+-------\n 1 |  50\n 2 |  150\n 3 |  300\n 4 |  500\n 5 |  750\n```\n\nCan you find a pattern in it? If so, then write a function `getScore(n)`\/`get_score(n)`\/`GetScore(n)` which returns the score for any positive number `n`:\n\n```c++\nint getScore(1) = return 50;\nint getScore(2) = return 150;\nint getScore(3) = return 300;\nint getScore(4) = return 500;\nint getScore(5) = return 750;\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef get_score(n):\n","entry_point":"get_score","test":"def check(candidate):\n    assert candidate(1) == 50\n    assert candidate(2) == 150\n    assert candidate(3) == 300\n    assert candidate(4) == 500\n    assert candidate(5) == 750\n    assert candidate(6) == 1050\n    assert candidate(7) == 1400\n    assert candidate(8) == 1800\n    assert candidate(9) == 2250\n    assert candidate(10) == 2750\n    assert candidate(20) == 10500\n    assert candidate(30) == 23250\n    assert candidate(100) == 252500\n    assert candidate(123) == 381300\n    assert candidate(1000) == 25025000\n    assert candidate(1234) == 38099750\n    assert candidate(10000) == 2500250000\n    assert candidate(12345) == 3810284250\n\n","canonical_solution":"def get_score(n):\n    return n * (n + 1) * 25"}
{"task_id":4365,"prompt":"\"\"\"\n=====Problem statement====\n\nAn isogram is a word that has no repeating letters, consecutive or non-consecutive. Implement a function that determines whether a string that contains only letters is an isogram. Assume the empty string is an isogram. Ignore letter case.\n\n```python\nis_isogram(\"Dermatoglyphics\" ) == true\nis_isogram(\"aba\" ) == false\nis_isogram(\"moOse\" ) == false # -- ignore letter case\n```\n```C\nis_isogram(\"Dermatoglyphics\" ) == true;\nis_isogram(\"aba\" ) == false;\nis_isogram(\"moOse\" ) == false; \/\/ -- ignore letter case\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef is_isogram(string):\n","entry_point":"is_isogram","test":"def check(candidate):\n    assert candidate('Dermatoglyphics') == True\n    assert candidate('isogram') == True\n    assert candidate('moose') == False\n    assert candidate('isIsogram') == False\n    assert candidate('aba') == False\n    assert candidate('moOse') == False\n    assert candidate('thumbscrewjapingly') == True\n    assert candidate('abcdefghijklmnopqrstuvwxyz') == True\n    assert candidate('abcdefghijklmnopqrstuwwxyz') == False\n    assert candidate('') == True\n\n","canonical_solution":"def is_isogram(string):\n    return len(string) == len(set(string.lower()))"}
{"task_id":4375,"prompt":"\"\"\"\n=====Problem statement====\n\nThe function is not returning the correct values. Can you figure out why?\n\n```python\nget_planet_name(3) # should return 'Earth'\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef get_planet_name(id):\n","entry_point":"get_planet_name","test":"def check(candidate):\n    assert candidate(2) == 'Venus'\n    assert candidate(5) == 'Jupiter'\n    assert candidate(3) == 'Earth'\n    assert candidate(4) == 'Mars'\n    assert candidate(8) == 'Neptune'\n    assert candidate(1) == 'Mercury'\n\n","canonical_solution":"def get_planet_name(id):\n    return {\n        1: \"Mercury\",\n        2: \"Venus\",\n        3: \"Earth\",\n        4: \"Mars\",\n        5: \"Jupiter\",\n        6: \"Saturn\",\n        7: \"Uranus\",\n        8: \"Neptune\",\n    }.get(id, None)"}
{"task_id":4387,"prompt":"\"\"\"\n=====Problem statement====\n\nPlease write a function that sums a list, but ignores any duplicate items in the list.\n\nFor instance, for the list [3, 4, 3, 6] , the function should return 10.\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import Counter\n\n\ndef sum_no_duplicates(nums):\n","entry_point":"sum_no_duplicates","test":"def check(candidate):\n    assert candidate([1, 1, 2, 3]) == 5\n    assert candidate([]) == 0\n    assert candidate([1, 1, 2, 2, 3]) == 3\n    assert candidate([5, 6, 10, 3, 10, 10, 6, 7, 0, 9, 1, 1, 6, 3, 1]) == 21\n    assert candidate([0, 10, 8, 9, 7, 3, 3, 9, 3, 6, 0]) == 31\n    assert candidate([0, 1, 4, 4, 0, 4, 2, 5, 9, 0, 10, 9, 0, 1, 2]) == 15\n    assert candidate([7, 2, 10, 9, 10, 2, 7, 3, 10, 8, 2, 5]) == 25\n    assert candidate([7, 2, 0, 3, 5, 7, 8, 3, 2, 10, 9, 5]) == 27\n    assert candidate([1, 9, 9, 5, 7, 7, 6, 1, 5, 6]) == 0\n    assert candidate([10, 10, 1, 4, 10, 3, 9, 6, 10, 10, 9, 9, 10, 5, 6, 10, 4, 1]) == 8\n    assert candidate([7, 10, 10, 9, 0, 2, 5, 10, 3, 8, 1, 4, 9, 9, 5, 8, 8, 8, 5, 3]) == 14\n    assert candidate([1, 9, 2, 1, 5, 5, 1, 1, 5, 10, 5, 9, 5, 2, 1]) == 10\n    assert candidate([8, 6, 3, 6, 7, 3, 4, 4, 2, 1, 4, 5, 8, 6]) == 15\n    assert candidate([10, 9, 2, 8, 9, 10, 4, 6, 9, 5, 1, 1, 4, 3, 9, 7, 8, 5, 5]) == 18\n    assert candidate([5, 5, 0, 0, 6, 3, 7, 2, 4, 2]) == 20\n    assert candidate([0, 8, 5, 10, 1, 1, 6, 8]) == 21\n    assert candidate([4, 2, 10, 9, 10, 5, 1, 7, 1, 9, 8, 7, 4, 2, 5, 8, 3, 10, 8]) == 3\n    assert candidate([9, 8, 3, 1, 8, 1, 7]) == 19\n    assert candidate([1, 4, 3, 8, 9, 4, 7, 5, 10, 10, 7, 6, 9, 3]) == 20\n    assert candidate([2, 0, 4, 2, 2, 3, 6, 7, 3, 8, 10, 6, 8]) == 21\n    assert candidate([7, 9, 5, 6, 1, 0, 5, 0, 4, 7, 1, 2, 8, 9, 6, 1]) == 14\n    assert candidate([7, 1, 8, 8, 5, 5, 1, 4, 0, 1, 10, 1]) == 21\n    assert candidate([9, 7, 6, 2, 5, 3, 2, 4, 6, 10, 0, 3, 0, 4, 6, 1, 9, 9, 2, 4, 7, 5, 1, 0, 6, 0, 4, 4, 10, 10, 4, 6, 0, 2, 1, 7, 5, 6, 6, 0, 6, 7, 9, 6, 8, 2, 6, 1, 10, 2, 8, 3, 9]) == 0\n    assert candidate([0, 10, 5, 7, 0, 3, 6, 9, 7, 6, 6, 10, 10, 6, 2, 1, 8, 0, 7, 2, 8, 9, 0, 3, 2, 5, 4, 6, 6, 6, 6, 2, 6, 3, 9, 3, 4, 6, 1, 6, 3, 9, 10, 5, 9, 10, 5, 4, 9, 0, 10, 5, 8, 4, 3, 4, 8]) == 0\n    assert candidate([5, 10, 5, 7, 2, 6, 1, 6, 2, 8, 10, 6, 9, 1, 1, 4, 4, 10, 1, 5, 4, 4, 8, 7, 7, 1, 7, 7, 6, 1, 9, 5, 2, 6, 5, 6, 3, 10, 4, 8, 10, 10, 2, 7, 9, 9, 3, 6, 1, 8, 9, 1, 3, 9, 4, 9, 0, 4, 8, 5, 8, 4, 1, 3, 3, 10, 2, 2, 10, 0, 10, 7, 7, 3, 0, 8, 0, 3, 7, 10, 7, 1, 10, 2, 4, 3, 5, 10, 7, 6, 6, 6, 2, 1, 8, 10, 9, 4, 1, 3, 6, 7, 1, 2, 5, 9, 6, 9, 9, 5, 7, 1, 7, 0, 1, 7, 5, 8, 5, 9, 3, 3, 3, 7, 1, 2, 10, 6, 0, 2, 4, 7, 3, 3, 8, 8, 3, 3, 2, 0, 3, 6]) == 0\n    assert candidate([9, 0, 5, 3, 2, 2, 10, 3, 2, 5, 4, 10, 5, 2, 1, 6, 2, 2, 7, 4, 7, 8, 10, 3, 8, 6, 4, 0, 9, 3, 3, 2, 8, 1, 5, 2, 3, 1, 9, 6, 0, 1, 4, 4, 7, 0, 4, 9, 4, 0, 10, 6, 10, 10, 3, 10, 9, 8, 5, 6, 6, 9, 7, 0, 7, 5, 10, 8, 3, 4, 1, 10, 5, 3, 2, 5, 5, 6, 10, 1, 7, 2, 8, 9, 9, 7, 4, 6, 6, 10, 1, 4, 6, 2, 9, 7, 10, 7, 2, 6, 9, 3, 8, 4, 3, 4, 9, 8, 5, 1, 6, 2, 9, 0, 3, 4, 5, 2, 3, 3, 5, 5, 4, 3, 2, 9, 1, 5, 1, 9, 2, 6, 8, 6, 6, 8, 2, 1, 9, 3, 7, 3, 0, 1, 7, 3, 0, 1, 8, 9, 3, 4, 1, 2, 9, 1, 10, 10, 8, 0, 8, 0, 3]) == 0\n    assert candidate([1, 7, 0, 2, 1, 1, 5, 10, 7, 5, 4, 5, 5, 2, 8, 5, 4, 9, 9, 7, 4, 9, 1, 7, 9, 7, 0, 3, 9, 8]) == 13\n    assert candidate([3, 10, 2, 3, 7, 5, 4, 8, 0, 1, 1, 6, 7, 3, 9, 9, 9, 3, 8, 5, 2, 4, 7]) == 16\n    assert candidate([9, 7, 7, 1, 7, 1, 9, 5, 4, 10, 1, 9, 6, 6, 3, 2, 0, 2, 7, 7, 5, 1]) == 17\n    assert candidate([2, 0, 7, 8, 1, 8, 10, 10, 10, 7, 2, 3, 0, 5, 5, 10, 4, 8, 0, 4, 4, 2, 5, 3, 8, 8, 8, 1, 4, 7, 7, 7, 7, 2, 10, 10, 8, 2, 0, 7, 2, 0, 6, 6, 0, 10, 9, 3, 7, 4, 2, 6, 7, 1, 0, 9, 1, 1, 3, 7, 3, 8, 10, 3, 6, 7, 5, 5, 8, 5, 0, 7, 10, 1, 3, 0, 9, 9, 1, 6, 5, 10, 6, 3, 10, 2, 9, 6, 7, 10, 9, 10, 4, 8, 6, 2, 7, 4, 6, 6, 7, 8, 5, 9]) == 0\n    assert candidate([5, 3, 1, 9, 7, 1, 3, 1, 5, 9, 7, 7, 2, 4, 2, 2, 3, 0, 0, 8, 6, 0, 0, 8, 0, 3, 0, 5, 8, 9, 6, 9, 5, 9, 3, 7, 7, 9, 0, 5, 6, 0, 7, 5, 9, 4, 7, 0, 4, 10, 4, 9, 1, 8, 0, 8, 9, 5, 10, 5, 10, 3, 10, 9, 8, 9, 1, 9, 9, 1, 9, 4, 0, 10, 2, 0, 0, 4, 7, 3, 2, 2, 9, 7, 5, 9, 2, 3, 10, 8, 3, 1, 7, 7, 5, 2]) == 0\n    assert candidate([4, 2, 10, 2, 1, 8, 3, 3, 6, 6, 5, 7, 4, 4, 1, 2, 8, 3, 0, 3, 10, 6, 1, 9, 2, 0, 3, 4, 6, 5, 9, 2, 5, 3, 4, 10, 5, 0, 6, 0, 9, 0, 2, 2, 0, 5, 9, 1, 8, 6, 3, 0, 4, 0, 9, 7, 7, 5, 10, 10, 5, 10, 5, 1, 6, 4, 10, 7, 10, 7, 7, 5, 4, 7, 7, 10, 8, 7, 8, 4, 6, 3, 5, 9, 7, 7, 2, 2, 4, 4, 2, 9, 7, 5, 10, 1, 3, 7, 3, 3, 1, 7, 10, 4, 6, 7, 9, 7, 10, 10, 7, 4, 8, 1, 2, 3, 0, 3, 1, 5, 9, 7, 2, 2, 2, 7, 7, 6, 3, 10]) == 0\n    assert candidate([10, 9, 6, 6, 8, 8, 5, 8, 7, 6, 6, 4, 1, 5, 3, 9, 9, 7, 10, 2, 7, 1, 7, 7, 4, 6, 10, 9, 10, 9, 1, 8, 10, 4, 7, 8, 1, 9, 10, 9, 0, 5, 10, 3, 9, 6, 3, 4, 6, 6, 10, 0, 9, 9, 2, 7, 3, 0, 1, 4, 9, 4, 10, 7, 1, 0, 8, 7, 1, 4, 6, 7, 3, 8, 9, 0, 1, 10, 9, 2, 1, 6, 5, 0, 1, 1, 1, 7, 0, 4, 8, 8, 9, 5, 2, 5, 2, 3, 8, 0, 10, 0, 3, 4, 6, 6, 1, 7, 5, 7, 2, 3, 1, 4, 2, 2, 3, 3, 0, 2, 5, 8, 10, 8, 2, 8]) == 0\n    assert candidate([6, 4, 4, 10, 8, 7, 7, 4, 1, 10, 0, 8, 9, 9, 4, 7, 4, 4, 1, 2, 7, 6, 9, 6, 10, 8, 7, 4, 7, 10, 3, 6, 3, 9, 4, 7, 3, 6, 5, 2, 1, 7, 8, 4, 0, 9, 3, 1, 4, 4, 10, 0, 6, 3, 2, 2, 5, 0, 5, 6, 0, 4, 5, 5, 1, 3, 9, 0, 5, 9, 5, 8, 5, 5, 7, 5, 7, 6, 8, 8, 8, 1, 4, 6, 3, 2, 2, 10, 4, 2, 6, 1, 4, 0, 8, 0, 9, 10, 0, 7, 3, 9, 10, 1, 1, 8, 5, 1, 7, 5, 8, 7, 1, 5, 4, 9, 3, 2, 2, 3, 2, 0, 10, 1, 0, 5, 6, 6, 2, 9, 5, 5, 3, 4, 2, 3]) == 0\n    assert candidate([9, 5, 6, 1, 3, 0, 7, 9, 0, 5, 5, 6, 3, 7, 6, 9, 10, 5, 10, 0, 4, 9, 10, 9, 0, 8, 3, 8, 5, 6, 3, 1, 5, 1, 2, 8, 8, 10, 4, 2, 6, 7, 9, 0, 9, 6, 4, 8, 0, 6, 0, 1, 4, 3, 2, 3, 7, 7, 0, 6, 4, 6, 5, 2, 6, 4, 2, 0, 7, 3, 5, 0, 2, 5, 7, 1, 9, 4, 10, 2, 4, 10, 4, 3, 5, 9, 10, 7, 10, 3, 6, 10, 1, 1, 3, 0, 0, 8, 1, 1, 2, 0, 2, 10, 4, 2, 6, 9, 3, 6, 4, 1, 9, 4, 0, 3, 1, 1, 4, 7, 10, 2, 8, 3, 2, 2, 0, 3, 6, 0, 6, 3, 10, 4, 6, 8, 10, 1, 7, 2, 9, 3, 10, 1, 10, 9, 9, 9, 7, 10, 2, 0, 9, 2, 7, 0, 0, 4, 6, 10, 7, 0, 8, 7, 6, 5, 3, 7, 1, 1, 1, 7, 8, 2, 8, 4, 7, 3, 5, 4, 8, 4, 8, 1, 1, 7, 10, 5, 8, 5, 5, 10]) == 0\n    assert candidate([7, 9, 10, 4, 2, 1, 1, 3, 7, 1, 2, 0, 9, 3, 9, 10, 8, 9, 10, 2, 8, 7, 1, 2, 3, 9, 6, 8, 3, 3, 3, 3, 2, 9, 6, 2, 5, 4, 3, 4, 4, 1, 4, 8, 2, 8, 9, 5, 5, 7, 9, 0, 7, 2, 3, 2, 3, 10, 7, 2, 1, 7, 5, 2, 6, 0, 9, 10, 6, 0, 10, 2, 1, 2, 5, 6, 3, 2, 1, 7, 0, 4, 9, 10, 3, 5, 4, 7, 6, 6, 9, 4, 6, 1, 7, 10, 0, 1, 4, 2, 3, 7, 4, 9, 2, 4, 0, 1, 9, 4, 5, 4, 0, 5, 8]) == 0\n    assert candidate([9, 4, 2, 0, 10, 9, 4, 1, 6, 3, 9, 9, 3, 4, 3, 2, 4, 3, 5, 0, 4, 6, 1, 4, 7, 3, 3, 6, 8, 6, 2, 7, 10, 5, 2, 1, 6, 8, 9, 10, 1, 9, 4, 3, 8, 8, 4, 6, 6, 2, 0, 8, 10, 8, 4, 6, 5, 9, 4, 6, 6, 2, 6, 5, 7, 7, 2, 7, 8, 5, 9, 6, 5, 8, 3, 2, 9, 2, 3, 2, 3, 1, 10, 4, 4, 1]) == 0\n    assert candidate([6, 7, 6, 6, 8, 0, 2, 0, 3, 2, 3, 0, 9, 10, 4, 8, 5, 1, 6, 3, 4, 3, 3, 4, 6, 8, 7, 6, 2, 2, 6, 9, 1, 9, 2, 1, 1, 0, 9, 9, 9, 4, 3, 6, 1, 2, 1, 9, 9, 9, 7, 4, 6, 6, 0, 8, 10, 9, 0, 7, 0, 7, 2, 4, 7, 9, 0, 4, 9, 3, 5, 7, 4, 6, 9, 1, 10, 10, 5, 0, 2, 3, 10, 10, 10, 2, 8, 7, 4, 8, 5, 10, 4, 9, 4, 5, 3, 9, 3, 5, 0, 0, 1, 9, 8, 5, 3, 2, 5, 0, 2, 0, 2, 6, 10, 0, 0, 4, 8, 10, 10, 5, 1, 3, 9, 5, 9, 8, 3, 9, 10, 8, 2, 4, 9, 10, 5, 8, 7, 2, 8, 2, 5, 0, 3, 3, 5, 7, 3, 9, 9, 0, 0, 8, 8, 3, 2, 2, 5, 2, 3, 3, 9, 6, 7, 10, 10, 5, 6, 8, 3, 7, 10, 9, 9, 0, 1, 2, 7, 0, 6, 2, 0, 10, 6, 0, 8, 1, 7, 3, 5, 10, 4, 8, 6, 3, 1, 3]) == 0\n    assert candidate([5, 3, 1, 5, 9, 6, 4, 10, 5, 2, 1, 6, 9, 4, 2, 2, 5, 10, 8, 2, 5, 10, 2, 0, 4, 0, 7, 0, 0, 9, 9, 8, 6, 9, 0, 7, 3, 2, 4, 6, 1, 8, 1, 8, 5]) == 0\n    assert candidate([7, 4, 3, 0, 7, 0, 0, 0, 6, 2, 5, 9, 10, 6, 1, 3, 6, 7, 2, 3, 5, 2, 9, 4, 7, 7, 7, 8, 9, 6, 10, 7, 6, 10, 10, 2, 2, 2, 7, 10, 0, 10, 4, 10, 6, 2, 0, 8, 10, 8, 7, 4, 3, 6, 8, 0, 7, 1, 10, 10, 2, 4, 4, 9, 5, 6, 8, 9, 3, 9, 4, 4, 5, 4, 2, 5, 5, 3, 10, 2, 4, 7]) == 0\n    assert candidate([4, 8, 6, 6, 7, 5, 9, 2, 2, 3, 1, 1, 1, 8, 1, 9, 6, 4, 8, 10, 9, 0, 7, 6, 10, 9, 0, 7, 6, 3, 5, 9, 10, 1, 4, 4, 10, 8, 4, 4, 1, 0, 5, 6, 8, 0, 2, 2, 0, 10, 3, 7, 1, 0, 6, 9, 5, 10, 9, 7, 3, 9, 9, 7, 10, 4, 5, 2, 7, 3, 8, 6, 0, 0, 8, 10, 0, 4, 3, 10, 3, 3, 1, 9, 7, 0, 5, 4, 10, 0, 10, 6, 6, 4, 0, 8, 3, 10, 1, 1, 10, 1, 0, 5, 7, 1, 1, 6, 8, 6, 3, 2, 0, 7, 0, 3, 9, 3, 7, 0, 8, 2, 0, 3, 3, 1, 6, 9, 4, 10, 5, 6, 4, 6, 1, 3, 0, 0, 3, 8, 1, 6, 8, 8, 1, 4, 3, 3, 9, 10, 4, 9, 3, 6, 4, 0, 7, 6, 0, 2, 2, 2, 1]) == 0\n    assert candidate([5, 2, 8, 1, 3, 3, 4, 4, 6, 1, 3, 4, 8, 3, 8, 1, 9, 1, 9, 3, 3, 3, 2, 1, 10, 5, 6, 5, 7, 5, 10, 10, 0, 3, 6, 1, 9, 8, 9, 5, 1, 1, 0, 7, 6, 2, 6, 10, 10, 1, 10, 9, 2, 10, 1, 3, 4, 3, 3, 4, 7, 0, 1, 10, 5, 1, 9, 10, 6, 10, 10, 2, 8, 1, 9, 7, 1, 9, 1, 2, 6, 9, 1, 3, 4, 2, 8, 0, 1, 7, 5, 4, 5, 10, 1, 6, 1, 9, 0, 9, 9, 1, 2, 6, 5, 4, 8, 9, 9, 10, 3, 10, 6, 1, 0, 0, 9, 4, 0, 2, 5, 4, 3, 6, 5, 2, 6, 0, 4, 0, 0, 6, 5, 4, 3, 6, 0, 7, 0, 9, 7, 6, 4, 6, 2, 7, 0, 4, 3, 4, 6, 1, 5, 5, 6, 4, 5, 9, 8, 3, 5, 10, 4, 0, 9, 1, 3, 5, 9, 8, 2, 6, 0, 0, 10, 9, 10, 10, 3, 2, 7, 8]) == 0\n\n","canonical_solution":"from collections import Counter\n\n\ndef sum_no_duplicates(nums):\n    return sum(k for k, v in list(Counter(nums).items()) if v == 1)\n"}
{"task_id":4388,"prompt":"\"\"\"\n=====Problem statement====\n\nIn this kata, you will make a function that converts between `camelCase`, `snake_case`, and `kebab-case`.\n\nYou must write a function that changes to a given case. It must be able to handle all three case types:\n\n```python\npy> change_case(\"snakeCase\", \"snake\")\n\"snake_case\"\npy> change_case(\"some-lisp-name\", \"camel\")\n\"someLispName\"\npy> change_case(\"map_to_all\", \"kebab\")\n\"map-to-all\"\npy> change_case(\"doHTMLRequest\", \"kebab\")\n\"do-h-t-m-l-request\"\npy> change_case(\"invalid-inPut_bad\", \"kebab\")\nNone\npy> change_case(\"valid-input\", \"huh???\")\nNone\npy> change_case(\"\", \"camel\")\n\"\"\n```\n\nYour function must deal with invalid input as shown, though it will only be passed strings. Furthermore, all valid identifiers will be lowercase except when necessary, in other words on word boundaries in `camelCase`.\n\n_**(Any translations would be greatly appreciated!)**_\n\"\"\"\n\n# ====== Solution ======\n\nimport re\n\ndef change_case(label, target):\n","entry_point":"change_case","test":"def check(candidate):\n    assert candidate('snakeCase','snake') == 'snake_case'\n    assert candidate('some-lisp-name','camel') == 'someLispName'\n    assert candidate('map_to_all','kebab') == 'map-to-all'\n    assert candidate('doHTMLRequest','kebab') == 'do-h-t-m-l-request'\n    assert candidate('invalid-inPut_bad','kebab') == None\n    assert candidate('valid-input','huh???') == None\n    assert candidate('','camel') == ''\n    assert candidate('snake-kebab_case','kebab') == None\n    assert candidate('snakeCamel_case','snake') == None\n    assert candidate('kebabCamel-case','snake') == None\n    assert candidate('case-Camel','kebab') == None\n\n","canonical_solution":"import re\n\ndef change_case(label, target):\n    if ('_' in label) + ('-' in label) + (label != label.lower()) > 1:\n        return\n    \n    if target == 'snake':\n        return re.sub('([A-Z])', r'_\\1', label.replace('-', '_')).lower()\n    \n    if target == 'kebab':\n        return re.sub('([A-Z])', r'-\\1', label.replace('_', '-')).lower()\n    \n    if target == 'camel':\n        return re.sub('([_-])([a-z])', lambda m: m.group(2).upper(), label)"}
{"task_id":4401,"prompt":"\"\"\"\n=====Problem statement====\n\nIn geometry, a cube is a three-dimensional solid object bounded by six square faces, facets or sides, with three meeting at each vertex.The cube is the only regular hexahedron and is one of the five Platonic solids. It has 12 edges, 6 faces and 8 vertices.The cube is also a square parallelepiped, an equilateral cuboid and a right rhombohedron. It is a regular square prism in three orientations, and a trigonal trapezohedron in four orientations. \n\nYou are given a task of finding a if the provided value is a perfect cube!\n\"\"\"\n\n# ====== Solution ======\n\ndef you_are_a_cube(cube):\n","entry_point":"you_are_a_cube","test":"def check(candidate):\n    assert candidate(27) == True\n    assert candidate(1) == True\n    assert candidate(2) == False\n    assert candidate(99) == False\n    assert candidate(64) == True\n\n","canonical_solution":"def you_are_a_cube(cube):\n    return round(cube ** (1\/3)) ** 3 == cube"}
{"task_id":4409,"prompt":"\"\"\"\n=====Problem statement====\n\nSpoonerize... with numbers... numberize?... numboonerize?... noonerize? ...anyway!  If you don't yet know what a spoonerism is and haven't yet tried my spoonerism kata, please do [check it out](http:\/\/www.codewars.com\/kata\/spoonerize-me) first.\n\nYou will create a function which takes an array of two positive integers, spoonerizes them, and returns the positive difference between them as a single number or ```0``` if the numbers are equal:\n```\n[123, 456] = 423 - 156 = 267\n```\nYour code must test that all array items are numbers and return ```\"invalid array\"``` if it finds that either item is not a number.  The provided array will always contain 2 elements.\n\nWhen the inputs are valid, they will always be integers, no floats will be passed.  However, you must take into account that the numbers will be of varying magnitude, between and within test cases.\n\"\"\"\n\n# ====== Solution ======\n\ndef noonerize(numbers):\n","entry_point":"noonerize","test":"def check(candidate):\n    assert candidate([12, 34]) == 18\n    assert candidate([55, 63]) == 12\n    assert candidate([357, 579]) == 178\n    assert candidate([1000000, 9999999]) == 7000001\n    assert candidate([1000000, 'hello']) == 'invalid array'\n    assert candidate(['pippi', 9999999]) == 'invalid array'\n    assert candidate(['pippi', 'hello']) == 'invalid array'\n    assert candidate([1, 1]) == 0\n    assert candidate([1, 0]) == 1\n    assert candidate([0, 1]) == 1\n\n","canonical_solution":"def noonerize(numbers):\n    \n    try:\n        num1 = int(str(numbers[1])[0] + str(numbers[0])[1:])\n        num2 = int(str(numbers[0])[0] + str(numbers[1])[1:])\n    except ValueError:\n        return \"invalid array\"\n        \n    return abs(num1 - num2)"}
{"task_id":4414,"prompt":"\"\"\"\n=====Problem statement====\n\nKaran's company makes software that provides different features based on the version of operating system of the user.\n\nFor finding which version is more recent, Karan uses the following method:\n\nWhile this function worked for OS versions 10.6, 10.7, 10.8 and 10.9, the Operating system company just released OS version 10.10.\n\nKaran's function fails for the new version:\n\n```python\ncompare_versions (\"10.9\", \"10.10\");       # returns True, while it should return False\n```\n\nKaran now wants to spend some time to right a more robust version comparison function that works for any future version\/sub-version updates.\n\nHelp Karan write this function. Here are a few sample cases:\n\n```python\ncompare_versions(\"11\", \"10\");                    # returns True\ncompare_versions(\"11\", \"11\");                    # returns True\ncompare_versions(\"10.4.6\", \"10.4\");              # returns True\ncompare_versions(\"10.4\", \"11\");                  # returns False\ncompare_versions(\"10.4\", \"10.10\");               # returns False\ncompare_versions(\"10.4.9\", \"10.5\");              # returns False\n```\n```haskell  \ncompareVersions \"11\" \"10\"       `shouldBe` GT\ncompareVersions \"10.4.6\" \"10.4\" `shouldBe` GT\ncompareVersions \"10.10\" \"10.9\"  `shouldBe` GT\ncompareVersions xs xs           `shouldBe` EQ -- xs is an arbitrary version\ncompareVersions \"10\" \"11\"         `shouldBe` LT\ncompareVersions \"10.4\" \"10.4.6\"   `shouldBe` LT\ncompareVersions \"10.99\" \"10.100\"  `shouldBe` LT\n```\n\nIt can be assumed that version strings are non empty and only contain numeric literals and the character `'.'`.\n\"\"\"\n\n# ====== Solution ======\n\ndef compare_versions(ver1,ver2):\n","entry_point":"compare_versions","test":"def check(candidate):\n    assert candidate('11','10') == True\n    assert candidate('11','11') == True\n    assert candidate('10.4.6','10.4') == True\n    assert candidate('10.4','10.4.8') == False\n    assert candidate('10.4','11') == False\n    assert candidate('10.4.9','10.5') == False\n    assert candidate('4.3.3','4.3.3.1') == False\n    assert candidate('10.4.9','104.9') == False\n    assert candidate('10.15','10.12') == True\n\n","canonical_solution":"def compare_versions(ver1,ver2):\n    return [int(i) for i in ver1.split(\".\")] >= [int(i) for i in ver2.split(\".\")]\n"}
{"task_id":4417,"prompt":"\"\"\"\n=====Problem statement====\n\nConsider the prime number `23`. If we sum the square of its digits we get:\n`2^2 + 3^2 = 13`, then for `13: 1^2 + 3^2 = 10`, and finally for `10: 1^2 + 0^2 = 1`. \n\nSimilarly, if we start with prime number `7`, the sequence is: `7->49->97->130->10->1`.\n\nGiven a range, how many primes within that range will eventually end up being `1`? \n\nThe upperbound for the range is `50,000`. A range of `(2,25)` means that: `2 <= n < 25`. \n\nGood luck!\n\nIf you like this Kata, please try:\n\n[Prime reversion](https:\/\/www.codewars.com\/kata\/59b46276afcda204ed000094)\n\n[Domainant primes](https:\/\/www.codewars.com\/kata\/59ce11ea9f0cbc8a390000ed)\n\"\"\"\n\n# ====== Solution ======\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrtn = int(n**0.5) + 1\n    for i in range(5, sqrtn, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef end_one(n):\n    while n > 6:\n        n = sum(map(lambda x: int(x)*int(x) ,f\"{n}\"))\n        if n == 1:\n            return True\n        \ndef solve(a,b):\n","entry_point":"solve","test":"def check(candidate):\n    assert candidate(1,25) == 4\n    assert candidate(100,1000) == 28\n    assert candidate(100,2000) == 47\n    assert candidate(100,3000) == 65\n    assert candidate(100,4000) == 95\n\n","canonical_solution":"def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    sqrtn = int(n**0.5) + 1\n    for i in range(5, sqrtn, 6):\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n    return True\n\ndef end_one(n):\n    while n > 6:\n        n = sum(map(lambda x: int(x)*int(x) ,f\"{n}\"))\n        if n == 1:\n            return True\n        \ndef solve(a,b):\n    return sum(1 for n in range(a, b) if is_prime(n) and end_one(n))"}
{"task_id":4426,"prompt":"\"\"\"\n=====Problem statement====\n\nYour task it to return ```true``` if the fractional part (rounded to 1 digit) of the result (```a``` \/ ```b```) exists, more than ```0``` and is multiple of ```n```.\nOtherwise return ```false```. (For Python return True or False)\n\nAll arguments are positive digital numbers.\n\nRounding works like toFixed() method. (if more than...5 rounds up)\n\nFind exapmles below: \n\n```\n\nisMultiple(5, 2, 3) -> false \/\/ 2.5 -> 5 is not multiple of 3\nisMultiple(5, 3, 4) -> false \/\/ 1.7 -> 7 is not multiple of 4\nisMultiple(5, 4, 3) -> true \/\/ 1.3 -> 3 is multiple of 3\nisMultiple(666, 665, 2) -> false \/\/ 1.0 -> return false\n\n\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef isMultiple(a, b, n):\n","entry_point":"isMultiple","test":"def check(candidate):\n    assert candidate(5,2,3) == False\n    assert candidate(5,3,4) == False\n    assert candidate(5,4,3) == True\n    assert candidate(666,665,2) == False\n    assert candidate(3691401,1892272,5) == False\n\n","canonical_solution":"def isMultiple(a, b, n):\n    remainder = int((a \/ b + 0.05) * 10) % 10\n    return remainder > 0 and remainder % n == 0"}
{"task_id":4437,"prompt":"\"\"\"\n=====Problem statement====\n\nFor this problem you must create a program that says who ate the last cookie. If the input is a string then \"Zach\" ate the cookie. If the input is a float or an int then \"Monica\" ate the cookie. If the input is anything else \"the dog\" ate the cookie. The way to return the statement is:\n\"Who ate the last cookie? It was (name)!\"\n\nEx: Input = \"hi\" --> Output = \"Who ate the last cookie? It was Zach!\n(The reason you return Zach is because the input is a string)\n\nNote: Make sure you return the correct message with correct spaces and punctuation.\n\nPlease leave feedback for this kata.\nCheers!\n\"\"\"\n\n# ====== Solution ======\n\ndef cookie(x):\n","entry_point":"cookie","test":"def check(candidate):\n    assert candidate('Ryan') == 'Who ate the last cookie? It was Zach!'\n    assert candidate(2.3) == 'Who ate the last cookie? It was Monica!'\n    assert candidate(26) == 'Who ate the last cookie? It was Monica!'\n    assert candidate(True) == 'Who ate the last cookie? It was the dog!'\n    assert candidate('True') == 'Who ate the last cookie? It was Zach!'\n    assert candidate(False) == 'Who ate the last cookie? It was the dog!'\n    assert candidate(1.98528462) == 'Who ate the last cookie? It was Monica!'\n\n","canonical_solution":"def cookie(x):\n    return \"Who ate the last cookie? It was %s!\" % {str:\"Zach\", float:\"Monica\", int:\"Monica\"}.get(type(x), \"the dog\")"}
{"task_id":4438,"prompt":"\"\"\"\n=====Problem statement====\n\nFor this kata, you are given three points ```(x1,y1,z1)```, ```(x2,y2,z2)```, and ```(x3,y3,z3)``` that lie on a straight line in 3-dimensional space.\nYou have to figure out which point lies in between the other two.\n\nYour function should return 1, 2, or 3 to indicate which point is the in-between one.\n\"\"\"\n\n# ====== Solution ======\n\ndef middle_point(x1, y1, z1, x2, y2, z2, x3, y3, z3):\n","entry_point":"middle_point","test":"def check(candidate):\n    assert candidate(1,2,3,4,5,6,7,8,9) == 2\n    assert candidate(0,2,0,6,-2,8,3,0,4) == 3\n    assert candidate(0.25,0.5,0.75,3.25,-0.5,-0.25,1.0,0.25,0.5) == 3\n    assert candidate(1,0,4,5,0,6,-7,0,0) == 1\n    assert candidate(-1,0,2,-2,4,-1,-3,8,-4) == 2\n\n","canonical_solution":"def middle_point(x1, y1, z1, x2, y2, z2, x3, y3, z3):\n    return sorted(((x1, y1, z1, 1), (x2, y2, z2, 2), (x3, y3, z3, 3)))[1][3]\n"}
{"task_id":4444,"prompt":"\"\"\"\n=====Problem statement====\n\nAn abundant number or excessive number is a number for which the sum of its proper divisors is greater than the number itself. \n\nThe integer 12 is the first abundant number. Its proper divisors are 1, 2, 3, 4 and 6 for a total of 16 (> 12).\n\nDerive function `abundantNumber(num)\/abundant_number(num)` which returns `true\/True\/.true.` if `num` is abundant, `false\/False\/.false.` if not.\n\"\"\"\n\n# ====== Solution ======\n\ndef abundant_number(num):\n","entry_point":"abundant_number","test":"def check(candidate):\n    assert candidate(12) == True\n    assert candidate(18) == True\n    assert candidate(37) == False\n    assert candidate(120) == True\n    assert candidate(77) == False\n    assert candidate(118) == False\n    assert candidate(5830) == True\n    assert candidate(11410) == True\n    assert candidate(14771) == False\n    assert candidate(11690) == True\n\n","canonical_solution":"def abundant_number(num):\n    return (sum([e for e in range(1,num) if num%e==0]) > num)"}
{"task_id":4459,"prompt":"\"\"\"\n=====Problem statement====\n\nReturn the Nth Even Number\n\nThe input will not be 0.\n\"\"\"\n\n# ====== Solution ======\n\ndef nth_even(n):\n","entry_point":"nth_even","test":"def check(candidate):\n    assert candidate(1) == 0\n    assert candidate(2) == 2\n    assert candidate(3) == 4\n    assert candidate(100) == 198\n    assert candidate(1298734) == 2597466\n\n","canonical_solution":"def nth_even(n):\n    return 2 * (n - 1);"}
{"task_id":4460,"prompt":"\"\"\"\n=====Problem statement====\n\nComplete the function which returns the weekday according to the input number:\n\n* `1` returns `\"Sunday\"`\n* `2` returns `\"Monday\"`\n* `3` returns `\"Tuesday\"`\n* `4` returns `\"Wednesday\"`\n* `5` returns `\"Thursday\"`\n* `6` returns `\"Friday\"`\n* `7` returns `\"Saturday\"`\n* Otherwise returns `\"Wrong, please enter a number between 1 and 7\"`\n\"\"\"\n\n# ====== Solution ======\n\nWEEKDAY = {\n    1: 'Sunday',\n    2: 'Monday',\n    3: 'Tuesday',\n    4: 'Wednesday',\n    5: 'Thursday',\n    6: 'Friday',\n    7: 'Saturday' }\nERROR = 'Wrong, please enter a number between 1 and 7'\n\n\ndef whatday(n):\n","entry_point":"whatday","test":"def check(candidate):\n    assert candidate(1) == 'Sunday'\n    assert candidate(2) == 'Monday'\n    assert candidate(3) == 'Tuesday'\n    assert candidate(4) == 'Wednesday'\n    assert candidate(5) == 'Thursday'\n    assert candidate(6) == 'Friday'\n    assert candidate(7) == 'Saturday'\n    assert candidate(0) == 'Wrong, please enter a number between 1 and 7'\n    assert candidate(8) == 'Wrong, please enter a number between 1 and 7'\n    assert candidate(20) == 'Wrong, please enter a number between 1 and 7'\n\n","canonical_solution":"WEEKDAY = {\n    1: 'Sunday',\n    2: 'Monday',\n    3: 'Tuesday',\n    4: 'Wednesday',\n    5: 'Thursday',\n    6: 'Friday',\n    7: 'Saturday' }\nERROR = 'Wrong, please enter a number between 1 and 7'\n\n\ndef whatday(n):\n    return WEEKDAY.get(n, ERROR)\n"}
{"task_id":4465,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that rearranges an integer into its largest possible value. \n\n```python\nsuper_size(123456) # 654321\nsuper_size(105)    # 510\nsuper_size(12)     # 21\n```\n``` haskell\nsuperSize 123456 `shouldBe` 654321\nsuperSize    105 `shouldBe`    510\nsuperSize     12 `shouldBe`     21\n```\n\nIf the argument passed through is single digit or is already the maximum possible integer, your function should simply return it.\n\"\"\"\n\n# ====== Solution ======\n\ndef super_size(n):\n","entry_point":"super_size","test":"def check(candidate):\n    assert candidate(69) == 96\n    assert candidate(513) == 531\n    assert candidate(2017) == 7210\n    assert candidate(414) == 441\n    assert candidate(608719) == 987610\n    assert candidate(123456789) == 987654321\n    assert candidate(700000000001) == 710000000000\n    assert candidate(666666) == 666666\n    assert candidate(2) == 2\n    assert candidate(0) == 0\n\n","canonical_solution":"def super_size(n):\n    return int(''.join(sorted(str(n), reverse = True)))"}
{"task_id":4480,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a simple parser that will parse and run Deadfish.  \n\nDeadfish has 4 commands, each 1 character long:\n* `i` increments the value (initially `0`)\n* `d` decrements the value\n* `s` squares the value\n* `o` outputs the value into the return array\n\nInvalid characters should be ignored.\n\n```python\nparse(\"iiisdoso\")  ==>  [8, 64]\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef parse(data):\n","entry_point":"parse","test":"def check(candidate):\n    assert candidate('ooo') == [0, 0, 0]\n    assert candidate('ioioio') == [1, 2, 3]\n    assert candidate('idoiido') == [0, 1]\n    assert candidate('isoisoiso') == [1, 4, 25]\n    assert candidate('codewars') == [0]\n\n","canonical_solution":"def parse(data):\n    value = 0\n    res=[]\n    for c in data:\n        if c==\"i\": value+=1\n        elif c==\"d\": value-=1\n        elif c==\"s\": value*=value\n        elif c==\"o\": res.append(value)\n    return res"}
{"task_id":4484,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function called calculate that takes 3 values. The first and third values are numbers. The second value is a character. If the character is \"+\" , \"-\", \"*\", or \"\/\", the function will return the result of the corresponding mathematical function on the two numbers. If the string is not one of the specified characters, the function should return null (throw an `ArgumentException` in C#).\n\nKeep in mind, you cannot divide by zero. If an attempt to divide by zero is made, return null (throw an `ArgumentException` in C#)\/(None in Python).\n\"\"\"\n\n# ====== Solution ======\n\ndef calculate(num1, operation, num2): \n","entry_point":"calculate","test":"def check(candidate):\n    assert candidate(3.2,'+',8) == 11.2\n    assert candidate(3.2,'-',8) == -4.8\n    assert candidate(3.2,'\/',8) == 0.4\n    assert candidate(3.2,'*',8) == 25.6\n    assert candidate(-3,'+',0) == -3\n    assert candidate(-3,'-',0) == -3\n    assert candidate(-2,'\/',-2) == 1\n    assert candidate(-3,'*',0) == 0\n    assert candidate(-3,'\/',0) == None\n    assert candidate(-3,'w',0) == None\n    assert candidate(-3,'w',1) == None\n\n","canonical_solution":"def calculate(num1, operation, num2): \n    # your code here\n    try :\n        return eval(\"{} {} {}\".format(num1, operation, num2))\n    except (ZeroDivisionError, SyntaxError):\n        return None"}
{"task_id":4487,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function that takes a single array as an argument (containing multiple strings and\/or positive numbers and\/or arrays), and returns one of four possible string values, depending on the ordering of the lengths of the elements in the input array:\n\nYour function should return...\n\n- \u201cIncreasing\u201d - if the lengths of the elements increase from left to right (although it is possible that some neighbouring elements may also be equal in length)\n- \u201cDecreasing\u201d - if the lengths of the elements decrease from left to right (although it is possible that some neighbouring elements may also be equal in length)\n- \u201cUnsorted\u201d - if the lengths of the elements fluctuate from left to right\n- \u201cConstant\u201d - if all element's lengths are the same.\n\n\n\nNumbers and Strings should be evaluated based on the number of characters or digits used to write them.\n\nArrays should be evaluated based on the number of elements counted directly in the parent array (but not the number of elements contained in any sub-arrays).\n\nHappy coding! :)\n\"\"\"\n\n# ====== Solution ======\n\ndef order_type(arr):\n","entry_point":"order_type","test":"def check(candidate):\n    assert candidate([1, 'b', ['p'], 2]) == 'Constant'\n    assert candidate([123, 1234, 12345, 123456]) == 'Increasing'\n    assert candidate(['a', 'abc', 'abcde', 'ab']) == 'Unsorted'\n    assert candidate([[1, 2, 3, 4], [5, 6, 7], [8, 9]]) == 'Decreasing'\n    assert candidate([1, 2, 3, 4, 56]) == 'Increasing'\n    assert candidate([['ab', 'cdef', 'g'], ['hi', 'jk', 'lmnopq'], ['rst', 'uv', 'wx'], ['yz']]) == 'Decreasing'\n    assert candidate([[1, 23, 456, 78910], ['abcdef', 'ghijklmno', 'pqrstuvwxy'], [[1, 23, 456, 78910, ['abcdef', 'ghijklmno', 'pqrstuvwxy']], 1234]]) == 'Decreasing'\n    assert candidate([]) == 'Constant'\n    assert candidate(['pippi', 'pippi', 'batuffulo', 'pippi']) == 'Unsorted'\n    assert candidate(['pippi']) == 'Constant'\n\n","canonical_solution":"def order_type(arr):\n    if not arr : return 'Constant'\n    arr = list( map(len, [str(elt) if type(elt)==int else elt for elt in arr] ))\n    cmp =sorted(arr)\n    if arr == [arr[0]]*len(arr) : s='Constant'\n    elif arr == cmp :             s='Increasing'\n    elif arr == cmp[::-1] :       s='Decreasing'\n    else :                        s='Unsorted'\n    return s"}
{"task_id":4490,"prompt":"\"\"\"\n=====Problem statement====\n\nThe Collatz conjecture is one of the most famous one. Take any positive integer n, if it is even divide it by 2, if it is odd multiply it by 3 and add 1 and continue indefinitely.The conjecture is that whatever is n the sequence will reach 1. There is many ways to approach this problem, each one of them had given beautifull graphs and impressive display of calculation power. The simplest approach can be found in this kata: http:\/\/www.codewars.com\/kata\/5286b2e162056fd0cb000c20\nYou look at the Collatz sequence of a number and see when it reaches 1.\n\nIn this kata we will take a look at the length of collatz sequences. And how they evolve. Write a function that take a positive integer n and return the number between 1 and n that has the maximum Collatz sequence length and the maximum length. The output has to take the form of an array [number, maxLength] For exemple the Collatz sequence of 4 is [4,2,1], 3 is [3,10,5,16,8,4,2,1], 2 is [2,1], 1 is [1], so `MaxCollatzLength(4)` should return `[3,8]`. If n is not a positive integer, the function have to return [].\n\n* As you can see, numbers in Collatz sequences may exceed n.\n\nThe last tests use random big numbers so you may consider some optimisation in your code:\n\n* You may get very unlucky and get only hard numbers: try submitting 2-3 times if it times out; if it still does, probably you need to optimize your code more;\n\n* Optimisation 1: when calculating the length of a sequence, if n is odd, what 3n+1 will be ?\n\n* Optimisation 2: when looping through 1 to n, take i such that i<n\/2, what will be the lenght of the sequence for 2i ?\n\"\"\"\n\n# ====== Solution ======\n\nfrom functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef rec(n): return 1 + (0 if n==1 else rec(3*n+1) if n&1 else rec(n\/\/2))\n\nmemo = [[0, None], [1, 1]]\ndef max_collatz_length(n):\n","entry_point":"max_collatz_length","test":"def check(candidate):\n    assert candidate(0) == []\n    assert candidate(1) == [1, 1]\n    assert candidate(4) == [3, 8]\n    assert candidate(30) == [27, 112]\n    assert candidate(1000) == [871, 179]\n    assert candidate(1000000) == [837799, 525]\n    assert candidate('a') == []\n    assert candidate(-1) == []\n    assert candidate(['a']) == []\n\n","canonical_solution":"from functools import lru_cache\n\n@lru_cache(maxsize=None)\ndef rec(n): return 1 + (0 if n==1 else rec(3*n+1) if n&1 else rec(n\/\/2))\n\nmemo = [[0, None], [1, 1]]\ndef max_collatz_length(n):\n    if not (type(n) == int and n > 0): return []\n    while n >= len(memo):\n        x = rec(len(memo))\n        if x > memo[-1][1]: memo.append([len(memo), x])\n        else: memo.append(memo[-1])\n    return memo[n]"}
{"task_id":4495,"prompt":"\"\"\"\n=====Problem statement====\n\nI've got a crazy mental illness.\nI dislike numbers a lot. But it's a little complicated:\nThe number I'm afraid of depends on which day of the week it is...\nThis is a concrete description of my mental illness:\n\nMonday     --> 12\n\nTuesday    --> numbers greater than 95\n\nWednesday  --> 34\n\nThursday   --> 0\n\nFriday     --> numbers divisible by 2\n\nSaturday   --> 56\n\nSunday     --> 666 or -666\n\n\nWrite a function which takes a string (day of the week) and an integer (number to be tested) so it tells the doctor if I'm afraid or not. (return a boolean)\n\"\"\"\n\n# ====== Solution ======\n\ndef am_I_afraid(day,num):\n","entry_point":"am_I_afraid","test":"def check(candidate):\n    assert candidate('Monday',13) == False\n    assert candidate('Monday',12) == True\n    assert candidate('Tuesday',0) == False\n    assert candidate('Tuesday',100) == True\n    assert candidate('Tuesday',95) == False\n    assert candidate('Wednesday',35) == False\n    assert candidate('Wednesday',34) == True\n    assert candidate('Thursday',2) == False\n    assert candidate('Thursday',0) == True\n    assert candidate('Friday',5) == False\n    assert candidate('Friday',4) == True\n    assert candidate('Saturday',55) == False\n    assert candidate('Saturday',56) == True\n    assert candidate('Sunday',55) == False\n    assert candidate('Sunday',666) == True\n    assert candidate('Sunday',-666) == True\n\n","canonical_solution":"def am_I_afraid(day,num):\n    return {\n        'Monday':  num == 12,\n        'Tuesday': num > 95,\n        'Wednesday': num == 34,\n        'Thursday': num == 0,\n        'Friday': num % 2 == 0,\n        'Saturday': num ==  56,\n        'Sunday': num == 666 or num == -666,\n    }[day]\n"}
{"task_id":4499,"prompt":"\"\"\"\n=====Problem statement====\n\n# Convergents of e\nThe square root of 2 can be written as an infinite continued fraction.\n![img](http:\/\/img0.ph.126.net\/x1Hyc4iHQg0Jz2EInmT3ag==\/6597639313681841979.png)  \nThe infinite continued fraction can be written, \u221a2 = [1;(2)], (2) indicates that 2 repeats ad infinitum. In a similar way, \u221a23 = [4;(1,3,1,8)].\n\nIt turns out that the sequence of partial values of continued fractions for square roots provide the best rational approximations. Let us consider the convergents for \u221a2.\n![img](http:\/\/img1.ph.126.net\/xme9gNBQdA7bvQkwIftznQ==\/6597819633588793645.png)  \nHence the sequence of the first ten convergents for \u221a2 are:\n\n1, 3\/2, 7\/5, 17\/12, 41\/29, 99\/70, 239\/169, 577\/408, 1393\/985, 3363\/2378, \u2026\n\nWhat is most surprising is that the important mathematical constant,\ne = [2; 1,2,1, 1,4,1, 1,6,1 , \u2026 , 1,2k,1, \u2026].\n\nThe first ten terms in the sequence of convergents for e are:\n\n2, 3, 8\/3, 11\/4, 19\/7, 87\/32, 106\/39, 193\/71, 1264\/465, 1457\/536, \u2026\n\nThe sum of digits in the numerator of the 10th convergent is 1+4+5+7=17.\n\nFind the sum of digits in the numerator of the mth convergent of the continued fraction for e.\n\n\n- Powered by [Project Euler](https:\/\/projecteuler.net\/problem=65)\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"convergents_of_e","test":"def check(candidate):\n    assert candidate(57) == 125\n    assert candidate(125) == 298\n    assert candidate(298) == 938\n    assert candidate(938) == 3756\n    assert candidate(3756) == 18287\n    assert candidate(18287) == 108346\n    assert candidate(2132) == 9469\n    assert candidate(9999) == 55534\n    assert candidate(788) == 3151\n    assert candidate(8787) == 48461\n\n","canonical_solution":"e = [1, 2]\nfor n in range(1, 10 ** 4):\n    for f in 1, 2 * n, 1:\n        e.append(f * e[-1] + e[-2])\nconvergents_of_e = lambda n: sum(map(int, str(e[n])))"}
{"task_id":4502,"prompt":"\"\"\"\n=====Problem statement====\n\nWell met with Fibonacci bigger brother, AKA Tribonacci.\n\nAs the name may already reveal, it works basically like a Fibonacci, but summing the last 3 (instead of 2) numbers of the sequence to generate the next. And, worse part of it, regrettably I won't get to hear non-native Italian speakers trying to pronounce it :(\n\nSo, if we are to start our Tribonacci sequence with `[1, 1, 1]` as a starting input (AKA *signature*), we have this sequence:\n\n```\n[1, 1 ,1, 3, 5, 9, 17, 31, ...]\n```\n\nBut what if we started with `[0, 0, 1]` as a signature? As starting with `[0, 1]` instead of `[1, 1]` basically *shifts* the common Fibonacci sequence by once place, you may be tempted to think that we would get the same sequence shifted by 2 places, but that is not the case and we would get:\n\n```\n[0, 0, 1, 1, 2, 4, 7, 13, 24, ...]\n```\n\nWell, you may have guessed it by now, but to be clear: you need to create a fibonacci function that given a **signature** array\/list, returns **the first n elements - signature included** of the so seeded sequence.\n\nSignature will always contain 3 numbers; n will always be a non-negative number; if `n == 0`, then return an empty array (except in C return NULL) and be ready for anything else which is not clearly specified ;)\n\nIf you enjoyed this kata more advanced and generalized version of it can be found in the Xbonacci kata\n\n*[Personal thanks to Professor Jim Fowler on Coursera for his awesome classes that I really recommend to any math enthusiast and for showing me this mathematical curiosity too with his usual contagious passion :)]*\n\"\"\"\n\n# ====== Solution ======\n\ndef tribonacci(signature, n):\n","entry_point":"tribonacci","test":"def check(candidate):\n    assert candidate([1, 1, 1],10) == [1, 1, 1, 3, 5, 9, 17, 31, 57, 105]\n    assert candidate([0, 0, 1],10) == [0, 0, 1, 1, 2, 4, 7, 13, 24, 44]\n    assert candidate([0, 1, 1],10) == [0, 1, 1, 2, 4, 7, 13, 24, 44, 81]\n    assert candidate([1, 0, 0],10) == [1, 0, 0, 1, 1, 2, 4, 7, 13, 24]\n    assert candidate([0, 0, 0],10) == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([1, 2, 3],10) == [1, 2, 3, 6, 11, 20, 37, 68, 125, 230]\n    assert candidate([3, 2, 1],10) == [3, 2, 1, 6, 9, 16, 31, 56, 103, 190]\n    assert candidate([1, 1, 1],1) == [1]\n    assert candidate([300, 200, 100],0) == []\n    assert candidate([0.5, 0.5, 0.5],30) == [0.5, 0.5, 0.5, 1.5, 2.5, 4.5, 8.5, 15.5, 28.5, 52.5, 96.5, 177.5, 326.5, 600.5, 1104.5, 2031.5, 3736.5, 6872.5, 12640.5, 23249.5, 42762.5, 78652.5, 144664.5, 266079.5, 489396.5, 900140.5, 1655616.5, 3045153.5, 5600910.5, 10301680.5]\n\n","canonical_solution":"def tribonacci(signature, n):\n  res = signature[:n]\n  for i in range(n - 3): res.append(sum(res[-3:]))\n  return res"}
{"task_id":4504,"prompt":"\"\"\"\n=====Problem statement====\n\nShare price\n===========\n\nYou spent all your saved money to buy some shares.\n\nYou bought it for `invested`, and want to know how much it's worth, but all the info you can quickly get are just the change the shares price made in percentages.\n\nYour task:\n----------\nWrite the function `sharePrice()` that calculates, and returns the current price of your share, given the following two arguments:\n\n- `invested`(number), the amount of money you initially invested in the given share\n\n- `changes`(array of numbers), contains your shares daily movement percentages\n\nThe returned number, should be in string format, and it's precision should be fixed at 2 decimal numbers.\n\nHave fun!\n\n>**Hint:** Try to write the function in a functional manner!\n\"\"\"\n\n# ====== Solution ======\n\ndef share_price(invested, changes):\n","entry_point":"share_price","test":"def check(candidate):\n    assert candidate(100,[]) == '100.00'\n    assert candidate(100,[-50, 50]) == '75.00'\n    assert candidate(100,[-50, 100]) == '100.00'\n    assert candidate(100,[-20, 30]) == '104.00'\n    assert candidate(1000,[0, 2, 3, 6]) == '1113.64'\n\n","canonical_solution":"def share_price(invested, changes):\n    for change in changes:\n        invested = invested * (100 + change) \/ 100.0\n    return format(invested, '.2f')"}
{"task_id":4513,"prompt":"\"\"\"\n=====Problem statement====\n\nYou will be given an array of numbers.\n\nFor each number in the array you will need to create an object. \n\nThe object key will be the number, as a string. The value will be the corresponding character code, as a string.\n\nReturn an array of the resulting objects.\n\nAll inputs will be arrays of numbers. All character codes are valid lower case letters. The input array will not be empty.\n\"\"\"\n\n# ====== Solution ======\n\ndef num_obj(s):\n","entry_point":"num_obj","test":"def check(candidate):\n    assert candidate([118, 117, 120]) == [{'118': 'v'}, {'117': 'u'}, {'120': 'x'}]\n    assert candidate([101, 121, 110, 113, 113, 103]) == [{'101': 'e'}, {'121': 'y'}, {'110': 'n'}, {'113': 'q'}, {'113': 'q'}, {'103': 'g'}]\n    assert candidate([118, 103, 110, 109, 104, 106]) == [{'118': 'v'}, {'103': 'g'}, {'110': 'n'}, {'109': 'm'}, {'104': 'h'}, {'106': 'j'}]\n    assert candidate([107, 99, 110, 107, 118, 106, 112, 102]) == [{'107': 'k'}, {'99': 'c'}, {'110': 'n'}, {'107': 'k'}, {'118': 'v'}, {'106': 'j'}, {'112': 'p'}, {'102': 'f'}]\n    assert candidate([100, 100, 116, 105, 117, 121]) == [{'100': 'd'}, {'100': 'd'}, {'116': 't'}, {'105': 'i'}, {'117': 'u'}, {'121': 'y'}]\n\n","canonical_solution":"def num_obj(s):\n    return [{str(i) : chr(i)} for i in s]"}
{"task_id":4515,"prompt":"\"\"\"\n=====Problem statement====\n\nYour task is to find the number couple with the greatest difference from a given array of number-couples. \n\nAll number couples will be given as strings and all numbers in them will be positive integers.  \n\nFor instance: ['56-23','1-100']; in this case, you should identify '1-100' as the number couple with the greatest difference and return it.\n\nIn case there are more than one option, for instance ['1-3','5-7','2-3'], you should identify whichever is first, so in this case '1-3'. \n\nIf there is no difference, like so ['11-11', '344-344'], return false.\n\"\"\"\n\n# ====== Solution ======\n\ndef diff(arr):\n","entry_point":"diff","test":"def check(candidate):\n    assert candidate(['43-45', '1021-55', '000-18888', '92-34', '76-32', '99-1', '1020-54']) == '000-18888'\n    assert candidate(['1-2', '2-4', '5-7', '8-9', '44-45']) == '2-4'\n    assert candidate(['1-1000', '2-1000', '100-67', '98-45', '8-9']) == '1-1000'\n    assert candidate(['33-33', '77-77']) == False\n    assert candidate(['23-67', '67-23', '88-88', '45-46']) == '23-67'\n    assert candidate(['45896-2354', '4654-556767', '2455-423522', '3455-355', '34-34', '2524522-0']) == '2524522-0'\n    assert candidate(['1-1', '2-2', '1-0', '77-77']) == '1-0'\n    assert candidate(['0-0']) == False\n    assert candidate([]) == False\n\n","canonical_solution":"def diff(arr):\n    r = arr and max(arr, key = lambda x : abs(eval(x)))\n    return bool(arr and eval(r)) and r"}
{"task_id":4516,"prompt":"\"\"\"\n=====Problem statement====\n\nMake a program that takes a value (x) and returns \"Bang\" if the number is divisible by 3, \"Boom\" if it is divisible by 5, \"BangBoom\" if it divisible by 3 and 5, and \"Miss\" if it isn't divisible by any of them.\nNote: Your program should only return one value\n\nEx: Input: 105 --> Output: \"BangBoom\"\nEx: Input: 9 --> Output: \"Bang\"\nEx:Input: 25 --> Output: \"Boom\"\n\"\"\"\n\n# ====== Solution ======\n\ndef multiple(x):\n","entry_point":"multiple","test":"def check(candidate):\n    assert candidate(30) == 'BangBoom'\n    assert candidate(3) == 'Bang'\n    assert candidate(98) == 'Miss'\n    assert candidate(65) == 'Boom'\n    assert candidate(23) == 'Miss'\n    assert candidate(15) == 'BangBoom'\n    assert candidate(4) == 'Miss'\n    assert candidate(2) == 'Miss'\n    assert candidate(45) == 'BangBoom'\n    assert candidate(90) == 'BangBoom'\n    assert candidate(21) == 'Bang'\n    assert candidate(7) == 'Miss'\n    assert candidate(6) == 'Bang'\n    assert candidate(10003823) == 'Miss'\n    assert candidate(41535) == 'BangBoom'\n    assert candidate(712) == 'Miss'\n    assert candidate(985) == 'Boom'\n    assert candidate(164523) == 'Bang'\n\n","canonical_solution":"def multiple(x):\n    return 'Bang' * (x % 3 == 0) + 'Boom' * (x % 5 == 0) or 'Miss'"}
{"task_id":4520,"prompt":"\"\"\"\n=====Problem statement====\n\nRick wants a faster way to get the product of the largest pair in an array. Your task is to create a performant solution to find the product of the largest two integers in a unique array of positive numbers. All inputs will be valid.\nPassing [2, 6, 3] should return 18, the product of [6, 3].\n\n```Disclaimer: Mr. Roll will only accept solutions that are faster than his, which has a running time O(nlogn).``` \n\n```python\nmax_product([2, 1, 5, 0, 4, 3])              # => 20\nmax_product([7, 8, 9])                       # => 72\nmax_product([33, 231, 454, 11, 9, 99, 57])   # => 104874\n```\n\"\"\"\n\n# ====== Solution ======\n\nimport heapq\ndef max_product(a):\n","entry_point":"max_product","test":"def check(candidate):\n    assert candidate([56, 335, 195, 443, 6, 494, 252]) == 218842\n    assert candidate([154, 428, 455, 346]) == 194740\n    assert candidate([39, 135, 47, 275, 37, 108, 265, 457, 2, 133, 316, 330, 153, 253, 321, 411]) == 187827\n    assert candidate([136, 376, 10, 146, 105, 63, 234]) == 87984\n    assert candidate([354, 463, 165, 62, 472, 53, 347, 293, 252, 378, 420, 398, 255, 89]) == 218536\n    assert candidate([346, 446, 26, 425, 432, 349, 123, 269, 285, 93, 75, 14]) == 192672\n    assert candidate([134, 320, 266, 299]) == 95680\n    assert candidate([114, 424, 53, 272, 128, 215, 25, 329, 272, 313, 100, 24, 252]) == 139496\n    assert candidate([375, 56, 337, 466, 203]) == 174750\n\n","canonical_solution":"import heapq\ndef max_product(a):\n    x = heapq.nlargest(2,a)\n    return x[0]*x[1]"}
{"task_id":4530,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function `consonantCount`, `consonant_count` or `ConsonantCount` that takes a string of English-language text and returns the number of consonants in the string.\n\nConsonants are all letters used to write English excluding the vowels `a, e, i, o, u`.\n\"\"\"\n\n# ====== Solution ======\n\ndef consonant_count(str):\n","entry_point":"consonant_count","test":"def check(candidate):\n    assert candidate('') == 0\n    assert candidate('aaaaa') == 0\n    assert candidate('helLo world') == 7\n    assert candidate('h^$&^#$&^elLo world') == 7\n    assert candidate('0123456789') == 0\n    assert candidate('012345_Cb') == 2\n\n","canonical_solution":"def consonant_count(str):\n    return sum(1 for c in str if c.isalpha() and c.lower() not in \"aeiou\")\n"}
{"task_id":4532,"prompt":"\"\"\"\n=====Problem statement====\n\nBasic regex tasks. Write a function that takes in a numeric code of any length. The function should check if the code begins with 1, 2, or 3 and return `true` if so. Return `false` otherwise. \n\nYou can assume the input will always be a number.\n\"\"\"\n\n# ====== Solution ======\n\ndef validate_code(code):\n","entry_point":"validate_code","test":"def check(candidate):\n    assert candidate(123) == True\n    assert candidate(248) == True\n    assert candidate(8) == False\n    assert candidate(321) == True\n    assert candidate(9453) == False\n\n","canonical_solution":"def validate_code(code):\n    return str(code).startswith(('1', '2', '3'))\n"}
{"task_id":4533,"prompt":"\"\"\"\n=====Problem statement====\n\nThe image shows how we can obtain the Harmonic Conjugated Point of three aligned points A, B, C.\n\n- We choose any point L, that is not in the line with A, B and C. We form the triangle ABL\n\n- Then we draw a line from point C that intersects the sides of this triangle at points M and N respectively.\n\n- We draw the diagonals of the quadrilateral ABNM; they are AN and BM and they intersect at point K\n\n- We unit, with a line L and K, and this line intersects the line of points A, B and C at point D\n\nThe point D is named the Conjugated Harmonic Point of the points A, B, C.\nYou can get more knowledge related with this point at: (https:\/\/en.wikipedia.org\/wiki\/Projective_harmonic_conjugate)\n\nIf we apply the theorems of Ceva (https:\/\/en.wikipedia.org\/wiki\/Ceva%27s_theorem)\nand Menelaus (https:\/\/en.wikipedia.org\/wiki\/Menelaus%27_theorem) we will have this formula:\n\n\n\nAC, in the above formula is the length of the segment of points A to C in this direction and its value is:\n\n```AC = xA - xC```\n\nTransform the above formula using the coordinates ```xA, xB, xC and xD```\n\nThe task is to create a function ```harmon_pointTrip()```, that receives three arguments, the coordinates of points xA, xB and xC, with values such that : ```xA < xB < xC```, this function should output the coordinates of point D for each given triplet, such that\n\n`xA < xD < xB < xC`, or to be clearer\n\nlet's see some cases:\n```python\nharmon_pointTrip(xA, xB, xC) ------> xD # the result should be expressed up to four decimals (rounded result)\nharmon_pointTrip(2, 10, 20) -----> 7.1429 # (2 < 7.1429 < 10 < 20, satisfies the constraint)\nharmon_pointTrip(3, 9, 18) -----> 6.75\n```\n\n\nEnjoy it and happy coding!!\n\"\"\"\n\n# ====== Solution ======\n\ndef harmon_pointTrip(xA, xB, xC):\n","entry_point":"harmon_pointTrip","test":"def check(candidate):\n    assert candidate(2,10,20) == 7.1429\n    assert candidate(3,9,18) == 6.75\n    assert candidate(6,10,11) == 9.3333\n    assert candidate(4,12,24) == 9.0\n    assert candidate(5,17,20) == 15.0\n\n","canonical_solution":"def harmon_pointTrip(xA, xB, xC):\n    a, b, c = list(map(float, [xA, xB, xC]))\n    # Yay for algebra!\n    d = ((a * c) + (b * c) - (2 * a * b)) \/ (2 * c - a - b)\n    return round(d, 4)\n"}
{"task_id":4536,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate a function that takes an input String and returns a String, where all the uppercase words of the input String are in front and all the lowercase words at the end.\nThe order of the uppercase and lowercase words should be the order in which they occur.\n\nIf a word starts with a number or special character, skip the word and leave it out of the result. \n\nInput String will not be empty.\n\nFor an input String: \"hey You, Sort me Already!\" \nthe function should return: \"You, Sort Already! hey me\"\n\"\"\"\n\n# ====== Solution ======\n\ndef capitals_first(string):\n","entry_point":"capitals_first","test":"def check(candidate):\n    assert candidate('hey You, Sort me Already') == 'You, Sort Already hey me'\n    assert candidate('sense Does to That Make you?') == 'Does That Make sense to you?'\n    assert candidate('i First need Thing In coffee The Morning') == 'First Thing In The Morning i need coffee'\n    assert candidate('123 baby You and Me') == 'You Me baby and'\n    assert candidate('Life gets Sometimes pretty !Hard') == 'Life Sometimes gets pretty'\n\n","canonical_solution":"def capitals_first(string):\n    return ' '.join([word for word in string.split() if word[0].isupper()] + [word for word in string.split() if word[0].islower()])\n"}
{"task_id":4537,"prompt":"\"\"\"\n=====Problem statement====\n\nGray code is a form of binary encoding where transitions between consecutive numbers differ by only one bit. This is a useful encoding for reducing hardware data hazards with values that change rapidly and\/or connect to slower hardware as inputs. It is also useful for generating inputs for Karnaugh maps.\n\nHere is an exemple of what the code look like:\n\n```\n0:    0000\n1:    0001\n2:    0011\n3:    0010\n4:    0110\n5:    0111\n6:    0101\n7:    0100\n8:    1100\n```\n\nThe goal of this kata is to build two function bin2gray and gray2bin wich will convert natural binary to Gray Code and vice-versa. We will use the \"binary reflected Gray code\". The input and output will be arrays of 0 and 1, MSB at index 0.\n\nThere are \"simple\" formula to implement these functions. It is a very interesting exercise to find them by yourself.\n\nAll input will be correct binary arrays.\n\"\"\"\n\n# ====== Solution ======\n\ndef bin2gray(bits):\n","entry_point":"bin2gray","test":"def check(candidate):\n    assert candidate([1, 0, 1]) == [1, 1, 1]\n    assert candidate([1, 1]) == [1, 0]\n    assert candidate([1]) == [1]\n    assert candidate([0]) == [0]\n    assert candidate([1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]) == [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1]\n    assert candidate([1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]) == [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1]\n\n","canonical_solution":"def bin2gray(bits):\n  bits.reverse()\n  return list(reversed([x if i >= len(bits) - 1 or bits[i + 1] == 0 else 1 - x for i, x in enumerate(bits)]))\n  \ndef gray2bin(bits):\n  for i, x in enumerate(bits):\n    if i > 0 and bits[i - 1] != 0: bits[i] = 1 - x\n  return bits"}
{"task_id":4542,"prompt":"\"\"\"\n=====Problem statement====\n\nLet\u2019s get to know our hero: Agent #134 - Mr. Slayer.\n\nHe was sent by his CSV agency to Ancient Rome in order to resolve some important national issues. However, something incredible has happened - the enemies have taken Julius Caesar as a prisoner!!!\n\nCaesar, not a simple man as you know, managed to send cryptic message with coordinates of his location hoping that somebody would break the code. Here our agent of the secret service comes to the stage.\n\nBut he needs your help!\n\n**Mission:**\n\nYou have to implement the function \u201cEncode\u201d of CaesarCrypto class that codes or decodes text based on Caesar\u2019s algorithm.the function receives 2 parameters: an original text of any length of type \u201cstring\u201d and a number of type \u201cint\u201d that represents shifts;only letters in both cases must be encrypted;alphabet contains only letters in this range: a-zA-Z;by encryption the letter can change the case;shift could be either positive or negative (for left shift);If the input text is empty, null or includes only whitespaces, return an empty string.\n\nTime's ticking away. The life of Caesar is on the chopping block! Go for it!\n\"\"\"\n\n# ====== Solution ======\n\nfrom string import ascii_letters as az\n\n\ndef caesar_crypto_encode(text, shift):\n","entry_point":"caesar_crypto_encode","test":"def check(candidate):\n    assert candidate('123,.)(!?',10) == '123,.)(!?'\n    assert candidate('',10) == ''\n    assert candidate(None,10) == ''\n    assert candidate('   ',10) == ''\n    assert candidate('Hello world!',127) == 'eBIIL TLOIA!'\n    assert candidate('eBIIL TLOIA!',-127) == 'Hello world!'\n    assert candidate('ksdjai8983hdk?}{',15) == 'zHsypx8983wsz?}{'\n    assert candidate('Hello world!',0) == 'Hello world!'\n\n","canonical_solution":"from string import ascii_letters as az\n\n\ndef caesar_crypto_encode(text, shift):\n    if not text:\n        return ''\n    sh = shift % 52\n    return str.translate(text, str.maketrans(az, az[sh:] + az[:sh])).strip()"}
{"task_id":4546,"prompt":"\"\"\"\n=====Problem statement====\n\nMothers arranged a dance party for the children in school. At that party, there are only mothers and their children. All are having great fun on the dance floor when suddenly all the lights went out. It's a dark night and no one can see each other. But you were flying nearby and you can see in the dark and have ability to teleport people anywhere you want.\n\nLegend:\n-Uppercase letters stands for mothers, lowercase stand for their children, i.e. \"A\" mother's children are \"aaaa\".\n-Function input: String contains only letters, uppercase letters are unique.\nTask:\nPlace all people in alphabetical order where Mothers are followed by their children, i.e. \"aAbaBb\" => \"AaaBbb\".\n\"\"\"\n\n# ====== Solution ======\n\ndef find_children(dancing_brigade):\n","entry_point":"find_children","test":"def check(candidate):\n    assert candidate('abBA') == 'AaBb'\n    assert candidate('AaaaaZazzz') == 'AaaaaaZzzz'\n    assert candidate('CbcBcbaA') == 'AaBbbCcc'\n    assert candidate('xXfuUuuF') == 'FfUuuuXx'\n    assert candidate('') == ''\n\n","canonical_solution":"def find_children(dancing_brigade):\n    return ''.join(sorted(dancing_brigade,key=lambda c:(c.upper(),c.islower())))"}
{"task_id":4552,"prompt":"\"\"\"\n=====Problem statement====\n\nYou are given an array of unique numbers. The numbers represent points. The higher the number the higher the points.  \nIn the array [1,3,2] 3 is the highest point value so it gets 1st place. 2 is the second highest so it gets second place. 1 is the 3rd highest so it gets 3rd place. \n\nYour task is to return an array giving each number its rank in the array.  \ninput \/\/ [1,3,2] \noutput \/\/ [3,1,2]\n\n```rankings([1,2,3,4,5]) \/\/ [5,4,3,2,1]``` \n```rankings([3,4,1,2,5])\/\/  [3,2,5,4,1]``` \n```rankings([10,20,40,50,30]) \/\/  [5, 4, 2, 1, 3]``` \n```rankings([1, 10]) \/\/   [2, 1]``` \n```rankings([22, 33, 18, 9, 110, 4, 1, 88, 6, 50]) \/\/```\n```[5, 4, 6, 7, 1, 9, 10, 2, 8, 3]```\n\"\"\"\n\n# ====== Solution ======\n\ndef rankings(arr):\n","entry_point":"rankings","test":"def check(candidate):\n    assert candidate([1, 3, 2]) == [3, 1, 2]\n    assert candidate([1, 2, 3, 4, 5]) == [5, 4, 3, 2, 1]\n    assert candidate([3, 4, 1, 2, 5]) == [3, 2, 5, 4, 1]\n    assert candidate([10, 20, 40, 50, 30]) == [5, 4, 2, 1, 3]\n    assert candidate([1, 10]) == [2, 1]\n    assert candidate([22, 33, 18, 9, 110, 4, 1, 88, 6, 50]) == [5, 4, 6, 7, 1, 9, 10, 2, 8, 3]\n\n","canonical_solution":"def rankings(arr):\n    dct = {v:i for i,v in enumerate(sorted(arr, reverse=True),1)}\n    return [dct[v] for v in arr]"}
{"task_id":4553,"prompt":"\"\"\"\n=====Problem statement====\n\nSimple, given a string of words, return the length of the shortest word(s).\n\nString will never be empty and you do not need to account for different data types.\n\"\"\"\n\n# ====== Solution ======\n\ndef find_short(s):\n","entry_point":"find_short","test":"def check(candidate):\n    assert candidate('bitcoin take over the world maybe who knows perhaps') == 3\n    assert candidate('turns out random test cases are easier than writing out basic ones') == 3\n    assert candidate('lets talk about javascript the best language') == 3\n    assert candidate('i want to travel the world writing code one day') == 1\n    assert candidate('Lets all go on holiday somewhere very cold') == 2\n\n","canonical_solution":"def find_short(s):\n    return min(len(x) for x in s.split())"}
{"task_id":4562,"prompt":"\"\"\"\n=====Problem statement====\n\nFlash has invited his nemesis The Turtle (He actually was a real villain! ) to play his favourite card game, SNAP. In this game a 52 card deck is dealt out so both Flash and the Turtle get 26 random cards. \n\nEach players cards will be represented by an array like below\n\nFlash\u2019s pile:\n```[ 'A', '5', 'Q', 'Q', '6', '2', 'A', '9', '10', '6', '4', '3', '10', '9', '3', '8', 'K', 'J', 'J', 'K', '7', '9', '5', 'J', '7', '2' ]```\n\nTurtle\u2019s pile:\n```[ '8', 'A', '2', 'Q', 'K', '8', 'J', '6', '4', '8', '7', 'A', '5', 'K', '3', 'Q', '6', '9', '4', '3', '4', '10', '2', '7', '10', '5' ]```\n\nThe players take it in turn to take the top card from their deck (the first element in their array) and place it in a face up pile in the middle. Flash goes first.\n\nWhen a card is placed on the face up pile that matches the card it is placed on top of the first player to shout \u2018SNAP!\u2019 wins that round. Due to Flash's speed he wins every round.\n\nFace up pile in the middle:\n```[ 'A', '8', '5', 'A', 'Q', '2', 'Q', 'Q',```  =>  SNAP!\n\nThe face up pile of cards in the middle are added to the bottom of Flash's pile.\n\nFlash\u2019s pile after one round:\n```['6', '2', 'A', '9', '10', '6', '4', '3', '10', '9', '3', '8', 'K', 'J', 'J', 'K', '7', '9', '5', 'J', '7', '2', 'A', '8', '5', 'A', 'Q', '2', 'Q', 'Q' ]```\n\nFlash then starts the next round by putting down the next card.\n\nWhen Turtle runs out of cards the game is over.\n\nHow many times does Flash get to call Snap before Turtle runs out of cards?\n\nIf both the player put down all their cards into the middle without any matches then the game ends a draw and Flash calls SNAP 0 times.\n\"\"\"\n\n# ====== Solution ======\n\ndef round(flash_pile, turtle_pile):\n    faceup_pile = []\n    while turtle_pile:\n        for pile in flash_pile, turtle_pile:\n            faceup_pile.append(pile.pop(0))\n            if len(faceup_pile) >= 2 and faceup_pile[-1] == faceup_pile[-2]:\n                flash_pile.extend(faceup_pile)\n                return True\n\ndef snap(flash_pile, turtle_pile):\n","entry_point":"snap","test":"def check(candidate):\n    assert candidate(['3', 'K', '5', 'A', '5', '6', '7', 'J', '7', '9', '10', 'Q', 'Q', '6', '8', '7', '4', 'J', '8', '9', 'K', 'J', '10', '4', 'K', '4'],['2', '8', '9', 'Q', 'A', 'K', '6', '3', 'J', '2', '4', '3', '3', '8', 'A', '2', '6', '7', '9', '10', 'A', '5', 'Q', '10', '2', '5']) == 2\n    assert candidate(['9', '5', '4', '4', 'A', '8', '4', '3', 'K', 'J', 'J', 'Q', 'Q', '9', '8', '5', 'J', '6', '7', '6', 'A', 'J', '9', 'K', '3', '8'],['K', '10', '3', '4', '5', 'Q', '2', '7', 'A', 'A', 'Q', '10', '6', '5', 'K', '6', '7', '10', '2', '9', '2', '10', '7', '8', '2', '3']) == 6\n    assert candidate(['3', '9', '8', '2', '6', 'Q', '9', '3', '6', '9', '6', 'A', '7', '10', '6', '7', 'A', 'Q', 'Q', '10', '5', '2', '9', '4', 'A', '3'],['Q', 'K', '5', '7', '10', '4', '8', '2', '3', 'J', 'J', '5', '8', '5', '10', '8', 'K', 'K', '7', '2', 'J', '4', 'A', 'J', '4', 'K']) == 0\n    assert candidate(['3', 'Q', '2', '4', '2', 'K', '7', '8', '6', 'K', '2', '4', '3', '8', 'A', '10', 'Q', '8', '10', 'J', 'K', '7', '6', '9', 'J', '9'],['3', '4', '9', 'J', '5', '8', '4', '10', 'A', '7', 'Q', 'A', '9', '10', 'J', 'K', '2', 'Q', '3', '6', '5', '5', '5', 'A', '6', '7']) == 1\n    assert candidate(['K', '5', '7', '10', '10', '10', '7', '3', '3', '9', '9', '8', '4', 'J', '6', 'J', 'Q', 'J', 'K', '9', '4', 'A', '5', '5', '2', 'J'],['6', '4', '8', '3', '4', '10', '9', 'A', '5', 'Q', '2', 'K', 'A', '6', '2', '8', 'A', '7', '6', '7', 'Q', 'K', '8', '3', '2', 'Q']) == 2\n    assert candidate(['8', '8', '4', '7', '7', 'A', '3', '4', '5', '2', 'J', '2', 'J', 'K', '7', 'K', 'J', '10', '5', 'A', '8', '3', '3', 'Q', '9', 'K'],['6', '6', '5', 'A', 'A', 'Q', '6', '9', '6', '3', '10', '5', '10', '9', '8', '2', '10', '2', 'Q', 'J', '4', 'Q', '9', 'K', '4', '7']) == 5\n\n","canonical_solution":"def round(flash_pile, turtle_pile):\n    faceup_pile = []\n    while turtle_pile:\n        for pile in flash_pile, turtle_pile:\n            faceup_pile.append(pile.pop(0))\n            if len(faceup_pile) >= 2 and faceup_pile[-1] == faceup_pile[-2]:\n                flash_pile.extend(faceup_pile)\n                return True\n\ndef snap(flash_pile, turtle_pile):\n    for i in range(26):\n        if not round(flash_pile, turtle_pile):\n            return i"}
{"task_id":4566,"prompt":"\"\"\"\n=====Problem statement====\n\nYou need count how many valleys you will pass.\n\nStart is always from zero level.\n\nEvery time you go down below 0 level counts as an entry of a valley, and as you go up to 0 level from valley counts as an exit of a valley.\n\nOne passed valley is equal one entry and one exit of a valley.\n```\ns='FUFFDDFDUDFUFUF'\nU=UP\nF=FORWARD\nD=DOWN\n```\n\nTo represent string above\n```\n(level 1)  __\n(level 0)_\/  \\         _(exit we are again on level 0)\n(entry-1)     \\_     _\/\n(level-2)       \\\/\\_\/\n```\nSo here we passed one valley\n\"\"\"\n\n# ====== Solution ======\n\ndef counting_valleys(s): \n","entry_point":"counting_valleys","test":"def check(candidate):\n    assert candidate('UFFFD') == 0\n    assert candidate('DFFFD') == 0\n    assert candidate('UFFFU') == 0\n    assert candidate('DFFFU') == 1\n    assert candidate('UFFDDFDUDFUFU') == 1\n    assert candidate('UFFDDFDUDFUFUUFFDDFDUDFUFU') == 2\n    assert candidate('UFFDDFDUDFUFUUFFDDUFFDDUFFDDUDUDUDUDUDUUUUUUUUU') == 3\n    assert candidate('UFFDDFDUDFUFUUFFDDFDUDFUFUUFFDDFDUDFUFUUFFDDFDUDFUFU') == 4\n    assert candidate('UFFDDFDUDFUFUUFFDDFDUDFUFUUFFDDFDUDFUFUUFFDDFDUDFUFUUFFDDFDUDFUFUUFFDDFDUDFUFU') == 6\n\n","canonical_solution":"def counting_valleys(s): \n    level = 0\n    in_valley = False\n    count = 0\n    for c in s:\n        if c =='U':\n            level += 1\n        elif c=='D':\n            level -= 1\n        if level >= 0 and in_valley:\n                count += 1\n        in_valley = level < 0\n    return count"}
{"task_id":4567,"prompt":"\"\"\"\n=====Problem statement====\n\nApparently \"Put A Pillow On Your Fridge Day is celebrated on the 29th of May each year, in Europe and the U.S. The day is all about prosperity, good fortune, and having bit of fun along the way.\"\n\nAll seems very weird to me.\n\nNevertheless, you will be given an array of two strings (s). First find out if the first string contains a fridge... (i've deemed this as being 'n', as it looks like it could hold something).\n\nThen check that the second string has a pillow - deemed 'B' (struggled to get the obvious pillow-esque character).\n\nIf the pillow is on top of the fridge - it must be May 29th! Or a weird house... Return true; For clarity, on top means right on top, ie in the same index position.\n\nIf the pillow is anywhere else in the 'house', return false;\n\nThere may be multiple fridges, and multiple pillows. But you need at least 1 pillow ON TOP of a fridge to return true. Multiple pillows on fridges should return true also.\n\n100 random tests\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"pillow","test":"def check(candidate):\n    assert candidate(['EvH\/KNikBiyxfeyK\/miCMj', 'I\/HwjnHlFLlahMOKNadps']) == False\n    assert candidate(['\\\\DjQ\\\\[zv]SpG]Z\/[Qm\\\\eLL', 'amwZArsaGRmibriXBgTRZp']) == False\n    assert candidate(['n', 'B']) == True\n    assert candidate(['yF[CeAAiNihWEmKxJc\/NRMVn', 'rMeIa\\\\KAfbjuLiTnAQxNw[XB']) == True\n    assert candidate(['inECnBMAA\/u', 'ABAaIUOUx\/M']) == True\n\n","canonical_solution":"pillow=lambda s:('n','B')in zip(*s)"}
{"task_id":4569,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a sequence of items and a specific item in that sequence, return the item immediately following the item specified. If the item occurs more than once in a sequence, return the item after the first occurence. This should work for a sequence of any type.\n\nWhen the item isn't present or nothing follows it, the function should return nil in Clojure and Elixir, Nothing in Haskell, undefined in JavaScript, None in Python.\n\n```python\nnext_item([1, 2, 3, 4, 5, 6, 7], 3) # => 4\nnext_item(['Joe', 'Bob', 'Sally'], 'Bob') # => \"Sally\"\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef next_item(xs, item):\n","entry_point":"next_item","test":"def check(candidate):\n    assert candidate([1, 2, 3, 4, 5, 6, 7, 8],3) == 4\n    assert candidate(['a', 'b', 'c'],'d') == None\n    assert candidate(['a', 'b', 'c'],'c') == None\n    assert candidate('testing','t') == 'e'\n    assert candidate('Hello!','o') == '!'\n    assert candidate('Hello!','!') == None\n    assert candidate('Hello!','x') == None\n\n","canonical_solution":"def next_item(xs, item):\n    it = iter(xs)\n    for x in it:\n        if x == item:\n            break\n    return next(it, None)"}
{"task_id":4582,"prompt":"\"\"\"\n=====Problem statement====\n\nSam is an avid collector of numbers. Every time he finds a new number he throws it on the top of his number-pile. Help Sam organise his collection so he can take it to the International Number Collectors Conference in Cologne. \n\nGiven an array of numbers, your function should return an array of arrays, where each subarray contains all the duplicates of a particular number. Subarrays should be in the same order as the first occurence of the number they contain:\nAssume the input is always going to be an array of numbers. If the input is an empty array, an empty array should be returned.\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"group","test":"def check(candidate):\n    assert candidate([3, 2, 6, 2, 1, 3]) == [[3, 3], [2, 2], [6], [1]]\n    assert candidate([3, 2, 6, 2]) == [[3], [2, 2], [6]]\n    assert candidate([]) == []\n    assert candidate([1, 100, 4, 2, 4]) == [[1], [100], [4, 4], [2]]\n    assert candidate([-1, 1, -1]) == [[-1, -1], [1]]\n\n","canonical_solution":"group=lambda arr: [[n]*arr.count(n) for n in sorted(set(arr), key=arr.index)]"}
{"task_id":4590,"prompt":"\"\"\"\n=====Problem statement====\n\nCreate an OR function, without use of the 'or' keyword, that takes an list of boolean values and runs OR against all of them.\n\nAssume there will be between 1 and 6 variables, and return None for an empty list.\n\"\"\"\n\n# ====== Solution ======\n\ndef alt_or(lst):\n","entry_point":"alt_or","test":"def check(candidate):\n    assert candidate([]) == None\n    assert candidate([False, False, False, False, False, False]) == False\n    assert candidate([False, False, False, False, False, True]) == True\n    assert candidate([False, False, False, False, True, False]) == True\n    assert candidate([False, False, False, False, True, True]) == True\n    assert candidate([False, False, False, True, False, False]) == True\n    assert candidate([False, False, False, True, False, True]) == True\n    assert candidate([False, False, False, True, True, False]) == True\n    assert candidate([False, False, False, True, True, True]) == True\n    assert candidate([False, False, True, False, False, False]) == True\n    assert candidate([False, False, True, False, False, True]) == True\n    assert candidate([False, False, True, False, True, False]) == True\n    assert candidate([False, False, True, False, True, True]) == True\n    assert candidate([False, False, True, True, False, False]) == True\n    assert candidate([False, False, True, True, False, True]) == True\n    assert candidate([False, False, True, True, True, False]) == True\n    assert candidate([False, False, True, True, True, True]) == True\n    assert candidate([False, True, False, False, False, False]) == True\n    assert candidate([False, True, False, False, False, True]) == True\n    assert candidate([False, True, False, False, True, False]) == True\n    assert candidate([False, True, False, False, True, True]) == True\n    assert candidate([False, True, False, True, False, False]) == True\n    assert candidate([False, True, False, True, False, True]) == True\n    assert candidate([False, True, False, True, True, False]) == True\n    assert candidate([False, True, False, True, True, True]) == True\n    assert candidate([False, True, True, False, False, False]) == True\n    assert candidate([False, True, True, False, False, True]) == True\n    assert candidate([False, True, True, False, True, False]) == True\n    assert candidate([False, True, True, False, True, True]) == True\n    assert candidate([False, True, True, True, False, False]) == True\n    assert candidate([False, True, True, True, False, True]) == True\n    assert candidate([False, True, True, True, True, False]) == True\n    assert candidate([False, True, True, True, True, True]) == True\n    assert candidate([True, False, False, False, False, False]) == True\n    assert candidate([True, False, False, False, False, True]) == True\n    assert candidate([True, False, False, False, True, False]) == True\n    assert candidate([True, False, False, False, True, True]) == True\n    assert candidate([True, False, False, True, False, False]) == True\n    assert candidate([True, False, False, True, False, True]) == True\n    assert candidate([True, False, False, True, True, False]) == True\n    assert candidate([True, False, False, True, True, True]) == True\n    assert candidate([True, False, True, False, False, False]) == True\n    assert candidate([True, False, True, False, False, True]) == True\n    assert candidate([True, False, True, False, True, False]) == True\n    assert candidate([True, False, True, False, True, True]) == True\n    assert candidate([True, False, True, True, False, False]) == True\n    assert candidate([True, False, True, True, False, True]) == True\n    assert candidate([True, False, True, True, True, False]) == True\n    assert candidate([True, False, True, True, True, True]) == True\n    assert candidate([True, True, False, False, False, False]) == True\n    assert candidate([True, True, False, False, False, True]) == True\n    assert candidate([True, True, False, False, True, False]) == True\n    assert candidate([True, True, False, False, True, True]) == True\n    assert candidate([True, True, False, True, False, False]) == True\n    assert candidate([True, True, False, True, False, True]) == True\n    assert candidate([True, True, False, True, True, False]) == True\n    assert candidate([True, True, False, True, True, True]) == True\n    assert candidate([True, True, True, False, False, False]) == True\n    assert candidate([True, True, True, False, False, True]) == True\n    assert candidate([True, True, True, False, True, False]) == True\n    assert candidate([True, True, True, False, True, True]) == True\n    assert candidate([True, True, True, True, False, False]) == True\n    assert candidate([True, True, True, True, False, True]) == True\n    assert candidate([True, True, True, True, True, False]) == True\n    assert candidate([True, True, True, True, True, True]) == True\n    assert candidate([False, False, False, False, False]) == False\n    assert candidate([False, False, False, False, True]) == True\n    assert candidate([False, False, False, True, False]) == True\n    assert candidate([False, False, False, True, True]) == True\n    assert candidate([False, False, True, False, False]) == True\n    assert candidate([False, False, True, False, True]) == True\n    assert candidate([False, False, True, True, False]) == True\n    assert candidate([False, False, True, True, True]) == True\n    assert candidate([False, True, False, False, False]) == True\n    assert candidate([False, True, False, False, True]) == True\n    assert candidate([False, True, False, True, False]) == True\n    assert candidate([False, True, False, True, True]) == True\n    assert candidate([False, True, True, False, False]) == True\n    assert candidate([False, True, True, False, True]) == True\n    assert candidate([False, True, True, True, False]) == True\n    assert candidate([False, True, True, True, True]) == True\n    assert candidate([True, False, False, False, False]) == True\n    assert candidate([True, False, False, False, True]) == True\n    assert candidate([True, False, False, True, False]) == True\n    assert candidate([True, False, False, True, True]) == True\n    assert candidate([True, False, True, False, False]) == True\n    assert candidate([True, False, True, False, True]) == True\n    assert candidate([True, False, True, True, False]) == True\n    assert candidate([True, False, True, True, True]) == True\n    assert candidate([True, True, False, False, False]) == True\n    assert candidate([True, True, False, False, True]) == True\n    assert candidate([True, True, False, True, False]) == True\n    assert candidate([True, True, False, True, True]) == True\n    assert candidate([True, True, True, False, False]) == True\n    assert candidate([True, True, True, False, True]) == True\n    assert candidate([True, True, True, True, False]) == True\n    assert candidate([True, True, True, True, True]) == True\n    assert candidate([False, False, False, False]) == False\n    assert candidate([False, False, False, True]) == True\n    assert candidate([False, False, True, False]) == True\n    assert candidate([False, False, True, True]) == True\n    assert candidate([False, True, False, False]) == True\n    assert candidate([False, True, False, True]) == True\n    assert candidate([False, True, True, False]) == True\n    assert candidate([False, True, True, True]) == True\n    assert candidate([True, False, False, False]) == True\n    assert candidate([True, False, False, True]) == True\n    assert candidate([True, False, True, False]) == True\n    assert candidate([True, False, True, True]) == True\n    assert candidate([True, True, False, False]) == True\n    assert candidate([True, True, False, True]) == True\n    assert candidate([True, True, True, False]) == True\n    assert candidate([True, True, True, True]) == True\n    assert candidate([False, False, False]) == False\n    assert candidate([False, False, True]) == True\n    assert candidate([False, True, False]) == True\n    assert candidate([False, True, True]) == True\n    assert candidate([True, False, False]) == True\n    assert candidate([True, False, True]) == True\n    assert candidate([True, True, False]) == True\n    assert candidate([True, True, True]) == True\n    assert candidate([False, False]) == False\n    assert candidate([False, True]) == True\n    assert candidate([True, False]) == True\n    assert candidate([True, True]) == True\n    assert candidate([False]) == False\n    assert candidate([True]) == True\n\n","canonical_solution":"def alt_or(lst):\n    return any(lst) if lst else None"}
{"task_id":4597,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite\n\n```python\nfunction combine()\n```\n\nthat combines arrays by alternatingly taking elements passed to it.\n\nE.g\n\n```python\ncombine(['a', 'b', 'c'], [1, 2, 3]) == ['a', 1, 'b', 2, 'c', 3]\ncombine(['a', 'b', 'c'], [1, 2, 3, 4, 5]) == ['a', 1, 'b', 2, 'c', 3, 4, 5]\ncombine(['a', 'b', 'c'], [1, 2, 3, 4, 5], [6, 7], [8]) == ['a', 1, 6, 8, 'b', 2, 7, 'c', 3, 4, 5]\n```\n\nArrays can have different lengths.\n\"\"\"\n\n# ====== Solution ======\n\ndef combine(*args):\n","entry_point":"combine","test":"def check(candidate):\n    assert candidate(['a', 'b', 'c'],[1, 2, 3]) == ['a', 1, 'b', 2, 'c', 3]\n    assert candidate(['a', 'b', 'c'],[1, 2, 3, 4, 5]) == ['a', 1, 'b', 2, 'c', 3, 4, 5]\n    assert candidate(['a', 'b', 'c'],[1, 2, 3, 4, 5],[6, 7],[8]) == ['a', 1, 6, 8, 'b', 2, 7, 'c', 3, 4, 5]\n    assert candidate([{'a': 1}, {'b': 2}],[1, 2]) == [{'a': 1}, 1, {'b': 2}, 2]\n    assert candidate([{'a': 2, 'b': 1}, {'a': 1, 'b': 2}],[1, 2, 3, 4],[5, 6],[7]) == [{'a': 2, 'b': 1}, 1, 5, 7, {'a': 1, 'b': 2}, 2, 6, 3, 4]\n\n","canonical_solution":"def combine(*args):\n  out = list()\n  for i in range(len(max(args, key=len))): #Sometimes you just have to love python\n    for arr in args:\n      if i < len(arr): out.append(arr[i])\n  return out"}
{"task_id":4600,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite an algorithm that takes an array and moves all of the zeros to the end, preserving the order of the other elements.\n\n```python\nmove_zeros([False,1,0,1,2,0,1,3,\"a\"]) # returns[False,1,1,2,1,3,\"a\",0,0]\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef move_zeros(arr):\n","entry_point":"move_zeros","test":"def check(candidate):\n    assert candidate([1, 2, 0, 1, 0, 1, 0, 3, 0, 1]) == [1, 2, 1, 1, 3, 1, 0, 0, 0, 0]\n    assert candidate([9, 0.0, 0, 9, 1, 2, 0, 1, 0, 1, 0.0, 3, 0, 1, 9, 0, 0, 0, 0, 9]) == [9, 9, 1, 2, 1, 1, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate(['a', 0, 0, 'b', 'c', 'd', 0, 1, 0, 1, 0, 3, 0, 1, 9, 0, 0, 0, 0, 9]) == ['a', 'b', 'c', 'd', 1, 1, 3, 1, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate(['a', 0, 0, 'b', None, 'c', 'd', 0, 1, False, 0, 1, 0, 3, [], 0, 1, 9, 0, 0, {}, 0, 0, 9]) == ['a', 'b', None, 'c', 'd', 1, False, 1, 3, [], 1, 9, {}, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert candidate([0, 1, None, 2, False, 1, 0]) == [1, None, 2, False, 1, 0, 0]\n    assert candidate(['a', 'b']) == ['a', 'b']\n    assert candidate(['a']) == ['a']\n    assert candidate([0, 0]) == [0, 0]\n    assert candidate([0]) == [0]\n    assert candidate([]) == []\n\n","canonical_solution":"def move_zeros(arr):\n    l = [i for i in arr if isinstance(i, bool) or i!=0]\n    return l+[0]*(len(arr)-len(l))"}
{"task_id":4609,"prompt":"\"\"\"\n=====Problem statement====\n\nRonald's uncle left him 3 fertile chickens in his will. When life gives you chickens, you start a business selling chicken eggs which is exactly what Ronald decided to do. \n\nA chicken lays 300 eggs in its first year. However, each chicken's egg production decreases by 20% every following year (rounded down) until when it dies (after laying its quota of eggs). \n\nAfter his first successful year of business, Ronald decides to buy 3 more chickens at the start of each year.  \n\n\nYour Task: \n\nFor a given year, and life span of chicken span,  calculate how many eggs Ronald's chickens will lay him that year, whereby year=1 is when Ronald first got his inheritance and span>0.\n\nIf year=0, make sure to return \"No chickens yet!\".\n\n\nNote: \n1. All chickens have the same life span regardless of when they are bought. \n2. Let's assume all calculations are made at the end of the year so don't bother taking eggs laid per month into consideration. \n3. Each chicken's egg production goes down by 20% each year, NOT the total number of eggs produced by each 'batch' of chickens. While this might appear to be the same thing, it doesn't once non-integers come into play so take care that this is reflected in your kata!\n\"\"\"\n\n# ====== Solution ======\n\ndef egged(year, span):   \n","entry_point":"egged","test":"def check(candidate):\n    assert candidate(0,5) == 'No chickens yet!'\n    assert candidate(2,1) == 900\n    assert candidate(4,8) == 2655\n    assert candidate(74,10) == 3984\n    assert candidate(1,15) == 900\n\n","canonical_solution":"def egged(year, span):   \n    total = 0\n    eggs_per_chicken = 300\n    for i in range(min(span,year)):\n        total += 3 * eggs_per_chicken\n        eggs_per_chicken = int(eggs_per_chicken * 0.8)\n        \n    return total or \"No chickens yet!\""}
{"task_id":4632,"prompt":"\"\"\"\n=====Problem statement====\n\nFans of The Wire will appreciate this one. \nFor those that haven't seen the show, the Barksdale Organization has a simple method for encoding telephone numbers exchanged via pagers: \"Jump to the other side of the 5 on the keypad, and swap 5's and 0's.\"\n\nHere's a keypad for visualization.\n```\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502 1 \u2502 2 \u2502 3 \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 4 \u2502 5 \u2502 6 \u2502\n\u251c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2524\n\u2502 7 \u2502 8 \u2502 9 \u2502\n\u2514\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2518\n    \u2502 0 \u2502\n    \u2514\u2500\u2500\u2500\u2518\n```\n\nDetective, we're hot on their trail! We have a big pile of encoded messages here to use as evidence, but it would take way too long to decode by hand. Could you write a program to do this for us?\n\n\nWrite a funciton called decode(). Given an encoded string, return the actual phone number in string form. Don't worry about input validation, parenthesies, or hyphens.\n\"\"\"\n\n# ====== Solution ======\n\ndef decode(s):\n","entry_point":"decode","test":"def check(candidate):\n    assert candidate('4103432323') == '6957678787'\n    assert candidate('4103438970') == '6957672135'\n    assert candidate('4104305768') == '6956750342'\n    assert candidate('4102204351') == '6958856709'\n    assert candidate('4107056043') == '6953504567'\n\n","canonical_solution":"def decode(s):\n    return s.translate(str.maketrans(\"1234567890\", \"9876043215\"))"}
{"task_id":4644,"prompt":"\"\"\"\n=====Problem statement====\n\nTake a string and return a hash with all the ascii values of the characters in the string.\nReturns nil if the string is empty.\nThe key is the character, and the value is the ascii value of the character.\nRepeated characters are to be ignored and non-alphebetic characters as well.\n\"\"\"\n\n# ====== Solution ======\n\ndef char_to_ascii(string):\n","entry_point":"char_to_ascii","test":"def check(candidate):\n    assert candidate('') == None\n    assert candidate('a') == {'a': 97}\n    assert candidate('aaa') == {'a': 97}\n    assert candidate('hello world') == {'h': 104, 'e': 101, 'l': 108, 'o': 111, 'w': 119, 'r': 114, 'd': 100}\n    assert candidate('ABaa ^') == {'A': 65, 'B': 66, 'a': 97}\n\n","canonical_solution":"def char_to_ascii(string):\n    return {c: ord(c) for c in set(string) if c.isalpha()} if len(string) else None"}
{"task_id":4652,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven a number `n` we will define its scORe to be `0 | 1 | 2 | 3 | ... | n`, where `|` is the [bitwise OR operator](https:\/\/en.wikipedia.org\/wiki\/Bitwise_operation#OR).\n\nWrite a function that takes `n` and finds its scORe.\n\n---------------------\n|    n    | scORe n |\n|---------|-------- |       \n| 0       | 0 |\n| 1       | 1 |\n| 49      | 63 |\n| 1000000 | 1048575 |\n\n\"\"\"\n\n# ====== Solution ======\n\n","entry_point":"score","test":"def check(candidate):\n    assert candidate(0) == 0\n    assert candidate(1) == 1\n    assert candidate(49) == 63\n    assert candidate(1000000) == 1048575\n    assert candidate(10000000) == 16777215\n    assert candidate(1000000000000000000) == 1152921504606846975\n\n","canonical_solution":"score=lambda n:2**n.bit_length()-1"}
{"task_id":4660,"prompt":"\"\"\"\n=====Problem statement====\n\nAs a strict big brother, I do limit my young brother Vasya on time he spends on computer games. I define a prime-time as a time period till which Vasya have a permission to play computer games. I specify start hour and end hour as pair of integers.\n\nI need a function which will take three numbers - a present moment (current hour), a start hour of allowed time period and an end hour of allowed time period. The function should give answer to a question (as a boolean): \"Can Vasya play in specified time?\"\n\nIf I say that prime-time is from 12 till 15 that means that at 12:00 it's OK to play computer but at 15:00 there should be no more games.\n\nI will allow Vasya to play at least one hour a day.\n\"\"\"\n\n# ====== Solution ======\n\ndef can_i_play(now_hour, start_hour, end_hour):\n","entry_point":"can_i_play","test":"def check(candidate):\n    assert candidate(9,10,11) == False\n    assert candidate(12,12,13) == True\n    assert candidate(13,10,15) == True\n    assert candidate(14,9,14) == False\n    assert candidate(15,8,12) == False\n    assert candidate(20,21,1) == False\n    assert candidate(21,21,6) == True\n    assert candidate(17,15,3) == True\n    assert candidate(0,22,1) == True\n    assert candidate(1,22,1) == False\n    assert candidate(3,23,2) == False\n    assert candidate(20,0,23) == True\n    assert candidate(14,2,9) == False\n    assert candidate(9,20,11) == True\n    assert candidate(23,23,0) == True\n    assert candidate(11,2,9) == False\n    assert candidate(0,20,23) == False\n    assert candidate(4,0,3) == False\n    assert candidate(6,2,10) == True\n\n","canonical_solution":"def can_i_play(now_hour, start_hour, end_hour):\n      return 0<=(now_hour-start_hour)%24<(end_hour-start_hour)%24\n"}
{"task_id":4673,"prompt":"\"\"\"\n=====Problem statement====\n\nConvert a hash into an array. Nothing more, Nothing less.\n\n```\n{name: 'Jeremy', age: 24, role: 'Software Engineer'}\n```\nshould be converted into\n\n```\n[[\"name\", \"Jeremy\"], [\"age\", 24], [\"role\", \"Software Engineer\"]]\n```\n\n```if:python,javascript,crystal\n**Note**: The output array should be sorted alphabetically.\n```\n\nGood Luck!\n\"\"\"\n\n# ====== Solution ======\n\ndef convert_hash_to_array(hash):\n","entry_point":"convert_hash_to_array","test":"def check(candidate):\n    assert candidate({'name': 'Jeremy'}) == [['name', 'Jeremy']]\n    assert candidate({'name': 'Jeremy', 'age': 24}) == [['age', 24], ['name', 'Jeremy']]\n    assert candidate({'name': 'Jeremy', 'age': 24, 'role': 'Software Engineer'}) == [['age', 24], ['name', 'Jeremy'], ['role', 'Software Engineer']]\n    assert candidate({'product': 'CodeWars', 'power_level_over': 9000}) == [['power_level_over', 9000], ['product', 'CodeWars']]\n    assert candidate({}) == []\n\n","canonical_solution":"def convert_hash_to_array(hash):\n    return sorted(map(list, hash.items()))"}
{"task_id":4685,"prompt":"\"\"\"\n=====Problem statement====\n\nA number is self-descriptive when the n'th digit describes the amount n appears in the number.\n\nE.g. 21200:\n\nThere are two 0's in the number, so the first digit is 2.\n\nThere is one 1 in the number, so the second digit is 1.\n\nThere are two 2's in the number, so the third digit is 2.\n\nThere are no 3's in the number, so the fourth digit is 0.\n\nThere are no 4's in the number, so the fifth digit is 0\n\n\nNumbers can be of any length up to 9 digits and are only full integers. For a given number derive a function ```selfDescriptive(num)``` that returns; ```true``` if the number is self-descriptive or ```false``` if the number is not.\n\"\"\"\n\n# ====== Solution ======\n\nfrom collections import Counter\n\n\ndef self_descriptive(num):\n","entry_point":"self_descriptive","test":"def check(candidate):\n    assert candidate(21200) == True\n    assert candidate(3211000) == True\n    assert candidate(42101000) == True\n    assert candidate(21230) == False\n    assert candidate(11200) == False\n    assert candidate(1210) == True\n    assert candidate(51120111) == False\n    assert candidate(2020) == True\n    assert candidate(11201) == False\n    assert candidate(6210001000) == True\n\n","canonical_solution":"from collections import Counter\n\n\ndef self_descriptive(num):\n    s = [int(a) for a in str(num)]\n    cnt = Counter(s)\n    return all(cnt[i] == b for i, b in enumerate(s))\n"}
{"task_id":4698,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function with the signature shown below:\n```python\ndef is_int_array(arr):\n    return True\n```\n* returns `true  \/ True`  if every element in an array is an integer or a float with no decimals.\n* returns `true  \/ True`  if array is empty.\n* returns `false \/ False` for every other input.\n\"\"\"\n\n# ====== Solution ======\n\ndef is_int_array(a):\n","entry_point":"is_int_array","test":"def check(candidate):\n    assert candidate([]) == True\n    assert candidate([1, 2, 3, 4]) == True\n    assert candidate([-11, -12, -13, -14]) == True\n    assert candidate([1.0, 2.0, 3.0]) == True\n    assert candidate([1, 2, None]) == False\n    assert candidate(None) == False\n    assert candidate('') == False\n    assert candidate([None]) == False\n    assert candidate([1.0, 2.0, 3.0001]) == False\n    assert candidate(['-1']) == False\n\n","canonical_solution":"def is_int_array(a):\n    return isinstance(a, list) and all(isinstance(x, (int, float)) and x == int(x) for x in a)"}
{"task_id":4699,"prompt":"\"\"\"\n=====Problem statement====\n\nImagine two rings with numbers on them. The inner ring spins clockwise (decreasing by 1 each spin) and the outer ring spins counter clockwise (increasing by 1 each spin). We start with both rings aligned on 0 at the top, and on each move we spin each ring one increment. How many moves will it take before both rings show the same number at the top again?\n\nThe inner ring has integers from 0 to innerMax and the outer ring has integers from 0 to outerMax, where innerMax and outerMax are integers >= 1.\n\n```\ne.g. if innerMax is 2 and outerMax is 3 then after\n1 move: inner = 2, outer = 1\n2 moves: inner = 1, outer = 2\n3 moves: inner = 0, outer = 3\n4 moves: inner = 2, outer = 0\n5 moves: inner = 1, outer = 1\nTherefore it takes 5 moves for the two rings to reach the same number\nTherefore spinningRings(2, 3) = 5\n```\n```\ne.g. if innerMax is 3 and outerMax is 2 then after\n1 move: inner = 3, outer = 1\n2 moves: inner = 2, outer = 2\nTherefore it takes 2 moves for the two rings to reach the same number\nspinningRings(3, 2) = 2\n```\n\n---\n\nfor a bigger challenge, check out the [Performance Version](https:\/\/www.codewars.com\/kata\/59b0b7cd2a00d219ab0000c5) of this kata by @Voile\n\"\"\"\n\n# ====== Solution ======\n\nfrom itertools import count\n\ndef spinning_rings(inner_max, outer_max):\n","entry_point":"spinning_rings","test":"def check(candidate):\n    assert candidate(2,3) == 5\n    assert candidate(3,2) == 2\n    assert candidate(1,1) == 1\n    assert candidate(2,2) == 3\n    assert candidate(3,3) == 2\n\n","canonical_solution":"from itertools import count\n\ndef spinning_rings(inner_max, outer_max):\n    return next(i for i in count(1) if i % (outer_max + 1) == -i % (inner_max + 1))"}
{"task_id":4701,"prompt":"\"\"\"\n=====Problem statement====\n\nMr Leicester's cheese factory is the pride of the East Midlands, but he's feeling a little blue. It's the time of the year when **the taxman is coming round to take a slice of his cheddar** - and the final thing he has to work out is how much money he's spending on his staff. Poor Mr Leicester can barely sleep he's so stressed. Can you help? \n\n- Mr Leicester **employs 4 staff**, who together make **10 wheels of cheese every 6 minutes**.\n- Worker pay is calculated on **how many wheels of cheese they produce in a day**. \n- Mr Leicester pays his staff according to the UK living wage, which is currently **\u00a38.75p an hour**. There are **100 pence (p) to the UK pound (\u00a3)**. \n\nThe input for function payCheese will be provided as an array of five integers, one for each amount of cheese wheels produced each day.\n\nWhen the workforce don't work a nice integer number of minutes - much to the chagrin of the company accountant - Mr Leicester very generously **rounds up to the nearest hour** at the end of the week (*not the end of each day*). Which means if the workers make 574 wheels on each day of the week, they're each paid 29 hours for the week (28.699 hours rounded up) and not 30 (6 hours a day rounded up * 5).\n\nThe return value should be a string (with the \u00a3 included) of the **total \u00a3 of staff wages for that week.**\n\"\"\"\n\n# ====== Solution ======\n\nfrom math import ceil\ndef pay_cheese(arr):\n","entry_point":"pay_cheese","test":"def check(candidate):\n    assert candidate([750, 750, 750, 750, 600]) == 'L1260'\n    assert candidate([700, 750, 700, 750, 600]) == 'L1225'\n    assert candidate([574, 574, 574, 574, 574]) == 'L1015'\n    assert candidate([1, 1, 1, 1, 1]) == 'L35'\n    assert candidate([0, 0, 0, 0, 0]) == 'L0'\n\n","canonical_solution":"from math import ceil\ndef pay_cheese(arr):\n    return f'L{ceil(sum(arr) \/ 100) * 35}'"}
{"task_id":4714,"prompt":"\"\"\"\n=====Problem statement====\n\n## Task\n\nWrite a method `remainder` which takes two integer arguments, `dividend` and `divisor`, and returns the remainder when dividend is divided by divisor. Do NOT use the modulus operator (%) to calculate the remainder!\n\n#### Assumption\n\nDividend will always be `greater than or equal to` divisor.\n\n#### Notes\n\nMake sure that the implemented `remainder` function works exactly the same as the `Modulus operator (%)`.\n\n```if:java\n`SimpleInteger` is a tiny and immutable implementation of an integer number. Its interface is a very small subset of the `java.math.BigInteger` API:\n\n* `#add(SimpleInteger val)`\n* `#subtract(SimpleInteger val)`\n* `#multiply(SimpleInteger val)`\n* `#divide(SimpleInteger val)`\n* `#compareTo(SimpleInteger val)`\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef remainder(dividend,divisor):\n","entry_point":"remainder","test":"def check(candidate):\n    assert candidate(3,2) == 1\n    assert candidate(19,2) == 1\n    assert candidate(10,2) == 0\n    assert candidate(34,7) == 6\n    assert candidate(27,5) == 2\n\n","canonical_solution":"def remainder(dividend,divisor):\n    while divisor <= dividend:\n      dividend = dividend - divisor\n    return dividend"}
{"task_id":4718,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function ```x(n)``` that takes in a number ```n``` and returns an ```nxn``` array with an ```X``` in the middle. The ```X``` will be represented by ```1's``` and the rest will be ```0's```. \nE.g.\n```python\nx(5) ==  [[1, 0, 0, 0, 1],\n          [0, 1, 0, 1, 0],\n          [0, 0, 1, 0, 0],\n          [0, 1, 0, 1, 0],\n          [1, 0, 0, 0, 1]];\n          \nx(6) ==  [[1, 0, 0, 0, 0, 1],\n          [0, 1, 0, 0, 1, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 0, 1, 1, 0, 0],\n          [0, 1, 0, 0, 1, 0],\n          [1, 0, 0, 0, 0, 1]];\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef x(n):    \n","entry_point":"x","test":"def check(candidate):\n    assert candidate(1) == [[1]]\n    assert candidate(2) == [[1, 1], [1, 1]]\n    assert candidate(3) == [[1, 0, 1], [0, 1, 0], [1, 0, 1]]\n    assert candidate(4) == [[1, 0, 0, 1], [0, 1, 1, 0], [0, 1, 1, 0], [1, 0, 0, 1]]\n    assert candidate(5) == [[1, 0, 0, 0, 1], [0, 1, 0, 1, 0], [0, 0, 1, 0, 0], [0, 1, 0, 1, 0], [1, 0, 0, 0, 1]]\n    assert candidate(6) == [[1, 0, 0, 0, 0, 1], [0, 1, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0], [0, 1, 0, 0, 1, 0], [1, 0, 0, 0, 0, 1]]\n\n","canonical_solution":"def x(n):    \n    d = [[0] * n for i in range (n)]\n    for i in range(n):\n        d[i][i] = 1\n        d[i][-i-1] = 1\n    return d"}
{"task_id":4721,"prompt":"\"\"\"\n=====Problem statement====\n\nWrite a function ```convert_temp(temp, from_scale, to_scale)``` converting temperature from one scale to another. \nReturn converted temp value. \n\nRound converted temp value to an integer(!).\n\nReading: http:\/\/en.wikipedia.org\/wiki\/Conversion_of_units_of_temperature\n\n```\npossible scale inputs:\n    \"C\"  for Celsius\n    \"F\"  for Fahrenheit\n    \"K\"  for Kelvin\n    \"R\"  for Rankine\n    \"De\" for Delisle\n    \"N\"  for Newton\n    \"Re\" for R\u00e9aumur\n    \"Ro\" for R\u00f8mer\n```\n\n```temp``` is a number, ```from_scale``` and ```to_scale``` are strings. \n\n```python\nconvert_temp(   100, \"C\",  \"F\") # => 212\nconvert_temp(    40, \"Re\", \"C\") # => 50\nconvert_temp(    60, \"De\", \"F\") # => 140\nconvert_temp(373.15, \"K\",  \"N\") # => 33\nconvert_temp(   666, \"K\",  \"K\") # => 666\n```\n\"\"\"\n\n# ====== Solution ======\n\nTO_KELVIN = {\n    'C': (1, 273.15),\n    'F': (5.0 \/ 9, 459.67 * 5.0 \/ 9),\n    'R': (5.0 \/ 9, 0),\n    'De': (-2.0 \/ 3, 373.15),\n    'N': (100.0 \/ 33, 273.15),\n    'Re': (5.0 \/ 4, 273.15),\n    'Ro': (40.0 \/ 21, -7.5 * 40 \/ 21 + 273.15),\n}\n\ndef convert_temp(temp, from_scale, to_scale):\n","entry_point":"convert_temp","test":"def check(candidate):\n    assert candidate(100,'C','F') == 212\n    assert candidate(-30,'De','K') == 393\n    assert candidate(40,'Re','C') == 50\n    assert candidate(60,'De','F') == 140\n    assert candidate(373.15,'K','N') == 33\n    assert candidate(666,'K','K') == 666\n    assert candidate(60,'C','F') == 140\n    assert candidate(60,'De','C') == 60\n    assert candidate(128.25,'Ro','C') == 230\n    assert candidate(-273.15,'C','R') == 0\n    assert candidate(0,'K','R') == 0\n\n","canonical_solution":"TO_KELVIN = {\n    'C': (1, 273.15),\n    'F': (5.0 \/ 9, 459.67 * 5.0 \/ 9),\n    'R': (5.0 \/ 9, 0),\n    'De': (-2.0 \/ 3, 373.15),\n    'N': (100.0 \/ 33, 273.15),\n    'Re': (5.0 \/ 4, 273.15),\n    'Ro': (40.0 \/ 21, -7.5 * 40 \/ 21 + 273.15),\n}\n\ndef convert_temp(temp, from_scale, to_scale):\n    if from_scale == to_scale:\n        return temp\n    if from_scale != 'K':\n        (a, b) = TO_KELVIN[from_scale]\n        temp = a * temp + b\n        if to_scale == 'K':\n            return int(round(temp))\n    (a, b) = TO_KELVIN[to_scale]\n    return int(round((temp - b) \/ a))\n"}
{"task_id":4724,"prompt":"\"\"\"\n=====Problem statement====\n\nDropCaps means that the first letter of the starting word of the paragraph should be in caps and the remaining lowercase, just like you see in the newspaper. \n\nBut for a change, let's do that for each and every word of the given String. Your task is to capitalize every word that has length greater than 2, leaving smaller words as they are.\n\n*should work also on Leading and Trailing Spaces and caps.\n\n```python\ndrop_cap('apple') => \"Apple\"\ndrop_cap('apple of banana'); => \"Apple of Banana\"\ndrop_cap('one   space'); => \"One   Space\" \ndrop_cap('   space WALK   '); => \"   Space Walk   \" \n```\n\n**Note:** you will be provided atleast one word and should take string as input and return string as output.\n\"\"\"\n\n# ====== Solution ======\n\ndef drop_cap(str_):\n","entry_point":"drop_cap","test":"def check(candidate):\n    assert candidate('Apple Banana') == 'Apple Banana'\n    assert candidate('Apple') == 'Apple'\n    assert candidate('') == ''\n    assert candidate('of') == 'of'\n    assert candidate('Revelation of the contents outraged American public opinion, and helped generate') == 'Revelation of The Contents Outraged American Public Opinion, And Helped Generate'\n    assert candidate('more  than    one space between words') == 'More  Than    One Space Between Words'\n    assert candidate('  leading spaces') == '  Leading Spaces'\n    assert candidate('trailing spaces   ') == 'Trailing Spaces   '\n    assert candidate('ALL CAPS CRAZINESS') == 'All Caps Craziness'\n    assert candidate('rAnDoM CaPs CrAzInEsS') == 'Random Caps Craziness'\n\n","canonical_solution":"def drop_cap(str_):\n    return ' '.join( w.capitalize() if len(w) > 2 else w for w in str_.split(' ') )\n"}
{"task_id":4725,"prompt":"\"\"\"\n=====Problem statement====\n\nImpliment the reverse function, which takes in input n and reverses it. For instance, `reverse(123)` should return `321`. You should do this without converting the inputted number into a string.\n\"\"\"\n\n# ====== Solution ======\n\ndef reverse(n):\n","entry_point":"reverse","test":"def check(candidate):\n    assert candidate(1234) == 4321\n    assert candidate(4321) == 1234\n    assert candidate(1001) == 1001\n    assert candidate(1010) == 101\n    assert candidate(12005000) == 50021\n\n","canonical_solution":"def reverse(n):\n    m = 0\n    while n > 0:\n        n, m = n \/\/ 10, m * 10 + n % 10\n    return m"}
{"task_id":4727,"prompt":"\"\"\"\n=====Problem statement====\n\n**This Kata is intended as a small challenge for my students**\n\nCreate a function, called ``removeVowels`` (or ``remove_vowels``), that takes a string argument and returns that same string with all vowels removed (vowels are \"a\", \"e\", \"i\", \"o\", \"u\").\n\"\"\"\n\n# ====== Solution ======\n\nREMOVE_VOWS = str.maketrans('','','aeiou')\n\ndef remove_vowels(s):\n","entry_point":"remove_vowels","test":"def check(candidate):\n    assert candidate('drake') == 'drk'\n    assert candidate('scholarstem') == 'schlrstm'\n    assert candidate('codewars') == 'cdwrs'\n    assert candidate('high fives!') == 'hgh fvs!'\n    assert candidate('') == ''\n    assert candidate('i') == ''\n    assert candidate('b') == 'b'\n\n","canonical_solution":"REMOVE_VOWS = str.maketrans('','','aeiou')\n\ndef remove_vowels(s):\n    return s.translate(REMOVE_VOWS)"}
{"task_id":4730,"prompt":"\"\"\"\n=====Problem statement====\n\nWe need a function ```prime_bef_aft()``` that gives the largest prime below a certain given value ```n```, \n\n```befPrime or bef_prime``` (depending on the language), \n\nand the smallest prime larger than this value, \n\n```aftPrime\/aft_prime``` (depending on the language).\n\nThe result should be output in a list like the following:\n\n```python\nprime_bef_aft(n) == [befPrime, aftPrime]\n```\n\nIf n is a prime number it will give two primes, n will not be included in the result.\n\nLet's see some cases:\n```python\nprime_bef_aft(100) == [97, 101]\n\nprime_bef_aft(97) == [89, 101]\n\nprime_bef_aft(101) == [97, 103]\n```\nRange for the random tests: \n```1000 <= n <= 200000```\n\n(The extreme and special case n = 2 will not be considered for the tests. Thanks Blind4Basics)\n\nHappy coding!!\n\"\"\"\n\n# ====== Solution ======\n\ndef prime(a):\n    if a < 2: return False\n    if a == 2 or a == 3: return True   \n    if a % 2 == 0 or a % 3 == 0: return False\n    maxDivisor = a**0.5\n    d, i = 5, 2\n    while d <= maxDivisor:\n        if a % d == 0: return False\n        d += i \n        i = 6 - i\n \n    return True\n\ndef prime_bef_aft(num):\n","entry_point":"prime_bef_aft","test":"def check(candidate):\n    assert candidate(3) == [2, 5]\n    assert candidate(4) == [3, 5]\n    assert candidate(100) == [97, 101]\n    assert candidate(97) == [89, 101]\n    assert candidate(101) == [97, 103]\n    assert candidate(120) == [113, 127]\n    assert candidate(130) == [127, 131]\n\n","canonical_solution":"def prime(a):\n    if a < 2: return False\n    if a == 2 or a == 3: return True   \n    if a % 2 == 0 or a % 3 == 0: return False\n    maxDivisor = a**0.5\n    d, i = 5, 2\n    while d <= maxDivisor:\n        if a % d == 0: return False\n        d += i \n        i = 6 - i\n \n    return True\n\ndef prime_bef_aft(num):\n    res = []\n    for n in range(num-1, 1, -1):\n        if prime(n):\n            res.append(n)\n            break\n    for n in range(num+1, 3*num, 1):\n        if prime(n):\n            res.append(n)\n            break\n    return res"}
{"task_id":4733,"prompt":"\"\"\"\n=====Problem statement====\n\nQuantum mechanics tells us that a molecule is only allowed to have specific, discrete amounts of internal energy. The 'rigid rotor model', a model for describing rotations, tells us that the amount of rotational energy a molecule can have is given by:  \n\n`E =  B * J * (J + 1)`, \n\nwhere J is the state the molecule is in, and B is the 'rotational constant' (specific to the molecular species).\n\nWrite a function that returns an array of allowed energies for levels between Jmin and Jmax.\n\nNotes:\n\n* return empty array if Jmin is greater than Jmax (as it make no sense).\n* Jmin, Jmax are integers.\n* physically B must be positive, so return empty array if B <= 0\n\"\"\"\n\n# ====== Solution ======\n\ndef rot_energies(B, Jmin, Jmax):\n","entry_point":"rot_energies","test":"def check(candidate):\n    assert candidate(1,1,2) == [2, 6]\n    assert candidate(2,0,3) == [0, 4, 12, 24]\n    assert candidate(423,100,150) == [4272300, 4357746, 4444038, 4531176, 4619160, 4707990, 4797666, 4888188, 4979556, 5071770, 5164830, 5258736, 5353488, 5449086, 5545530, 5642820, 5740956, 5839938, 5939766, 6040440, 6141960, 6244326, 6347538, 6451596, 6556500, 6662250, 6768846, 6876288, 6984576, 7093710, 7203690, 7314516, 7426188, 7538706, 7652070, 7766280, 7881336, 7997238, 8113986, 8231580, 8350020, 8469306, 8589438, 8710416, 8832240, 8954910, 9078426, 9202788, 9327996, 9454050, 9580950]\n    assert candidate(1,2,0) == []\n    assert candidate(1,2,2) == [6]\n    assert candidate(-1.0,2,2) == []\n\n","canonical_solution":"def rot_energies(B, Jmin, Jmax):\n    return [B * J * (J + 1) for J in range(Jmin, Jmax + 1)] if B > 0 else []"}
{"task_id":4734,"prompt":"\"\"\"\n=====Problem statement====\n\nIt's bonus time in the big city! The fatcats are rubbing their paws in anticipation... but who is going to make the most money? \n\nBuild a function that takes in two arguments (salary, bonus). Salary will be an integer, and bonus a boolean.\n\nIf bonus is true, the salary should be multiplied by 10. If bonus is false, the fatcat did not make enough money and must receive only his stated salary.\n\nReturn the total figure the individual will receive as a string prefixed with \"\u00a3\" (= `\"\\u00A3\"`, JS, Go, and Java), \"$\" (C#, C++, Ruby, Clojure, Elixir, PHP and Python, Haskell, Lua) or \"\u00a5\" (Rust).\n\"\"\"\n\n# ====== Solution ======\n\ndef bonus_time(salary, bonus):\n","entry_point":"bonus_time","test":"def check(candidate):\n    assert candidate(10000,True) == '$100000'\n    assert candidate(25000,True) == '$250000'\n    assert candidate(10000,False) == '$10000'\n    assert candidate(60000,False) == '$60000'\n    assert candidate(2,True) == '$20'\n    assert candidate(78,False) == '$78'\n    assert candidate(67890,True) == '$678900'\n\n","canonical_solution":"def bonus_time(salary, bonus):\n    return \"${}\".format(salary * (10 if bonus else 1))"}
{"task_id":4738,"prompt":"\"\"\"\n=====Problem statement====\n\n## The Riddle\n\nThe King of a small country invites 1000 senators to his annual party. As a tradition, each senator brings the King a bottle of wine. Soon after, the Queen discovers that one of the senators is trying to assassinate the King by giving him a bottle of poisoned wine. Unfortunately, they do not know which senator, nor which bottle of wine is poisoned, and the poison is completely indiscernible.\n\nHowever, the King has 10 lab rats. He decides to use them as taste testers to determine which bottle of wine contains the poison. The poison when taken has no effect on the rats, until exactly 24 hours later when the infected rats suddenly die. The King needs to determine which bottle of wine is poisoned by tomorrow, so that the festivities can continue as planned.\n\nHence he only has time for one round of testing, he decides that each rat tastes multiple bottles, according to a certain scheme.\n\n\n## Your Task\n\nYou receive an array of integers (`0 to 9`), each of them is the number of a rat which died after tasting the wine bottles. Return the number of the bottle (`1..1000`) which is poisoned.\n\n\n**Good Luck!**\n\n\n*Hint: think of rats as a certain representation of the number of the bottle...*\n\"\"\"\n\n# ====== Solution ======\n\ndef find(r):\n","entry_point":"find","test":"def check(candidate):\n    assert candidate([0]) == 1\n    assert candidate([1]) == 2\n    assert candidate([2]) == 4\n    assert candidate([3]) == 8\n    assert candidate([4]) == 16\n    assert candidate([5]) == 32\n    assert candidate([6]) == 64\n    assert candidate([7]) == 128\n    assert candidate([8]) == 256\n    assert candidate([9]) == 512\n    assert candidate([3, 5, 6, 7, 8, 9]) == 1000\n    assert candidate([0, 3, 5, 4, 9, 8]) == 825\n    assert candidate([0, 1, 9, 3, 5]) == 555\n    assert candidate([0, 1, 2, 3, 4, 6]) == 95\n    assert candidate([0, 1, 3, 4]) == 27\n\n","canonical_solution":"def find(r):\n    return sum(2**i for i in r)"}
{"task_id":4740,"prompt":"\"\"\"\n=====Problem statement====\n\nGiven the triangle of consecutive odd numbers:\n\n```\n             1\n          3     5\n       7     9    11\n   13    15    17    19\n21    23    25    27    29\n...\n```\n\nCalculate the row sums of this triangle from the row index (starting at index 1) e.g.:\n\n```python\nrow_sum_odd_numbers(1); # 1\nrow_sum_odd_numbers(2); # 3 + 5 = 8\n```\n\n```if:nasm\nrow_sum_odd_numbers:\n```\n\"\"\"\n\n# ====== Solution ======\n\ndef row_sum_odd_numbers(n):\n","entry_point":"row_sum_odd_numbers","test":"def check(candidate):\n    assert candidate(1) == 1\n    assert candidate(2) == 8\n    assert candidate(13) == 2197\n    assert candidate(19) == 6859\n    assert candidate(41) == 68921\n    assert candidate(42) == 74088\n    assert candidate(74) == 405224\n    assert candidate(86) == 636056\n    assert candidate(93) == 804357\n    assert candidate(101) == 1030301\n\n","canonical_solution":"def row_sum_odd_numbers(n):\n    #your code here\n    return n ** 3"}
